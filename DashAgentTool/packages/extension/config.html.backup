<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DashAgent Configuration</title>
  <style>
    :root {
      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-tertiary: #f1f5f9;
      --text-primary: #0f172a;
      --text-secondary: #64748b;
      --text-muted: #94a3b8;
      --border-color: #e2e8f0;
      --border-light: #f1f5f9;
      --accent: #3b82f6;
      --accent-hover: #2563eb;
      --accent-light: #eff6ff;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --radius-sm: 6px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
      --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.1);
      --transition: 150ms ease;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      height: 100vh;
      overflow: hidden;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-primary);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%);
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .logo svg { width: 18px; height: 18px; color: white; }

    .header-title {
      font-size: 16px;
      font-weight: 600;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .status-dot.connected { background: var(--success); }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 500;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all var(--transition);
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover { background: var(--accent-hover); }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

    .btn-ghost {
      background: transparent;
      color: var(--text-secondary);
    }

    .btn-ghost:hover { background: var(--bg-secondary); color: var(--text-primary); }

    /* Pulse highlight animation for drawing attention */
    .pulse-highlight {
      animation: pulse-glow 0.6s ease-in-out infinite;
      background: var(--accent) !important;
      color: white !important;
    }
    @keyframes pulse-glow {
      0%, 100% { transform: scale(1); box-shadow: 0 0 5px var(--accent); }
      50% { transform: scale(1.05); box-shadow: 0 0 15px var(--accent), 0 0 30px var(--accent); }
    }

    .btn-icon {
      padding: 8px;
      background: transparent;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
    }

    .btn-icon:hover { background: var(--bg-secondary); color: var(--text-primary); }

    /* Main Layout */
    .main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    .sidebar {
      width: 240px;
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      background: var(--bg-secondary);
    }

    .nav {
      padding: 12px;
    }

    .nav-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      width: 100%;
      text-align: left;
      transition: all var(--transition);
    }

    .nav-item:hover { background: var(--bg-tertiary); color: var(--text-primary); }
    .nav-item.active { background: var(--accent-light); color: var(--accent); }
    .nav-item svg { width: 18px; height: 18px; flex-shrink: 0; }

    /* Tools Documentation Table */
    .tools-panel { padding: 20px; overflow-y: auto; }
    .tools-panel h2 { font-size: 18px; font-weight: 600; margin-bottom: 8px; color: var(--text-primary); }
    .tools-panel .subtitle { font-size: 13px; color: var(--text-secondary); margin-bottom: 20px; }
    .tools-table { width: 100%; border-collapse: collapse; font-size: 12px; }
    .tools-table th, .tools-table td { padding: 10px 12px; text-align: left; border-bottom: 1px solid var(--border-color); }
    .tools-table th { background: var(--bg-secondary); font-weight: 600; color: var(--text-primary); position: sticky; top: 0; }
    .tools-table tr:hover { background: var(--bg-tertiary); }
    .tools-table .tool-name { font-weight: 600; color: var(--accent); font-family: monospace; white-space: nowrap; }
    .tools-table .category-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: 500; }
    .tools-table .cat-data { background: #dbeafe; color: #1e40af; }
    .tools-table .cat-viz { background: #dcfce7; color: #166534; }
    .tools-table .cat-analysis { background: #fef3c7; color: #92400e; }
    .tools-table .cat-design { background: #f3e8ff; color: #7c3aed; }
    .tools-table .cat-docs { background: #e0e7ff; color: #3730a3; }
    .tools-table .dep-badge { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin: 1px; }
    .tools-table .dep-ext { background: #fee2e2; color: #991b1b; }
    .tools-table .dep-mcp { background: #cffafe; color: #0e7490; }
    .tools-table .dep-api { background: #fef9c3; color: #854d0e; }
    .tools-table .dep-ai { background: #ede9fe; color: #6d28d9; }

    .sidebar-footer {
      margin-top: auto;
      padding: 12px;
      border-top: 1px solid var(--border-color);
    }

    /* Content */
    .content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .panel { display: none; flex-direction: column; flex: 1; overflow: hidden; }
    .panel.active { display: flex; }

    /* Chat Panel */
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .message {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      max-width: 85%;
    }

    .message.user { margin-left: auto; flex-direction: row-reverse; }

    .message-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--bg-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      font-size: 14px;
    }

    .message.user .message-avatar { background: var(--accent); color: white; }
    .message.assistant .message-avatar { background: var(--bg-tertiary); }
    .message.system .message-avatar { background: #f59e0b; color: white; font-size: 12px; }
    .message.system .message-content { 
      background: rgba(245, 158, 11, 0.1); 
      border: 1px solid rgba(245, 158, 11, 0.3);
      font-size: 13px;
    }

    .message-content {
      padding: 12px 16px;
      border-radius: var(--radius-lg);
      background: var(--bg-secondary);
      font-size: 14px;
      line-height: 1.6;
    }

    .message.user .message-content {
      background: var(--accent);
      color: white;
    }

    .message-content p { margin-bottom: 8px; }
    .message-content p:last-child { margin-bottom: 0; }
    .message-content ul { margin: 8px 0; padding-left: 20px; }
    .message-content li { margin-bottom: 4px; }

    .chat-input-area {
      display: flex;
      gap: 12px;
      padding: 16px 20px;
      border-top: 1px solid var(--border-color);
      background: var(--bg-primary);
    }

    .chat-input {
      flex: 1;
      padding: 12px 16px;
      font-size: 14px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      resize: none;
      outline: none;
      font-family: inherit;
      transition: border-color var(--transition);
    }

    .chat-input:focus { border-color: var(--accent); }

    /* Design Panel */
    .design-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 20px;
      overflow: hidden;
    }

    .drop-zone {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border: 2px dashed var(--border-color);
      border-radius: var(--radius-lg);
      background: var(--bg-secondary);
      transition: all var(--transition);
      position: relative;
      min-height: 200px;
    }

    .drop-zone.dragover {
      border-color: var(--accent);
      background: var(--accent-light);
    }

    .drop-zone.has-image {
      border-style: solid;
    }

    .drop-content {
      text-align: center;
      color: var(--text-secondary);
    }

    .drop-content svg {
      width: 48px;
      height: 48px;
      margin-bottom: 12px;
      color: var(--text-muted);
    }

    .drop-content h3 {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .drop-content p {
      font-size: 13px;
    }

    .preview-image {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      border-radius: var(--radius-md);
    }

    .design-actions {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    /* Data Panel */
    .data-content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
    }

    .data-section {
      margin-bottom: 24px;
    }

    .data-section-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      margin-bottom: 12px;
    }

    .data-card {
      padding: 16px;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-color);
    }

    .data-card-title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .data-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      font-size: 13px;
      border-bottom: 1px solid var(--border-light);
    }

    .data-item:last-child { border-bottom: none; }
    .data-item-label { color: var(--text-secondary); }
    .data-item-value { font-weight: 500; }

    /* Settings Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .modal-overlay.active { display: flex; }

    .modal {
      background: var(--bg-primary);
      border-radius: var(--radius-lg);
      width: 100%;
      max-width: 480px;
      max-height: 90vh;
      overflow: hidden;
      box-shadow: var(--shadow-md);
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
    }

    .modal-title {
      font-size: 16px;
      font-weight: 600;
    }

    .modal-body {
      padding: 20px;
      overflow-y: auto;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 6px;
    }

    .form-input, .form-select {
      width: 100%;
      padding: 10px 12px;
      font-size: 14px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      outline: none;
      font-family: inherit;
      transition: border-color var(--transition);
    }

    .form-input:focus, .form-select:focus { border-color: var(--accent); }

    .form-hint {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding: 16px 20px;
      border-top: 1px solid var(--border-color);
    }

    /* Preview Panel */
    .preview-content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
    }

    .preview-container {
      min-height: 300px;
      padding: 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
    }
  </style>
</head>
<body>
  <div id="app">
    <header class="header">
      <div class="header-left">
        <div class="logo">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
            <polyline points="3.27 6.96 12 12.01 20.73 6.96"/>
            <line x1="12" y1="22.08" x2="12" y2="12"/>
          </svg>
        </div>
        <span class="header-title">DashAgent Configuration</span>
      </div>
      <div class="header-right">
        <div class="status" title="Tableau Dashboard Connection">
          <span id="status-dot" class="status-dot"></span>
          <span id="status-text">Loading...</span>
        </div>
        <button id="btn-settings" class="btn-icon" title="Settings">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="3"/>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
          </svg>
        </button>
      </div>
    </header>

    <main class="main">
      <aside class="sidebar">
        <nav class="nav">
          <button class="nav-item active" data-panel="chat">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
            </svg>
            Chat
          </button>
          <button class="nav-item" data-panel="design">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
              <circle cx="8.5" cy="8.5" r="1.5"/>
              <polyline points="21 15 16 10 5 21"/>
            </svg>
            Design
          </button>
          <button class="nav-item" data-panel="preview">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
              <line x1="8" y1="21" x2="16" y2="21"/>
              <line x1="12" y1="17" x2="12" y2="21"/>
            </svg>
            Preview
          </button>
          <button class="nav-item" data-panel="tools">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
            </svg>
            Tools
          </button>
        </nav>
        <div class="sidebar-footer">
          <button id="btn-save" class="btn btn-primary" style="width:100%">
            Save & Close
          </button>
        </div>
      </aside>

      <section class="content">
        <!-- Chat Panel -->
        <div id="panel-chat" class="panel active">
          <div id="chat-messages" class="chat-messages">
            <div class="message assistant">
              <div class="message-avatar">Dash</div>
              <div class="message-content">
                <p><strong>Welcome to DashAgent</strong> — Your AI Design Partner for Tableau dashboards.</p>
                
                <details style="margin-top:8px;">
                  <summary style="cursor:pointer; color:var(--accent); font-weight:500; font-size:13px; padding:6px 0;">
                    💡 Show available commands...
                  </summary>
                  
                  <div style="margin-top:8px; padding-left:4px;">
                    <p style="margin-top:8px;font-weight:600;color:var(--accent);font-size:13px;">Design Tools</p>
                    <ul style="margin-top:4px;font-size:13px;">
                      <li><strong>"Review my dashboard design"</strong> — Iron Viz-style scorecard</li>
                      <li><strong>"Check my colors"</strong> — Palette harmony & accessibility</li>
                      <li><strong>"Create a palette for [topic]"</strong> — Custom color palette</li>
                    </ul>
                    
                    <p style="margin-top:10px;font-weight:600;color:var(--accent);font-size:13px;">AI Image Generation</p>
                    <ul style="margin-top:4px;font-size:13px;">
                      <li><strong>"Create icons for my dashboard"</strong> — Custom AI-generated icons</li>
                      <li><strong>"Design a background"</strong> — Subtle dashboard backgrounds</li>
                    </ul>
                    
                    <p style="margin-top:10px;font-weight:600;color:var(--accent);font-size:13px;">Storytelling & Analysis</p>
                    <ul style="margin-top:4px;font-size:13px;">
                      <li><strong>"Build me a dashboard"</strong> — KPI cards, charts & views</li>
                      <li><strong>"Analyze this dashboard"</strong> — Quick profiling & insights</li>
                      <li><strong>"Which [X] has the highest [Y]?"</strong> — Segment analysis</li>
                    </ul>
                  </div>
                </details>
                
                <p style="margin-top:10px;padding:8px 10px;background:rgba(11,92,173,0.1);border-radius:8px;font-size:12px;">
                  <strong>Tip:</strong> Drop a screenshot into chat for design analysis, or use the <strong>Design tab</strong> to capture your view.
                </p>
              </div>
            </div>
          </div>
          <div class="chat-input-area">
            <button class="btn-icon" id="btn-attach" title="Attach image">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/>
              </svg>
            </button>
            <textarea id="chat-input" class="chat-input" placeholder="Ask me about your dashboard..." rows="1"></textarea>
            <button id="btn-send" class="btn btn-primary" disabled>Send</button>
            <button id="btn-clear-chat" class="btn-icon" title="Clear conversation history" style="opacity: 0.6;">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
              </svg>
            </button>
          </div>
        </div>

        <!-- Design Panel -->
        <div id="panel-design" class="panel">
          <div class="design-content">
            <div id="drop-zone" class="drop-zone">
              <div id="drop-content" class="drop-content">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                  <circle cx="8.5" cy="8.5" r="1.5"/>
                  <polyline points="21 15 16 10 5 21"/>
                </svg>
                <h3>Drop screenshot here</h3>
                <p>or click to browse</p>
              </div>
              <img id="preview-img" class="preview-image" style="display:none" />
            </div>
            <div class="design-actions">
              <button id="btn-capture" class="btn btn-ghost" title="Capture your screen">Capture Screen</button>
              <button id="btn-clear" class="btn btn-ghost" style="display:none">Clear</button>
              <button id="btn-analyze" class="btn btn-primary" disabled>Analyze Design</button>
            </div>
          </div>
        </div>

        <!-- Preview Panel -->
        <div id="panel-preview" class="panel">
          <div class="preview-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <div class="data-section-title">Generated Output</div>
              <div style="display: flex; gap: 8px;">
                <button id="btn-clear-viz" class="btn btn-ghost" style="padding: 4px 12px; font-size: 12px; display: none;">
                  Clear
                </button>
                <button id="btn-refresh-viz" class="btn btn-primary" style="padding: 4px 12px; font-size: 12px; display: none;">
                  Refresh Data
                </button>
              </div>
            </div>
            <div id="preview-container" class="preview-container">
              <p style="color:var(--text-muted);font-size:13px">No content generated yet. Use Chat to generate visualizations.</p>
            </div>
          </div>
        </div>

        <!-- Tools Documentation Panel -->
        <div id="panel-tools" class="panel">
          <div class="tools-panel">
            <h2>DashAgent MCP Tools</h2>
            <p class="subtitle">18 custom tools available for AI-powered dashboard analysis and design. Each tool integrates with Tableau Extensions API and/or Tableau MCP Server.</p>
            
            <table class="tools-table">
              <thead>
                <tr>
                  <th>Tool Name</th>
                  <th>Category</th>
                  <th>Description</th>
                  <th>Dependencies</th>
                </tr>
              </thead>
              <tbody>
                <!-- Data Profiling -->
                <tr>
                  <td class="tool-name">profile_data_for_visualization</td>
                  <td><span class="category-badge cat-data">Data</span></td>
                  <td><em>Primary.</em> Profiles worksheet data for quality, structure, and viz recommendations. <strong>Call first before any visualization.</strong></td>
                  <td><span class="dep-badge dep-ext">Extensions API</span><span class="dep-badge dep-api">getDataSourcesAsync</span></td>
                </tr>
                <tr>
                  <td class="tool-name">get_worksheet_data</td>
                  <td><span class="category-badge cat-data">Data</span></td>
                  <td>Retrieves raw data from Tableau worksheets with optional limits and data quality analysis.</td>
                  <td><span class="dep-badge dep-ext">Extensions API</span><span class="dep-badge dep-api">getSummaryDataAsync</span></td>
                </tr>
                <tr>
                  <td class="tool-name">apply_filter</td>
                  <td><span class="category-badge cat-data">Data</span></td>
                  <td>Applies categorical or range filters to worksheet data.</td>
                  <td><span class="dep-badge dep-ext">Extensions API</span><span class="dep-badge dep-api">applyFilterAsync</span></td>
                </tr>
                <tr>
                  <td class="tool-name">set_parameter</td>
                  <td><span class="category-badge cat-data">Data</span></td>
                  <td>Sets Tableau parameter values to update dashboard calculations.</td>
                  <td><span class="dep-badge dep-ext">Extensions API</span><span class="dep-badge dep-api">changeValueAsync</span></td>
                </tr>

                <!-- Visualization -->
                <tr>
                  <td class="tool-name">render_visualization</td>
                  <td><span class="category-badge cat-viz">Viz</span></td>
                  <td>Renders single charts (bar, line, pie, donut, area, table, KPI). Supports themes, average lines, and aggregation.</td>
                  <td><span class="dep-badge dep-ext">Extensions API</span><span class="dep-badge dep-api">getSummaryDataAsync</span></td>
                </tr>
                <tr>
                  <td class="tool-name">build_dashboard</td>
                  <td><span class="category-badge cat-viz">Viz</span></td>
                  <td>Creates complete multi-panel dashboards with KPIs, charts, and professional styling. One-shot dashboard builder.</td>
                  <td><span class="dep-badge dep-ext">Extensions API</span><span class="dep-badge dep-api">getSummaryDataAsync</span></td>
                </tr>
                <tr>
                  <td class="tool-name">clear_visualization</td>
                  <td><span class="category-badge cat-viz">Viz</span></td>
                  <td>Clears the preview panel content.</td>
                  <td><span class="dep-badge dep-ext">DOM Only</span></td>
                </tr>
                <tr>
                  <td class="tool-name">toggle_tooltips</td>
                  <td><span class="category-badge cat-viz">Viz</span></td>
                  <td>Toggles tooltip visibility on rendered charts.</td>
                  <td><span class="dep-badge dep-ext">DOM Only</span></td>
                </tr>

                <!-- Analysis -->
                <tr>
                  <td class="tool-name">analyze_dashboard_smart</td>
                  <td><span class="category-badge cat-analysis">Analysis</span></td>
                  <td>Primary data analysis tool. Supports quick-profile, segment-deep-dive, concentration, trend, and anomaly analysis.</td>
                  <td><span class="dep-badge dep-ext">Extensions API</span><span class="dep-badge dep-mcp">Tableau MCP</span><span class="dep-badge dep-api">query-datasource</span></td>
                </tr>
                <tr>
                  <td class="tool-name">analyze_design</td>
                  <td><span class="category-badge cat-analysis">Analysis</span></td>
                  <td>Vision AI analysis of dashboard design. Evaluates UX/UI, storytelling, and accessibility from screenshots.</td>
                  <td><span class="dep-badge dep-ai">GPT-4 Vision</span><span class="dep-badge dep-ext">Screenshot</span></td>
                </tr>

                <!-- Design Tools -->
                <tr>
                  <td class="tool-name">analyze_iron_viz_style</td>
                  <td><span class="category-badge cat-design">Design</span></td>
                  <td>Evaluates dashboard against Iron Viz competition principles. Returns scorecard with improvement suggestions.</td>
                  <td><span class="dep-badge dep-ai">GPT-4 Vision</span><span class="dep-badge dep-ext">Screenshot</span></td>
                </tr>
                <tr>
                  <td class="tool-name">analyze_color_harmony</td>
                  <td><span class="category-badge cat-design">Design</span></td>
                  <td>Analyzes color palette for harmony, WCAG accessibility, and colorblind safety.</td>
                  <td><span class="dep-badge dep-ai">GPT-4 Vision</span><span class="dep-badge dep-ext">Color Analysis</span></td>
                </tr>
                <tr>
                  <td class="tool-name">generate_tableau_palette</td>
                  <td><span class="category-badge cat-design">Design</span></td>
                  <td>Generates custom Tableau color palette (.tps Preferences file) with font recommendations.</td>
                  <td><span class="dep-badge dep-ai">LLM</span><span class="dep-badge dep-ext">TPS Generator</span></td>
                </tr>
                <tr>
                  <td class="tool-name">suggest_annotations</td>
                  <td><span class="category-badge cat-design">Design</span></td>
                  <td>Suggests where to add annotations in the dashboard with text recommendations.</td>
                  <td><span class="dep-badge dep-ext">Extensions API</span><span class="dep-badge dep-ai">LLM</span></td>
                </tr>
                <tr>
                  <td class="tool-name">transform_to_story</td>
                  <td><span class="category-badge cat-design">Design</span></td>
                  <td>Transforms data into storytelling format with hero headlines, key takeaways, and action recommendations.</td>
                  <td><span class="dep-badge dep-ext">Extensions API</span><span class="dep-badge dep-ai">LLM</span></td>
                </tr>
                <tr>
                  <td class="tool-name">generate_custom_assets</td>
                  <td><span class="category-badge cat-design">Design</span></td>
                  <td>Generates AI-powered custom assets (icons, pictograms, backgrounds) using DALL-E 3.</td>
                  <td><span class="dep-badge dep-ai">DALL-E 3</span></td>
                </tr>

                <!-- Documentation -->
                <tr>
                  <td class="tool-name">generate_documentation</td>
                  <td><span class="category-badge cat-docs">Docs</span></td>
                  <td>Auto-generates documentation for the connected Tableau dashboard.</td>
                  <td><span class="dep-badge dep-ext">Extensions API</span><span class="dep-badge dep-api">getDataSourcesAsync</span></td>
                </tr>
                <tr>
                  <td class="tool-name">parse_workbook_xml</td>
                  <td><span class="category-badge cat-docs">Docs</span></td>
                  <td>Extracts metadata, calculated fields, and parameters from Tableau workbook XML.</td>
                  <td><span class="dep-badge dep-mcp">Tableau MCP</span><span class="dep-badge dep-api">download-workbook</span></td>
                </tr>
              </tbody>
            </table>

            <div style="margin-top: 24px; padding: 16px; background: var(--bg-secondary); border-radius: var(--radius-md);">
              <h3 style="font-size: 14px; margin-bottom: 12px;">Dependency Legend</h3>
              <div style="display: flex; flex-wrap: wrap; gap: 12px; font-size: 12px;">
                <div><span class="dep-badge dep-ext">Extensions API</span> Tableau Extensions JavaScript API</div>
                <div><span class="dep-badge dep-api">API Method</span> Specific Tableau API method called</div>
                <div><span class="dep-badge dep-mcp">Tableau MCP</span> Tableau MCP Server (REST API)</div>
                <div><span class="dep-badge dep-ai">AI Model</span> AI/LLM integration (GPT-4, DALL-E, etc.)</div>
              </div>
            </div>

            <div style="margin-top: 16px; padding: 16px; background: linear-gradient(135deg, #eff6ff 0%, #f3e8ff 100%); border-radius: var(--radius-md);">
              <h3 style="font-size: 14px; margin-bottom: 8px;">Recommended Workflow</h3>
              <ol style="font-size: 12px; color: var(--text-secondary); padding-left: 20px;">
                <li><strong>profile_data_for_visualization</strong> — Understand your data first</li>
                <li><strong>analyze_dashboard_smart</strong> — Get insights and recommendations</li>
                <li><strong>build_dashboard</strong> or <strong>render_visualization</strong> — Create visualizations</li>
                <li><strong>analyze_iron_viz_style</strong> — Get design feedback</li>
                <li><strong>generate_tableau_palette</strong> — Enhance colors if needed</li>
              </ol>
            </div>
          </div>
        </div>
      </section>
    </main>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay">
      <div class="modal">
        <div class="modal-header">
          <span class="modal-title">Settings</span>
          <button id="btn-close-settings" class="btn-icon">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"/>
              <line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
          </button>
        </div>
        <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
          <!-- API Keys Section -->
          <div style="background: #f8fafc; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
            <h4 style="margin: 0 0 12px 0; font-size: 14px; color: #1e40af;">🔑 API Keys</h4>
            <div class="form-group">
              <label class="form-label">OpenAI API Key</label>
              <input type="password" id="openai-api-key" class="form-input" placeholder="sk-..." />
              <p class="form-hint">Required for GPT-4o vision and chat</p>
            </div>
            <div class="form-group">
              <label class="form-label">Anthropic API Key</label>
              <input type="password" id="anthropic-api-key" class="form-input" placeholder="sk-ant-..." />
              <p class="form-hint">Required for Claude models</p>
            </div>
          </div>
          
          <!-- Model Selection by Task -->
          <div style="background: #f0fdf4; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
            <h4 style="margin: 0 0 12px 0; font-size: 14px; color: #065f46;">🤖 Model Selection by Task</h4>
            
            <div class="form-group">
              <label class="form-label">Vision / Design Analysis</label>
              <select id="model-vision" class="form-select">
                <optgroup label="OpenAI GPT-5 Series (Latest)">
                  <option value="openai:gpt-5.2">GPT-5.2 (Best overall)</option>
                  <option value="openai:gpt-5.2-pro">GPT-5.2 Pro (Smartest)</option>
                  <option value="openai:gpt-5">GPT-5</option>
                  <option value="openai:gpt-5-mini">GPT-5 Mini (Fast)</option>
                </optgroup>
                <optgroup label="OpenAI GPT-4 Series">
                  <option value="openai:gpt-4.1">GPT-4.1 (Smartest non-reasoning)</option>
                  <option value="openai:gpt-4o">GPT-4o (Great for vision)</option>
                  <option value="openai:gpt-4o-mini">GPT-4o Mini (Faster)</option>
                </optgroup>
                <optgroup label="Anthropic Claude 4.5 (Latest)">
                  <option value="anthropic:claude-opus-4-5-20251101">Claude Opus 4.5 (Best overall)</option>
                  <option value="anthropic:claude-sonnet-4-5">Claude Sonnet 4.5 (Balanced)</option>
                  <option value="anthropic:claude-haiku-4-5">Claude Haiku 4.5 (Fast)</option>
                </optgroup>
                <optgroup label="Anthropic Claude 4">
                  <option value="anthropic:claude-sonnet-4-20250514">Claude Sonnet 4</option>
                  <option value="anthropic:claude-3-5-sonnet-20241022">Claude 3.5 Sonnet</option>
                </optgroup>
              </select>
              <p class="form-hint">Used for: Screenshot analysis, design review, accessibility audit</p>
            </div>
            
            <div class="form-group">
              <label class="form-label">Code / HTML Generation</label>
              <select id="model-generation" class="form-select">
                <optgroup label="Anthropic Claude 4.5 (Recommended)">
                  <option value="anthropic:claude-opus-4-5-20251101">Claude Opus 4.5 (Best for code)</option>
                  <option value="anthropic:claude-sonnet-4-5">Claude Sonnet 4.5 (Excellent)</option>
                  <option value="anthropic:claude-haiku-4-5">Claude Haiku 4.5 (Fast)</option>
                </optgroup>
                <optgroup label="Anthropic Claude 4">
                  <option value="anthropic:claude-sonnet-4-20250514">Claude Sonnet 4</option>
                  <option value="anthropic:claude-3-5-sonnet-20241022">Claude 3.5 Sonnet</option>
                  <option value="anthropic:claude-3-opus-20240229">Claude 3 Opus</option>
                </optgroup>
                <optgroup label="OpenAI GPT-5 Series">
                  <option value="openai:gpt-5.2">GPT-5.2 (Excellent for code)</option>
                  <option value="openai:gpt-5.2-pro">GPT-5.2 Pro</option>
                  <option value="openai:gpt-5-mini">GPT-5 Mini (Fast)</option>
                </optgroup>
                <optgroup label="OpenAI GPT-4 Series">
                  <option value="openai:gpt-4o">GPT-4o</option>
                  <option value="openai:gpt-4o-mini">GPT-4o Mini</option>
                </optgroup>
              </select>
              <p class="form-hint">Used for: Dashboard redesign, HTML/CSS generation</p>
            </div>
            
            <div class="form-group">
              <label class="form-label">Data Analysis / Chat</label>
              <select id="model-analysis" class="form-select">
                <optgroup label="OpenAI GPT-5 Series (Latest)">
                  <option value="openai:gpt-5.2">GPT-5.2 (Best overall)</option>
                  <option value="openai:gpt-5-mini">GPT-5 Mini (Balanced)</option>
                  <option value="openai:gpt-5-nano">GPT-5 Nano (Fastest)</option>
                </optgroup>
                <optgroup label="OpenAI GPT-4 Series">
                  <option value="openai:gpt-4o">GPT-4o (Balanced)</option>
                  <option value="openai:gpt-4o-mini">GPT-4o Mini (Fast)</option>
                </optgroup>
                <optgroup label="Anthropic Claude 4.5 (Latest)">
                  <option value="anthropic:claude-opus-4-5-20251101">Claude Opus 4.5 (Best)</option>
                  <option value="anthropic:claude-sonnet-4-5">Claude Sonnet 4.5</option>
                  <option value="anthropic:claude-haiku-4-5">Claude Haiku 4.5 (Fast)</option>
                </optgroup>
                <optgroup label="Anthropic Claude 4">
                  <option value="anthropic:claude-sonnet-4-20250514">Claude Sonnet 4</option>
                  <option value="anthropic:claude-3-5-sonnet-20241022">Claude 3.5 Sonnet</option>
                  <option value="anthropic:claude-3-haiku-20240307">Claude 3 Haiku (Fastest)</option>
                </optgroup>
              </select>
              <p class="form-hint">Used for: Data profiling, trend analysis, tool execution, chat</p>
            </div>
          </div>
          
          <!-- MCP Server -->
          <div style="background: #faf5ff; padding: 12px; border-radius: 8px;">
            <h4 style="margin: 0 0 12px 0; font-size: 14px; color: #5b21b6;">🔌 MCP Server</h4>
            <div class="form-group">
              <label class="form-label">MCP Server URL</label>
              <input type="text" id="mcp-url" class="form-input" value="ws://localhost:3001" />
              <p class="form-hint">WebSocket URL for the MCP server</p>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button id="btn-cancel-settings" class="btn btn-ghost">Cancel</button>
          <button id="btn-save-settings" class="btn btn-primary">Save Settings</button>
        </div>
      </div>
    </div>
  </div>

  <script src="./js/tableau.extensions.1.latest.js"></script>
  <!-- html2pdf for PDF generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // Wait for DOM and Tableau API to be ready
    window.addEventListener('DOMContentLoaded', function() {
      // Check if Tableau Extensions API is available
      if (typeof tableau === 'undefined' || !tableau.extensions) {
        document.getElementById('status-text').textContent = 'Error: Tableau API not loaded';
        console.error('Tableau Extensions API not available');
        return;
      }
      
      initDashAgent();
    });
    
    function initDashAgent() {
      // State
      let uploadedImage = null;
      let generatedHtml = '';
      let mcpSocket = null;
      let mcpRequestId = 0;
      let mcpCallbacks = {};
      let dashboardContext = null; // Stores dashboard info for LLM context
      let conversationHistory = []; // Keep conversation history for context
      let lastGeneratedAnalysis = null; // Stores last analysis for follow-up questions

      // Settings - Multi-model configuration
      const settings = {
        // API Keys for both providers
        openaiApiKey: localStorage.getItem('dashagent_openai_apikey') || '',
        anthropicApiKey: localStorage.getItem('dashagent_anthropic_apikey') || '',
        
        // Model selection by task type (format: "provider:model")
        modelVision: localStorage.getItem('dashagent_model_vision') || 'openai:gpt-5.2',
        modelGeneration: localStorage.getItem('dashagent_model_generation') || 'anthropic:claude-sonnet-4-20250514',
        modelAnalysis: localStorage.getItem('dashagent_model_analysis') || 'openai:gpt-5.2',
        
        // Legacy fallbacks (for backward compatibility)
        get provider() { return this.modelAnalysis.split(':')[0]; },
        get apiKey() { return this.provider === 'openai' ? this.openaiApiKey : this.anthropicApiKey; },
        get model() { return this.modelAnalysis.split(':')[1]; },
        
        // MCP Server
        mcpUrl: localStorage.getItem('dashagent_mcpurl') || 'ws://localhost:3001',
        
        // Helper to get model config for a task type
        getModelConfig(taskType) {
          let modelString;
          switch (taskType) {
            case 'vision': modelString = this.modelVision; break;
            case 'generation': modelString = this.modelGeneration; break;
            case 'analysis': 
            default: modelString = this.modelAnalysis; break;
          }
          const [provider, model] = modelString.split(':');
          const apiKey = provider === 'openai' ? this.openaiApiKey : this.anthropicApiKey;
          return { provider, model, apiKey };
        },
        
        // Helper to get the correct token parameter for OpenAI models
        // max_tokens is deprecated, max_completion_tokens is the new standard
        getOpenAITokenParam(model, tokens = 4096) {
          // Use max_completion_tokens for all OpenAI models (max_tokens is deprecated)
          return { max_completion_tokens: tokens };
        }
      };

      // DOM Elements
      const chatMessages = document.getElementById('chat-messages');
      const chatInput = document.getElementById('chat-input');
      const btnSend = document.getElementById('btn-send');
      const btnAttach = document.getElementById('btn-attach');
      const dropZone = document.getElementById('drop-zone');
      const dropContent = document.getElementById('drop-content');
      const previewImg = document.getElementById('preview-img');
      const btnClear = document.getElementById('btn-clear');
      const btnAnalyze = document.getElementById('btn-analyze');
      const btnRefreshData = document.getElementById('btn-refresh-data');
      const dashboardInfo = document.getElementById('dashboard-info');
      const previewContainer = document.getElementById('preview-container');
      const btnRefreshViz = document.getElementById('btn-refresh-viz');
      const btnClearViz = document.getElementById('btn-clear-viz');
      const btnSave = document.getElementById('btn-save');
      const btnSettings = document.getElementById('btn-settings');
      const settingsModal = document.getElementById('settings-modal');
      const btnCloseSettings = document.getElementById('btn-close-settings');
      const btnCancelSettings = document.getElementById('btn-cancel-settings');
      const btnSaveSettings = document.getElementById('btn-save-settings');
      const statusDot = document.getElementById('status-dot');
      const statusText = document.getElementById('status-text');
      const btnClearChat = document.getElementById('btn-clear-chat');
      
      // Clear chat button handler - resets conversation history
      btnClearChat.addEventListener('click', () => {
        // Clear conversation history
        conversationHistory = [];
        
        // Clear chat messages UI (keep only the welcome message)
        const messages = chatMessages.querySelectorAll('.message');
        messages.forEach((msg, index) => {
          if (index > 0) msg.remove(); // Keep first message (welcome)
        });
        
        // Add confirmation message
        addMessage('system', '🗑️ **Chat cleared** — Conversation history reset. Ready for a fresh start!');
        console.log('[DashAgent] Conversation history cleared');
      });
      
      // Clear visualization button handler
      btnClearViz.addEventListener('click', () => {
        // Clear the preview container
        previewContainer.innerHTML = '<p style="color:var(--text-muted);font-size:13px">No content generated yet. Use Chat to generate visualizations.</p>';
        generatedHtml = '';
        
        // Reset preview container styling (remove dark theme)
        previewContainer.style.backgroundColor = '';
        previewContainer.style.borderColor = '';
        
        // Clear viz configs and listeners
        currentVizConfigs = [];
        for (const listener of vizEventListeners) {
          try { listener.unregister(); } catch (e) {}
        }
        vizEventListeners = [];
        
        // Clear localStorage
        localStorage.removeItem('dashagent_viz_configs');
        
        // Hide buttons
        btnRefreshViz.style.display = 'none';
        btnClearViz.style.display = 'none';
        
        console.log('Visualizations cleared');
      });
      
      // Refresh button click handler - use window function defined outside DOMContentLoaded
      btnRefreshViz.addEventListener('click', async () => {
        if (currentVizConfigs.length === 0) return;
        
        btnRefreshViz.textContent = 'Refreshing...';
        btnRefreshViz.disabled = true;
        
        try {
          const htmlParts = [];
          for (const config of currentVizConfigs) {
            try {
              const vizHtml = await renderVisualization(config);
              htmlParts.push(vizHtml);
            } catch (e) {
              htmlParts.push(`<div style="padding: 20px; color: red;">Error: ${e.message}</div>`);
            }
          }
          
          const container = document.getElementById('preview-container');
          container.innerHTML = `<div class="dashboard-container" style="display: flex; flex-direction: column; gap: 16px;">${htmlParts.join('')}</div>`;
          generatedHtml = container.innerHTML;
        } catch (e) {
          const container = document.getElementById('preview-container');
          container.innerHTML = `<div style="padding: 20px; color: red;">Refresh error: ${e.message}</div>`;
        }
        
        btnRefreshViz.textContent = 'Refresh Data';
        btnRefreshViz.disabled = false;
      });

      // Navigation
      document.querySelectorAll('.nav-item').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.nav-item').forEach(b => b.classList.remove('active'));
          document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
          btn.classList.add('active');
          document.getElementById('panel-' + btn.dataset.panel).classList.add('active');
        });
      });

      // Chat input
      chatInput.addEventListener('input', () => {
        btnSend.disabled = !chatInput.value.trim();
        chatInput.style.height = 'auto';
        chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
      });

      chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          if (!btnSend.disabled) sendMessage();
        }
      });

      btnSend.addEventListener('click', sendMessage);

      async function sendMessage() {
        const text = chatInput.value.trim();
        if (!text) return;

        addMessage('user', text);
        chatInput.value = '';
        btnSend.disabled = true;
        chatInput.style.height = 'auto';

        // Add user message to history
        conversationHistory.push({ role: 'user', content: text });
        
        // Warn user when conversation history is getting long (will be truncated)
        const MAX_HISTORY = 20;
        if (conversationHistory.length >= MAX_HISTORY) {
          const turnsKept = Math.floor(MAX_HISTORY / 2);
          console.log(`[DashAgent] Conversation history at ${conversationHistory.length} messages, will keep last ${MAX_HISTORY}`);
          // Show warning once when we first hit the limit
          if (conversationHistory.length === MAX_HISTORY || conversationHistory.length === MAX_HISTORY + 1) {
            addMessage('system', `⚠️ **Context limit reached** — I'll remember only the last ${turnsKept} exchanges. For best results on new topics, click "Clear Chat" to start fresh.`);
          }
        }

        // Show thinking indicator
        const thinkingId = showThinking();

        try {
          // Route chat through MCP server (centralized LLM handler)
          const response = await sendChatToMCP(text);
          removeThinking(thinkingId);
          addMessage('assistant', response);
          
          // Add assistant response to history
          conversationHistory.push({ role: 'assistant', content: response });

          // Check if response contains HTML
          const htmlMatch = response.match(/```html([\s\S]*?)```/);
          if (htmlMatch) {
            generatedHtml = htmlMatch[1].trim();
            previewContainer.innerHTML = generatedHtml;
          }
        } catch (error) {
          removeThinking(thinkingId);
          addMessage('assistant', 'Error: ' + error.message);
        } finally {
          btnSend.disabled = false;
        }
      }
      
      // Send chat message to MCP server for centralized LLM handling
      // This routes all chat through MCP server which has the single source of truth for tools
      async function sendChatToMCP(message) {
        const modelConfig = settings.getModelConfig('analysis');
        
        if (!modelConfig.apiKey) {
          const providerName = modelConfig.provider === 'openai' ? 'OpenAI' : 'Anthropic';
          throw new Error(`Please configure your ${providerName} API key in Settings (needed for chat/analysis)`);
        }
        
        // Build system prompt with dashboard context
        const systemPrompt = buildSystemPrompt();
        
        return new Promise((resolve, reject) => {
          // Ensure MCP connection
          if (!mcpSocket || mcpSocket.readyState !== WebSocket.OPEN) {
            connectMCP();
            // Wait a bit for connection
            setTimeout(() => {
              if (!mcpSocket || mcpSocket.readyState !== WebSocket.OPEN) {
                reject(new Error('Could not connect to MCP server. Make sure it is running.'));
                return;
              }
              doSendChat();
            }, 500);
          } else {
            doSendChat();
          }
          
          function doSendChat() {
            const requestId = 'chat_' + Date.now();
            
            // Set up response handler
            const messageHandler = (event) => {
              try {
                const data = JSON.parse(event.data);
                if (data.type === 'chat-response' && data.requestId === requestId) {
                  mcpSocket.removeEventListener('message', messageHandler);
                  if (data.error) {
                    reject(new Error(data.error));
                  } else {
                    resolve(data.response);
                  }
                }
              } catch (e) {
                console.error('Error parsing chat response:', e);
              }
            };
            
            mcpSocket.addEventListener('message', messageHandler);
            
            // Send chat request to MCP server
            mcpSocket.send(JSON.stringify({
              type: 'chat',
              requestId,
              chatMessage: message,
              conversationHistory: conversationHistory.slice(-20),
              modelConfig: {
                provider: modelConfig.provider,
                model: modelConfig.model,
                apiKey: modelConfig.apiKey,
              },
              systemPrompt,
              dashboardContext,
            }));
            
            // Timeout after 60 seconds (LLM can be slow)
            setTimeout(() => {
              mcpSocket.removeEventListener('message', messageHandler);
              reject(new Error('Chat request timed out after 60 seconds'));
            }, 60000);
          }
        });
      }

      function showThinking() {
        const id = 'thinking-' + Date.now();
        const modelConfig = settings.getModelConfig('analysis');
        const modelLabel = modelConfig.model.split('-').slice(0, 2).join('-'); // e.g., "gpt-4o" or "claude-sonnet"
        const div = document.createElement('div');
        div.id = id;
        div.className = 'message assistant';
        div.innerHTML = `
          <div class="message-avatar">Dash</div>
          <div class="message-content">
            <p style="color:var(--text-muted)">Thinking...</p>
            <p style="font-size:11px;color:var(--text-muted);opacity:0.7;margin-top:4px;">Using ${modelLabel}</p>
          </div>
        `;
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return id;
      }

      function removeThinking(id) {
        const el = document.getElementById(id);
        if (el) el.remove();
      }

      // NOTE: LLM calling functions removed - now handled by MCP server
      // Chat is routed through sendChatToMCP() which uses MCP server's centralized LLM handler

      function buildSystemPrompt() {
        let prompt = `You are Dash, an AI Sr. Business Intelligence Analyst for Tableau dashboards. Today is ${new Date().toLocaleDateString()}.

You have tools available to interact with the dashboard:
- analyze_dashboard_smart: PRIMARY TOOL for data analysis (statistics, insights, patterns, trends)
- apply_filter: Apply or exclude filter values on worksheets
- set_parameter: Change parameter values
- get_worksheet_data: Retrieve data from a worksheet
- generate_documentation: Create Markdown documentation of dashboard structure
- render_visualization: Create live visualizations using REAL Tableau data

CRITICAL: CONVERSATION vs NEW ANALYSIS

**FOLLOW-UP QUESTIONS** - Do NOT call analyze_dashboard_smart again:
- "What can you summarize?" → Use conversation history to respond
- "Explain the findings" → Summarize based on previous analysis in chat history
- "What does this mean?" → Interpret based on context
- "Tell me more about X" → Elaborate using previous data
- Questions about data that was ALREADY analyzed → Respond conversationally

**NEW ANALYSIS REQUESTS** - Call analyze_dashboard_smart:
- "Analyze this dashboard" → Run new analysis
- "Do a fresh analysis" → Run new analysis  
- "Run concentration analysis" → Run specific analysis type
- "Check for anomalies" → Run anomaly scan

TOOL SELECTION:

1. For NEW DATA ANALYSIS requests:
   → Use analyze_dashboard_smart
   → Only when user explicitly asks for NEW analysis

2. For FOLLOW-UP QUESTIONS about previous analysis:
   → DO NOT call any tool
   → Respond conversationally using the conversation history
   → Reference the data/insights from the previous analysis

3. For VISUALIZATION requests (create chart, show graph):
   → Use render_visualization

4. For DOCUMENTATION requests:
   → Use generate_documentation

⚠️ CRITICAL: DATE FILTER BEHAVIOR ⚠️
- NEVER automatically apply date filters when creating time series charts
- When user asks for a time series "by date" or "over time", show ALL dates by default
- Only filter dates if the user EXPLICITLY asks to filter (e.g., "show me last month" or "filter to October")
- If the user says "all dates" or "expand to all dates", use apply_filter with action="clear" to remove date filters

VISUALIZATION BEST PRACTICES (CRITICAL - ALWAYS FOLLOW):

1. COLOR USAGE:
   - For bar charts (ranked data): Use SINGLE color (blue, green, purple, orange, teal)
   - NEVER use rainbow/different colors for each bar in a ranked chart
   - For pie/donut charts: Use 'tableau' or 'categorical' for distinct colors
   - When showing multiple charts for the SAME metric: Use the SAME color across all charts
   - When showing DIFFERENT metrics: Use DIFFERENT colors (e.g., volume=blue, rate=green)

2. MULTI-CHART DASHBOARDS:
   - Group related metrics with consistent colors
   - Volume metrics (counts, totals): Use blues or teals
   - Rate metrics (percentages, averages): Use greens or oranges
   - Comparison metrics: Use purples

3. LAYOUT:
   - Use layout='half' for side-by-side comparisons
   - Limit to 2-4 visualizations per view
   - KPIs at the top, details below

4. DATA DISPLAY:
   - Limit bars to 7-10 items max for readability
   - Sort by value (desc) for ranked charts
   - Always show value labels (showValues: true)`;

        // Add last analysis context if available
        if (lastGeneratedAnalysis) {
          prompt += `

=== RECENT ANALYSIS RESULT ===
The following analysis was recently generated. Use this to answer follow-up questions WITHOUT calling analyze_dashboard_smart again:

${lastGeneratedAnalysis.markdown?.substring(0, 3000) || 'Analysis available in conversation history'}
=== END RECENT ANALYSIS ===`;
        }

        prompt += `

BUILDING MULTI-VISUALIZATION DASHBOARDS:
When creating a complete dashboard with multiple visualizations:
1. PREFERRED: Use **build_dashboard** tool - it auto-analyzes data, selects optimal chart types, and builds a cohesive dashboard
2. build_dashboard automatically applies best practices: single colors for bar charts, proper KPIs, professional layout
3. ONLY use render_visualization if creating a single specific chart

CREATING SINGLE CHARTS (render_visualization):
**⚠️ ALWAYS follow this workflow for single charts:**
1. User asks for a chart (e.g., "show me Clickthrough Rate by Name")
2. FIRST call **confirm_chart_fields** with:
   - worksheet: the worksheet name
   - requestedDimension: EXACTLY what user said (e.g., "Name" - NOT "Program Name")
   - requestedMeasure: EXACTLY what user said (e.g., "Clickthrough Rate")
3. Show the confirmation to the user and wait for their response
4. ONLY AFTER user confirms, call render_visualization with the EXACT matched field names

**CRITICAL:** When user says "by Name", use "Name" as requestedDimension, NOT "Program Name".
Use the EXACT words the user provides. Do not substitute similar-sounding fields.

NEVER just give text advice about design. ALWAYS demonstrate by creating actual visualizations.
When user asks to "create a dashboard" or "build visuals" or "visualize the data":
→ Use **build_dashboard** first (it's smarter and creates cohesive layouts)
→ Use confirm_chart_fields + render_visualization for single-chart requests`;

        if (dashboardContext) {
          prompt += `

=== DASHBOARD CONTEXT ===
Dashboard Name: ${dashboardContext.dashboardName || 'Unknown'}

Worksheets (${dashboardContext.worksheets?.length || 0}):
${dashboardContext.worksheets?.map(w => {
  const name = w.name || w;
  const fields = w.fields?.length > 0 ? ` (fields: ${w.fields.map(f => f.name).join(', ')})` : '';
  return '  - ' + name + fields;
}).join('\n') || '  None'}

📊 AVAILABLE DIMENSIONS (categorical fields for grouping/segmentation):
${dashboardContext.availableDimensions?.length > 0 
  ? dashboardContext.availableDimensions.map(d => '  - ' + d).join('\n') 
  : '  None detected'}

📈 AVAILABLE MEASURES (numeric fields for aggregation):
${dashboardContext.availableMeasures?.length > 0 
  ? dashboardContext.availableMeasures.map(m => '  - ' + m).join('\n') 
  : '  None detected'}

⚠️ CRITICAL: When user asks to segment/group by a field name, use ONLY dimensions from the list above.
If user says "by Name", use "Name" NOT "Program Name" (unless "Name" is not available).
ALWAYS match user's requested field to the exact dimension name in the list above.

Parameters (${dashboardContext.parameters?.length || 0}):
${dashboardContext.parameters?.map(p => '  - ' + p.name + (p.currentValue ? ' = ' + p.currentValue : '')).join('\n') || '  None'}

Filters:
${dashboardContext.filters?.map(f => '  - ' + f.worksheet + ': ' + f.fieldName + ' (' + f.filterType + ')').join('\n') || '  None'}
=== END DASHBOARD CONTEXT ===`;
        } else {
          prompt += `

NOTE: Dashboard context is not available yet. Ask the user to refresh or check the connection.`;
        }

        return prompt;
      }

      // NOTE: Tool definitions removed - now handled by MCP server
      // All tools are defined in packages/mcp-server/src/tools/index.ts
      // The extension is now a thin client that routes chat through MCP server
      
      // Store current visualization config for auto-refresh
      let currentVizConfigs = []; // Array to track multiple visualizations
      let vizEventListeners = [];
      let refreshDebounceTimer = null;
      let dashboardBaseHtml = ''; // HTML from build_dashboard that should be preserved when appending
      let tooltipsEnabled = true; // Global tooltip toggle - default ON
      
      // ==================== STORY CACHE SYSTEM ====================
      // Multi-stage pipeline cache for transform_to_story
      const storyCache = {
        // Cache validation key
        cacheKey: {
          worksheetNames: [],
          dataHash: null,
          rowCount: 0,
          filterState: '',
          timestamp: null
        },
        
        // Staleness tracking
        isStale: true,
        staleReason: 'initial',
        
        // Stage 1: Extracted & computed data (no LLM)
        extractedData: {
          rankings: {},       // { 'Open Rate': [{ name, value, formatted }] }
          statistics: {},     // { 'Open Rate': { min, max, avg, median, stdDev } }
          topPerformers: {},  // { dimension: { measure: topItem } }
          totals: {},         // { 'Sends': 15000 }
          anomalies: [],      // [{ field, value, reason }]
          dimensionBreakdowns: {}, // { 'Program Name': [{ name, metrics: {} }] }
          rawMetrics: []      // All extracted metrics with proper formatting
        },
        
        // Stage 2: LLM analysis result (cached)
        analysisResult: {
          heroHeadline: null,
          keyTakeaway: null,
          insights: [],
          recommendations: [],
          trustStatement: null,
          analysisAngle: null,
          audience: null
        },
        
        // Stage 3: Design preferences (current session)
        designPreferences: {
          theme: 'professional',
          colorScheme: ['#0B5CAD', '#1F9FB5', '#F4A261', '#E76F51'],
          layout: 'standard',
          emphasis: null
        },
        
        // Stage 4: Exploration state (for data science workflows)
        explorationState: {
          // Full field profiles
          fieldProfiles: {},      // { fieldName: { type, stats, distribution, quality } }
          // Correlation matrix
          correlationMatrix: {},  // { 'field1|field2': { r, pValue, strength } }
          // Data quality metrics
          dataQuality: {
            completeness: 0,      // % non-null
            uniqueness: 0,        // % unique values
            consistency: 0,       // % matching expected patterns
            issues: []            // [{ field, issue, severity, count }]
          },
          // Exploration history
          drillPath: [],          // [{ dimension, filter, timestamp }]
          focusedSegments: [],    // Current filter context
          // Advanced analysis results
          regressionModels: {},   // { targetMeasure: { coefficients, rSquared } }
          clusterAnalysis: {},    // { dimension: { clusters: [], silhouette } }
          seasonalityPatterns: {} // { measure: { period, strength, peaks } }
        }
      };
      
      // ==================== STATISTICAL HELPER FUNCTIONS ====================
      
      /**
       * Calculate Pearson correlation coefficient between two arrays
       */
      function calculateCorrelation(x, y) {
        if (x.length !== y.length || x.length < 3) return { r: 0, strength: 'insufficient data' };
        
        const n = x.length;
        const sumX = x.reduce((a, b) => a + b, 0);
        const sumY = y.reduce((a, b) => a + b, 0);
        const sumXY = x.reduce((acc, xi, i) => acc + xi * y[i], 0);
        const sumX2 = x.reduce((acc, xi) => acc + xi * xi, 0);
        const sumY2 = y.reduce((acc, yi) => acc + yi * yi, 0);
        
        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
        
        if (denominator === 0) return { r: 0, strength: 'no variance' };
        
        const r = numerator / denominator;
        const absR = Math.abs(r);
        
        let strength;
        if (absR >= 0.8) strength = 'very strong';
        else if (absR >= 0.6) strength = 'strong';
        else if (absR >= 0.4) strength = 'moderate';
        else if (absR >= 0.2) strength = 'weak';
        else strength = 'negligible';
        
        // Approximate p-value using t-distribution
        const t = r * Math.sqrt((n - 2) / (1 - r * r));
        // Simplified significance check
        const isSignificant = Math.abs(t) > 2; // Roughly p < 0.05 for n > 20
        
        return { r: parseFloat(r.toFixed(3)), strength, direction: r > 0 ? 'positive' : 'negative', significant: isSignificant };
      }
      
      /**
       * Detect distribution type from values
       */
      function detectDistribution(values) {
        if (values.length < 10) return { type: 'insufficient data', skewness: 0, kurtosis: 0 };
        
        const n = values.length;
        const mean = values.reduce((a, b) => a + b, 0) / n;
        const variance = values.reduce((acc, v) => acc + Math.pow(v - mean, 2), 0) / n;
        const stdDev = Math.sqrt(variance);
        
        if (stdDev === 0) return { type: 'constant', skewness: 0, kurtosis: 0 };
        
        // Calculate skewness (asymmetry)
        const m3 = values.reduce((acc, v) => acc + Math.pow((v - mean) / stdDev, 3), 0) / n;
        
        // Calculate kurtosis (tailedness)
        const m4 = values.reduce((acc, v) => acc + Math.pow((v - mean) / stdDev, 4), 0) / n;
        const kurtosis = m4 - 3; // Excess kurtosis (normal = 0)
        
        let type;
        if (Math.abs(m3) < 0.5 && Math.abs(kurtosis) < 1) {
          type = 'approximately normal';
        } else if (m3 > 1) {
          type = 'right-skewed (positive skew)';
        } else if (m3 < -1) {
          type = 'left-skewed (negative skew)';
        } else if (kurtosis > 2) {
          type = 'heavy-tailed (leptokurtic)';
        } else if (kurtosis < -1) {
          type = 'light-tailed (platykurtic)';
        } else {
          type = 'slightly skewed';
        }
        
        return { type, skewness: parseFloat(m3.toFixed(2)), kurtosis: parseFloat(kurtosis.toFixed(2)), mean, stdDev };
      }
      
      /**
       * Detect outliers using IQR method
       */
      function detectOutliers(values, fieldName) {
        if (values.length < 4) return [];
        
        const sorted = [...values].sort((a, b) => a - b);
        const n = sorted.length;
        const q1 = sorted[Math.floor(n * 0.25)];
        const q3 = sorted[Math.floor(n * 0.75)];
        const iqr = q3 - q1;
        const lowerBound = q1 - 1.5 * iqr;
        const upperBound = q3 + 1.5 * iqr;
        
        const outliers = [];
        values.forEach((v, idx) => {
          if (v < lowerBound) {
            outliers.push({ index: idx, value: v, type: 'low', field: fieldName, deviation: ((q1 - v) / iqr).toFixed(2) + ' IQR below Q1' });
          } else if (v > upperBound) {
            outliers.push({ index: idx, value: v, type: 'high', field: fieldName, deviation: ((v - q3) / iqr).toFixed(2) + ' IQR above Q3' });
          }
        });
        
        return outliers;
      }
      
      /**
       * Calculate percentiles
       */
      function calculatePercentiles(values, percentiles = [5, 25, 50, 75, 95]) {
        if (values.length === 0) return {};
        const sorted = [...values].sort((a, b) => a - b);
        const result = {};
        for (const p of percentiles) {
          const idx = Math.floor(sorted.length * p / 100);
          result[`p${p}`] = sorted[Math.min(idx, sorted.length - 1)];
        }
        return result;
      }
      
      /**
       * Detect concentration (Gini coefficient)
       */
      function calculateGiniCoefficient(values) {
        if (values.length < 2) return 0;
        
        const sorted = [...values].filter(v => v >= 0).sort((a, b) => a - b);
        const n = sorted.length;
        const sum = sorted.reduce((a, b) => a + b, 0);
        
        if (sum === 0) return 0;
        
        let cumulativeSum = 0;
        let giniSum = 0;
        
        for (let i = 0; i < n; i++) {
          cumulativeSum += sorted[i];
          giniSum += (2 * (i + 1) - n - 1) * sorted[i];
        }
        
        return parseFloat((giniSum / (n * sum)).toFixed(3));
      }
      
      /**
       * Simple linear regression
       */
      function linearRegression(x, y) {
        if (x.length !== y.length || x.length < 3) return null;
        
        const n = x.length;
        const sumX = x.reduce((a, b) => a + b, 0);
        const sumY = y.reduce((a, b) => a + b, 0);
        const sumXY = x.reduce((acc, xi, i) => acc + xi * y[i], 0);
        const sumX2 = x.reduce((acc, xi) => acc + xi * xi, 0);
        
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        
        // Calculate R-squared
        const meanY = sumY / n;
        const ssTotal = y.reduce((acc, yi) => acc + Math.pow(yi - meanY, 2), 0);
        const ssResidual = y.reduce((acc, yi, i) => acc + Math.pow(yi - (slope * x[i] + intercept), 2), 0);
        const rSquared = ssTotal > 0 ? 1 - ssResidual / ssTotal : 0;
        
        return { slope: parseFloat(slope.toFixed(4)), intercept: parseFloat(intercept.toFixed(4)), rSquared: parseFloat(rSquared.toFixed(3)) };
      }
      
      /**
       * Detect seasonality in time series (simple autocorrelation)
       */
      function detectSeasonality(values, maxLag = 12) {
        if (values.length < maxLag * 2) return { detected: false };
        
        const n = values.length;
        const mean = values.reduce((a, b) => a + b, 0) / n;
        const variance = values.reduce((acc, v) => acc + Math.pow(v - mean, 2), 0) / n;
        
        if (variance === 0) return { detected: false };
        
        const autocorrelations = [];
        for (let lag = 1; lag <= maxLag; lag++) {
          let sum = 0;
          for (let i = 0; i < n - lag; i++) {
            sum += (values[i] - mean) * (values[i + lag] - mean);
          }
          const ac = sum / ((n - lag) * variance);
          autocorrelations.push({ lag, ac: parseFloat(ac.toFixed(3)) });
        }
        
        // Find strongest lag (excluding very short lags)
        const significantLags = autocorrelations.filter(a => a.lag >= 2 && Math.abs(a.ac) > 0.3);
        const strongestLag = significantLags.sort((a, b) => Math.abs(b.ac) - Math.abs(a.ac))[0];
        
        if (strongestLag) {
          return { detected: true, period: strongestLag.lag, strength: Math.abs(strongestLag.ac), autocorrelations };
        }
        
        return { detected: false, autocorrelations };
      }
      
      // Generate hash for cache validation
      function generateDataHash(data) {
        const str = JSON.stringify(data).substring(0, 1000);
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        return hash.toString(16);
      }
      
      // Mark cache as stale
      function markStoryCacheStale(reason) {
        storyCache.isStale = true;
        storyCache.staleReason = reason;
        console.log(`[StoryCache] Marked stale: ${reason}`);
      }
      
      // Check if cache is valid
      function isStoryCacheValid(worksheetNames, rowCount) {
        if (storyCache.isStale) return false;
        if (storyCache.cacheKey.rowCount !== rowCount) return false;
        if (JSON.stringify(storyCache.cacheKey.worksheetNames) !== JSON.stringify(worksheetNames)) return false;
        // Cache expires after 10 minutes
        if (Date.now() - storyCache.cacheKey.timestamp > 600000) return false;
        return true;
      }
      
      // Format value as percentage if it looks like a rate
      function formatAsPercentage(value, fieldName) {
        const numVal = parseFloat(value);
        if (isNaN(numVal)) return value;
        
        // Check if field name suggests it's a rate
        const isRate = /rate|ratio|percent|%|pct|proportion|share/i.test(fieldName);
        
        // If it's a decimal between 0 and 1, and field suggests rate, format as %
        if (isRate && numVal >= 0 && numVal <= 1) {
          return (numVal * 100).toFixed(1) + '%';
        }
        // If it's already > 1 but < 100 and looks like a rate, add %
        if (isRate && numVal > 1 && numVal <= 100) {
          return numVal.toFixed(1) + '%';
        }
        return value;
      }
      
      // ==================== MULTI-STAGE STORY PIPELINE ====================
      
      /**
       * STAGE 1: Extract and compute data statistics (NO LLM)
       * Computes actual rankings, statistics, and formatted metrics
       */
      async function extractStoryData(dashboard, forceRefresh = false) {
        const worksheetNames = dashboard.worksheets.map(ws => ws.name);
        
        // Check cache validity (unless force refresh)
        if (!forceRefresh && !storyCache.isStale) {
          console.log('[Stage1] Using cached extracted data');
          return { cached: true, data: storyCache.extractedData };
        }
        
        console.log('[Stage1] Extracting fresh data from', worksheetNames.length, 'worksheets');
        
        const extracted = {
          rankings: {},
          statistics: {},
          topPerformers: {},
          totals: {},
          anomalies: [],
          dimensionBreakdowns: {},
          rawMetrics: [],
          worksheetSummaries: []
        };
        
        let totalRowCount = 0;
        const allDimensionData = {}; // { dimensionField: { dimensionValue: { measureField: [values] } } }
        
        for (const ws of dashboard.worksheets.slice(0, 6)) {
          try {
            const data = await ws.getSummaryDataAsync();
            const columns = data.columns;
            const rows = data.data;
            totalRowCount += rows.length;
            
            // Identify dimensions and measures
            const dimensions = [];
            const measures = [];
            
            columns.forEach((col, idx) => {
              const fieldName = col.fieldName;
              const isAggregated = /^(SUM|AVG|COUNT|CNTD|MIN|MAX|AGG|ATTR)\(/i.test(fieldName);
              const cleanName = fieldName.replace(/^(SUM|AVG|COUNT|CNTD|MIN|MAX|AGG|ATTR)\(|\)$/gi, '');
              
              if (isAggregated) {
                measures.push({ idx, fieldName, cleanName });
              } else {
                dimensions.push({ idx, fieldName, cleanName });
              }
            });
            
            // Build worksheet summary
            const wsSummary = {
              name: ws.name,
              rowCount: rows.length,
              dimensions: dimensions.map(d => d.cleanName),
              measures: measures.map(m => m.cleanName)
            };
            extracted.worksheetSummaries.push(wsSummary);
            
            // Process each row to build dimension breakdowns
            for (const row of rows) {
              // Get dimension values for this row
              const dimValues = {};
              dimensions.forEach(dim => {
                dimValues[dim.cleanName] = row[dim.idx]?.formattedValue || '';
              });
              
              // Get measure values
              measures.forEach(measure => {
                const rawVal = row[measure.idx]?.value;
                const numVal = parseFloat(rawVal);
                const formattedVal = row[measure.idx]?.formattedValue || '';
                
                if (!isNaN(numVal)) {
                  // Track per dimension breakdown
                  dimensions.forEach(dim => {
                    const dimName = dim.cleanName;
                    const dimVal = dimValues[dimName];
                    
                    if (!allDimensionData[dimName]) allDimensionData[dimName] = {};
                    if (!allDimensionData[dimName][dimVal]) allDimensionData[dimName][dimVal] = {};
                    if (!allDimensionData[dimName][dimVal][measure.cleanName]) {
                      allDimensionData[dimName][dimVal][measure.cleanName] = [];
                    }
                    allDimensionData[dimName][dimVal][measure.cleanName].push({
                      value: numVal,
                      formatted: formattedVal
                    });
                  });
                  
                  // Track overall statistics per measure
                  if (!extracted.statistics[measure.cleanName]) {
                    extracted.statistics[measure.cleanName] = { values: [], formatted: [] };
                  }
                  extracted.statistics[measure.cleanName].values.push(numVal);
                  extracted.statistics[measure.cleanName].formatted.push(formattedVal);
                }
              });
            }
            
          } catch (e) {
            console.log('[Stage1] Could not read worksheet', ws.name, e.message);
          }
        }
        
        // Compute rankings for each dimension/measure combination
        for (const dimName of Object.keys(allDimensionData)) {
          extracted.dimensionBreakdowns[dimName] = [];
          
          const dimData = allDimensionData[dimName];
          for (const dimVal of Object.keys(dimData)) {
            const entry = { name: dimVal, metrics: {} };
            
            for (const measureName of Object.keys(dimData[dimVal])) {
              const measureVals = dimData[dimVal][measureName];
              // Use the last value (most recent) or average if multiple
              const avgVal = measureVals.reduce((a, b) => a + b.value, 0) / measureVals.length;
              const lastFormatted = measureVals[measureVals.length - 1].formatted;
              
              entry.metrics[measureName] = {
                value: avgVal,
                formatted: formatAsPercentage(avgVal, measureName),
                originalFormatted: lastFormatted
              };
            }
            
            extracted.dimensionBreakdowns[dimName].push(entry);
          }
        }
        
        // Compute rankings (sort by each measure)
        for (const dimName of Object.keys(extracted.dimensionBreakdowns)) {
          const breakdown = extracted.dimensionBreakdowns[dimName];
          if (breakdown.length === 0) continue;
          
          // Get all measure names from first entry
          const measureNames = Object.keys(breakdown[0]?.metrics || {});
          
          for (const measureName of measureNames) {
            const sorted = [...breakdown]
              .filter(b => b.metrics[measureName])
              .sort((a, b) => b.metrics[measureName].value - a.metrics[measureName].value);
            
            if (sorted.length > 0) {
              const rankingKey = `${measureName} by ${dimName}`;
              extracted.rankings[rankingKey] = sorted.map((item, idx) => ({
                rank: idx + 1,
                name: item.name,
                value: item.metrics[measureName].value,
                formatted: item.metrics[measureName].formatted
              }));
              
              // Track top performer
              if (!extracted.topPerformers[dimName]) extracted.topPerformers[dimName] = {};
              extracted.topPerformers[dimName][measureName] = {
                name: sorted[0].name,
                value: sorted[0].metrics[measureName].value,
                formatted: sorted[0].metrics[measureName].formatted
              };
            }
          }
        }
        
        // Compute aggregate statistics for each measure
        for (const measureName of Object.keys(extracted.statistics)) {
          const vals = extracted.statistics[measureName].values;
          if (vals.length === 0) continue;
          
          const sum = vals.reduce((a, b) => a + b, 0);
          const avg = sum / vals.length;
          const sorted = [...vals].sort((a, b) => a - b);
          const median = sorted[Math.floor(sorted.length / 2)];
          const min = sorted[0];
          const max = sorted[sorted.length - 1];
          const stdDev = Math.sqrt(vals.reduce((sq, n) => sq + Math.pow(n - avg, 2), 0) / vals.length);
          
          extracted.statistics[measureName] = {
            count: vals.length,
            sum: sum,
            avg: avg,
            median: median,
            min: min,
            max: max,
            stdDev: stdDev,
            formattedAvg: formatAsPercentage(avg, measureName),
            formattedMax: formatAsPercentage(max, measureName),
            formattedMin: formatAsPercentage(min, measureName)
          };
          
          // Track totals for counts and sums
          if (/count|total|sum|sends|emails|records/i.test(measureName)) {
            extracted.totals[measureName] = sum;
          }
        }
        
        // Detect anomalies (values > 2 std deviations from mean)
        for (const measureName of Object.keys(extracted.statistics)) {
          const stats = extracted.statistics[measureName];
          if (!stats.stdDev || stats.stdDev === 0) continue;
          
          // Check top performers for anomalies
          for (const dimName of Object.keys(extracted.topPerformers)) {
            const topEntry = extracted.topPerformers[dimName][measureName];
            if (topEntry && Math.abs(topEntry.value - stats.avg) > 2 * stats.stdDev) {
              extracted.anomalies.push({
                type: topEntry.value > stats.avg ? 'high_outlier' : 'low_outlier',
                dimension: dimName,
                dimensionValue: topEntry.name,
                measure: measureName,
                value: topEntry.value,
                formatted: topEntry.formatted,
                reason: `${((topEntry.value - stats.avg) / stats.stdDev).toFixed(1)} std deviations from mean`
              });
            }
          }
        }
        
        // Update cache
        storyCache.cacheKey = {
          worksheetNames: worksheetNames,
          dataHash: generateDataHash(extracted),
          rowCount: totalRowCount,
          filterState: '',
          timestamp: Date.now()
        };
        storyCache.extractedData = extracted;
        storyCache.isStale = false;
        storyCache.staleReason = null;
        
        console.log('[Stage1] Extraction complete:', {
          worksheets: worksheetNames.length,
          rows: totalRowCount,
          rankings: Object.keys(extracted.rankings).length,
          anomalies: extracted.anomalies.length
        });
        
        return { cached: false, data: extracted };
      }
      
      /**
       * STAGE 2: Generate narrative insights using Analysis LLM
       * Uses pre-computed facts, LLM interprets them
       */
      async function generateStoryAnalysis(extractedData, storyAngle, audience, forceRefresh = false) {
        // Check if we have valid cached analysis for same angle/audience
        const cachedAnalysis = storyCache.analysisResult;
        if (!forceRefresh && 
            cachedAnalysis.heroHeadline && 
            cachedAnalysis.analysisAngle === storyAngle && 
            cachedAnalysis.audience === audience) {
          console.log('[Stage2] Using cached analysis');
          return { cached: true, analysis: cachedAnalysis };
        }
        
        console.log('[Stage2] Generating fresh analysis with', storyAngle, 'angle for', audience);
        
        // Build a fact-based prompt with pre-computed statistics
        const rankingsSummary = [];
        for (const [key, ranking] of Object.entries(extractedData.rankings)) {
          if (ranking.length > 0) {
            const top3 = ranking.slice(0, 3).map(r => `${r.rank}. ${r.name}: ${r.formatted}`).join(', ');
            rankingsSummary.push(`**${key}:** ${top3}`);
          }
        }
        
        const statsSummary = [];
        for (const [measure, stats] of Object.entries(extractedData.statistics)) {
          if (stats.avg !== undefined) {
            statsSummary.push(`- ${measure}: avg=${stats.formattedAvg}, range=${stats.formattedMin} to ${stats.formattedMax}`);
          }
        }
        
        const anomaliesSummary = extractedData.anomalies.map(a => 
          `- ${a.dimensionValue} (${a.dimension}): ${a.measure}=${a.formatted} [${a.type}]`
        ).join('\n');
        
        const totalsSummary = Object.entries(extractedData.totals)
          .map(([k, v]) => `- ${k}: ${v.toLocaleString()}`)
          .join('\n');
        
        const analysisPrompt = `You are a senior BI analyst creating an executive story from dashboard data.

**VERIFIED FACTS (pre-computed from actual data):**

**Rankings:**
${rankingsSummary.join('\n')}

**Statistics:**
${statsSummary.join('\n')}

**Totals:**
${totalsSummary || 'No totals computed'}

**Anomalies Detected:**
${anomaliesSummary || 'No significant anomalies'}

**Worksheets Analyzed:**
${extractedData.worksheetSummaries.map(ws => `- ${ws.name}: ${ws.rowCount} rows, measures: ${ws.measures.join(', ')}`).join('\n')}

---

**STORY PARAMETERS:**
- Angle: ${storyAngle}
- Audience: ${audience}

**YOUR TASK:**
Create a compelling narrative using ONLY the verified facts above. Do NOT make up statistics or rankings.

**RETURN JSON:**
{
  "heroHeadline": "8 words max, key insight",
  "keyTakeaway": "2-3 sentences summarizing the most important verified finding",
  "insights": [
    { 
      "headline": "Short headline", 
      "text": "1-2 sentences with specific numbers from the data", 
      "metric": "The key number (use exact values from rankings/stats)",
      "metricLabel": "What this metric represents"
    }
  ],
  "recommendations": [
    { 
      "text": "Specific action based on data", 
      "priority": "high|medium|low", 
      "rationale": "Brief why, citing data" 
    }
  ],
  "trustStatement": "Cite specific data scope, e.g. 'Based on analysis of X campaigns across Y records'"
}

CRITICAL: Only reference rankings and metrics that appear in the VERIFIED FACTS above. Do not invent data.`;

        try {
          const response = await callLLM(analysisPrompt, null, 'analysis');
          
          let analysisResult;
          try {
            analysisResult = JSON.parse(response.trim());
          } catch (e) {
            const match = response.match(/\{[\s\S]*\}/);
            if (match) {
              analysisResult = JSON.parse(match[0]);
            } else {
              throw new Error('Could not parse analysis response');
            }
          }
          
          // Cache the analysis
          analysisResult.analysisAngle = storyAngle;
          analysisResult.audience = audience;
          storyCache.analysisResult = analysisResult;
          
          console.log('[Stage2] Analysis complete:', analysisResult.heroHeadline);
          
          return { cached: false, analysis: analysisResult };
        } catch (error) {
          console.error('[Stage2] Analysis error:', error);
          throw error;
        }
      }
      
      /**
       * STAGE 3: Generate design preferences using Design LLM
       * Chooses layout, colors, emphasis based on content
       */
      async function generateStoryDesign(analysisResult, designHints = {}) {
        // If no specific design request, use defaults
        if (!designHints.customRequest) {
          console.log('[Stage3] Using default design');
          return {
            cached: true,
            design: storyCache.designPreferences
          };
        }
        
        console.log('[Stage3] Generating custom design based on:', designHints.customRequest);
        
        const designPrompt = `You are a dashboard design expert.

**STORY CONTENT:**
- Headline: ${analysisResult.heroHeadline}
- ${analysisResult.insights?.length || 0} insights to display
- ${analysisResult.recommendations?.length || 0} recommendations

**USER REQUEST:**
${designHints.customRequest}

**AVAILABLE OPTIONS:**
- Themes: professional (blue), modern (dark), minimal (monochrome), warm (orange tones), corporate (navy)
- Layouts: standard (grid), compact, magazine (editorial), presentation (large text)
- Emphasis: headline-focus, metrics-focus, recommendations-focus, balanced

**RETURN JSON:**
{
  "theme": "professional|modern|minimal|warm|corporate",
  "layout": "standard|compact|magazine|presentation",
  "emphasis": "headline-focus|metrics-focus|recommendations-focus|balanced",
  "colorScheme": ["#hex1", "#hex2", "#hex3", "#hex4"],
  "reasoning": "Brief explanation of design choices"
}`;

        try {
          const response = await callLLM(designPrompt, null, 'design');
          
          let designResult;
          try {
            designResult = JSON.parse(response.trim());
          } catch (e) {
            const match = response.match(/\{[\s\S]*\}/);
            if (match) {
              designResult = JSON.parse(match[0]);
            } else {
              // Fallback to defaults
              return { cached: true, design: storyCache.designPreferences };
            }
          }
          
          // Update cache
          storyCache.designPreferences = {
            theme: designResult.theme || 'professional',
            layout: designResult.layout || 'standard',
            emphasis: designResult.emphasis || 'balanced',
            colorScheme: designResult.colorScheme || ['#0B5CAD', '#1F9FB5', '#F4A261', '#E76F51']
          };
          
          console.log('[Stage3] Design complete:', storyCache.designPreferences.theme);
          
          return { cached: false, design: storyCache.designPreferences };
        } catch (error) {
          console.log('[Stage3] Design error, using defaults:', error.message);
          return { cached: true, design: storyCache.designPreferences };
        }
      }
      
      /**
       * STAGE 4: Render final HTML using Code LLM or templates
       * Combines analysis + design into final output
       */
      function renderStoryHtml(analysisResult, designPrefs) {
        console.log('[Stage4] Rendering story HTML with', designPrefs.theme, 'theme');
        
        // Theme color mappings
        const themes = {
          professional: { primary: '#0B5CAD', secondary: '#1a5490', bg: '#fefefe', text: '#1a1a2e' },
          modern: { primary: '#6366f1', secondary: '#4f46e5', bg: '#0f172a', text: '#f8fafc' },
          minimal: { primary: '#374151', secondary: '#4b5563', bg: '#ffffff', text: '#111827' },
          warm: { primary: '#ea580c', secondary: '#c2410c', bg: '#fffbeb', text: '#1c1917' },
          corporate: { primary: '#1e3a5f', secondary: '#0f2744', bg: '#f8fafc', text: '#0f172a' }
        };
        
        const t = themes[designPrefs.theme] || themes.professional;
        const colors = designPrefs.colorScheme || ['#0B5CAD', '#1F9FB5', '#F4A261', '#E76F51'];
        
        // Priority styling
        const priorityStyles = {
          high: { dot: '#dc2626', bg: '#fee2e2', color: '#991b1b', label: 'High Impact · Quick Win' },
          medium: { dot: '#d97706', bg: '#fef3c7', color: '#92400e', label: 'Medium · Requires Testing' },
          low: { dot: '#2563eb', bg: '#dbeafe', color: '#1e40af', label: 'Foundational · Long-term' }
        };
        
        // Normalize recommendations
        let recommendations = analysisResult.recommendations || [];
        if (recommendations.length > 0 && typeof recommendations[0] === 'string') {
          recommendations = recommendations.map((r, i) => ({
            text: r,
            priority: i === 0 ? 'high' : i === 1 ? 'medium' : 'low',
            rationale: ''
          }));
        }
        
        const storyHtml = `
<div style="font-family: 'Georgia', serif; padding: 30px; background: linear-gradient(180deg, ${t.bg} 0%, ${t.bg}ee 100%); color: ${t.text}; border-radius: 12px; max-width: 800px; margin: 0 auto;">
  
  <!-- Hero Section -->
  <div style="text-align: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 3px solid ${t.primary};">
    <h1 style="font-size: 32px; font-weight: 700; margin: 0; color: ${t.primary}; line-height: 1.2;">
      ${analysisResult.heroHeadline}
    </h1>
  </div>
  
  <!-- Key Takeaway Box -->
  <div style="background: linear-gradient(135deg, ${t.primary} 0%, ${t.secondary} 100%); color: white; padding: 20px 25px; border-radius: 10px; margin-bottom: 30px; box-shadow: 0 4px 15px ${t.primary}4d;">
    <div style="display: flex; align-items: flex-start; gap: 12px;">
      <div style="width: 24px; height: 24px; border-radius: 50%; background: rgba(255,255,255,0.2); display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>
      </div>
      <div>
        <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.8; margin-bottom: 5px;">Key Takeaway</div>
        <div style="font-size: 16px; line-height: 1.5;">${analysisResult.keyTakeaway}</div>
      </div>
    </div>
  </div>
  
  <!-- Insights Grid -->
  <div style="display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 30px;">
    ${analysisResult.insights?.map((insight, i) => `
      <div style="flex: 1 1 200px; min-width: 180px; background: ${designPrefs.theme === 'modern' ? '#1e293b' : 'white'}; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.08); border-left: 4px solid ${colors[i % colors.length]};">
        <div style="font-size: 24px; font-weight: 700; color: ${colors[i % colors.length]};">${insight.metric}</div>
        <div style="font-size: 12px; color: ${designPrefs.theme === 'modern' ? '#94a3b8' : '#666'}; margin-bottom: 10px;">${insight.metricLabel || ''}</div>
        <div style="font-size: 14px; font-weight: 600; margin-bottom: 5px;">${insight.headline}</div>
        <div style="font-size: 13px; color: ${designPrefs.theme === 'modern' ? '#cbd5e1' : '#555'}; line-height: 1.5;">${insight.text}</div>
      </div>
    `).join('') || ''}
  </div>
  
  ${recommendations.length > 0 ? `
  <!-- Prioritized Recommendations -->
  <div style="background: ${designPrefs.theme === 'modern' ? '#1e293b' : '#f8fafc'}; padding: 25px; border-radius: 10px; margin-bottom: 20px; border: 1px solid ${designPrefs.theme === 'modern' ? '#334155' : '#e2e8f0'};">
    <div style="font-size: 16px; font-weight: 600; color: ${t.primary}; margin-bottom: 18px; display: flex; align-items: center; gap: 10px;">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="${t.primary}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/><polyline points="17 6 23 6 23 12"/></svg>
      Recommended Actions <span style="font-size: 12px; font-weight: 400; color: ${designPrefs.theme === 'modern' ? '#94a3b8' : '#64748b'};">(ordered by expected ROI)</span>
    </div>
    <div style="display: flex; flex-direction: column; gap: 14px;">
      ${recommendations.map(r => {
        const priority = r.priority || 'medium';
        const style = priorityStyles[priority] || priorityStyles.medium;
        return `
        <div style="display: flex; align-items: flex-start; gap: 14px; padding: 16px; background: ${designPrefs.theme === 'modern' ? '#0f172a' : 'white'}; border-radius: 8px; border-left: 4px solid ${style.color}; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
          <div style="flex-shrink: 0; margin-top: 6px;">
            <div style="width: 12px; height: 12px; border-radius: 50%; background: ${style.dot};"></div>
          </div>
          <div style="flex: 1;">
            <div style="font-size: 15px; color: ${t.text}; line-height: 1.6; margin-bottom: 8px;">${r.text || r}</div>
            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 10px;">
              <span style="font-size: 11px; padding: 3px 10px; background: ${style.bg}; color: ${style.color}; border-radius: 12px; font-weight: 600;">${style.label}</span>
              ${r.rationale ? `<span style="font-size: 12px; color: ${designPrefs.theme === 'modern' ? '#94a3b8' : '#64748b'}; line-height: 1.4;">${r.rationale}</span>` : ''}
            </div>
          </div>
        </div>
        `;
      }).join('')}
    </div>
  </div>
  ` : ''}
  
  <!-- Trust Statement -->
  ${analysisResult.trustStatement ? `
  <div style="text-align: center; font-size: 13px; color: ${designPrefs.theme === 'modern' ? '#94a3b8' : '#475569'}; padding: 14px 24px; background: ${designPrefs.theme === 'modern' ? '#1e293b' : '#f1f5f9'}; border-radius: 8px; margin-bottom: 15px; line-height: 1.5;">
    <span style="font-weight: 600; color: ${designPrefs.theme === 'modern' ? '#e2e8f0' : '#334155'};">Data scope:</span> ${analysisResult.trustStatement}
  </div>
  ` : ''}
  
  <!-- Footer -->
  <div style="text-align: center; font-size: 11px; color: ${designPrefs.theme === 'modern' ? '#64748b' : '#888'}; padding-top: 15px; border-top: 1px solid ${designPrefs.theme === 'modern' ? '#334155' : '#eee'};">
    ${analysisResult.footer || `Analysis generated by DashAgent | ${new Date().toLocaleDateString()}`}
  </div>
  
</div>`;
        
        return storyHtml;
      }
      
      /**
       * Get cached data for dashboard/chart building
       * Returns extracted data if available, or extracts fresh
       * This allows build_dashboard and render_visualization to reuse cache
       */
      async function getCachedDashboardData(dashboard, forceRefresh = false) {
        // If cache is valid and not forcing refresh, return cached data
        if (!forceRefresh && !storyCache.isStale && storyCache.extractedData.worksheetSummaries.length > 0) {
          console.log('[Cache] Using cached dashboard data');
          return { cached: true, data: storyCache.extractedData };
        }
        
        // Otherwise, extract fresh data
        console.log('[Cache] Extracting fresh dashboard data');
        const result = await extractStoryData(dashboard, forceRefresh);
        return result;
      }
      
      /**
       * Get KPIs from cached data for build_dashboard
       * Returns array of { label, value, formatted, type }
       */
      function getKPIsFromCache(cachedData, maxKPIs = 6) {
        const kpis = [];
        
        // Get overall statistics for KPIs
        for (const [measureName, stats] of Object.entries(cachedData.statistics)) {
          if (kpis.length >= maxKPIs) break;
          
          // Determine if this is a rate or volume metric
          const isRate = /rate|ratio|percent|%|pct|proportion|share/i.test(measureName);
          const isCount = /count|total|sum|volume|sends|emails|records|sales|revenue/i.test(measureName);
          
          if (isRate) {
            kpis.push({
              label: measureName,
              value: stats.avg,
              formatted: stats.formattedAvg,
              type: 'rate'
            });
          } else if (isCount && stats.sum > 0) {
            kpis.push({
              label: measureName,
              value: stats.sum,
              formatted: stats.sum.toLocaleString(),
              type: 'volume'
            });
          }
        }
        
        return kpis;
      }
      
      /**
       * Get top performers from cached data for charts
       * Returns array of { dimension, items: [{ name, value, formatted }] }
       */
      function getTopPerformersFromCache(cachedData, measureName = null) {
        const performers = [];
        
        for (const [rankingKey, ranking] of Object.entries(cachedData.rankings)) {
          // If measureName specified, filter for it
          if (measureName && !rankingKey.toLowerCase().includes(measureName.toLowerCase())) {
            continue;
          }
          
          // Extract dimension and measure from ranking key (format: "Measure by Dimension")
          const [measure, dimension] = rankingKey.split(' by ');
          
          performers.push({
            rankingKey,
            measure,
            dimension,
            items: ranking.slice(0, 10).map(item => ({
              name: item.name,
              value: item.value,
              formatted: item.formatted,
              rank: item.rank
            }))
          });
        }
        
        return performers;
      }
      
      /**
       * Get chart-ready data from cached dimension breakdowns
       * Returns data formatted for bar/donut charts
       */
      function getChartDataFromCache(cachedData, dimensionName, measureName) {
        const breakdown = cachedData.dimensionBreakdowns[dimensionName];
        if (!breakdown) return null;
        
        return breakdown
          .filter(item => item.metrics[measureName])
          .map(item => ({
            label: item.name,
            value: item.metrics[measureName].value,
            formatted: item.metrics[measureName].formatted
          }))
          .sort((a, b) => b.value - a.value)
          .slice(0, 10);
      }
      
      // ==================== MCP SERVER COMMUNICATION ====================
      // Send request to MCP server via WebSocket
      async function sendMcpRequest(toolName, params) {
        console.log('🔧 sendMcpRequest called:', toolName, params);
        
        return new Promise((resolve, reject) => {
          // Check if WebSocket is available
          if (!window._dashagentWs || window._dashagentWs.readyState !== WebSocket.OPEN) {
            console.log('🔌 Creating new WebSocket connection...');
            // Try to connect - MCP server uses port 3001
            const wsUrl = 'ws://localhost:3001';
            window._dashagentWs = new WebSocket(wsUrl);
            
            window._dashagentWs.onopen = () => {
              console.log('🔗 Connected to MCP server at', wsUrl);
              sendRequest();
            };
            
            window._dashagentWs.onerror = (e) => {
              console.error('❌ WebSocket error:', e);
              reject(new Error('Could not connect to MCP server. Make sure it is running on ws://localhost:3001'));
            };
            
            window._dashagentWs.onclose = () => {
              console.log('🔌 Disconnected from MCP server');
            };
          } else {
            sendRequest();
          }
          
          function sendRequest() {
            const requestId = 'req_' + Date.now();
            console.log('📤 Sending MCP request:', requestId, toolName);
            
            // Set up response handler
            const messageHandler = (event) => {
              console.log('📥 Received MCP message:', event.data);
              try {
                const data = JSON.parse(event.data);
                if (data.requestId === requestId) {
                  window._dashagentWs.removeEventListener('message', messageHandler);
                  console.log('✅ Got matching response for', requestId);
                  if (data.error) {
                    reject(new Error(data.error));
                  } else {
                    resolve(data.result);
                  }
                }
              } catch (e) {
                console.error('Error parsing MCP response:', e);
              }
            };
            
            window._dashagentWs.addEventListener('message', messageHandler);
            
            // Send the request
            window._dashagentWs.send(JSON.stringify({
              jsonrpc: '2.0',
              id: requestId,
              method: 'tools/call',
              params: {
                name: toolName,
                arguments: params
              }
            }));
            
            // Timeout after 30 seconds
            setTimeout(() => {
              window._dashagentWs.removeEventListener('message', messageHandler);
              reject(new Error('MCP request timed out after 30 seconds'));
            }, 30000);
          }
        });
      }
      
      // Save viz configs to localStorage (without worksheetObj which can't be serialized)
      function saveVizConfigs() {
        const configsToSave = currentVizConfigs.map(c => {
          const { worksheetObj, ...rest } = c;
          return { ...rest, worksheetName: worksheetObj?.name || c.worksheet };
        });
        localStorage.setItem('dashagent_viz_configs', JSON.stringify(configsToSave));
      }
      
      // Load viz configs from localStorage and restore worksheetObj
      function loadVizConfigs() {
        try {
          const saved = localStorage.getItem('dashagent_viz_configs');
          if (saved) {
            const configs = JSON.parse(saved);
            const dashboard = tableau.extensions.dashboardContent?.dashboard;
            if (dashboard) {
              currentVizConfigs = configs.map(c => {
                const ws = dashboard.worksheets.find(w => w.name === (c.worksheetName || c.worksheet));
                return { ...c, worksheetObj: ws };
              }).filter(c => c.worksheetObj); // Only keep configs where worksheet still exists
              
              // Show refresh button if we have configs
              if (currentVizConfigs.length > 0) {
                const refreshBtn = document.getElementById('btn-refresh-viz');
                if (refreshBtn) {
                  refreshBtn.style.display = 'inline-block';
                }
              }
            }
          }
        } catch (e) {
          console.log('Could not load viz configs:', e);
        }
      }

      // Execute a tool call from the LLM
      async function executeToolCall(toolName, args) {
        const dashboard = tableau.extensions.dashboardContent.dashboard;
        
        switch (toolName) {
          // ==================== FIELD CONFIRMATION HANDLER ====================
          case 'confirm_chart_fields': {
            const ws = dashboard.worksheets.find(w => w.name === args.worksheet);
            if (!ws) {
              const available = dashboard.worksheets.map(w => w.name).join(', ');
              throw new Error(`Worksheet "${args.worksheet}" not found. Available: ${available}`);
            }
            
            // Get data to extract field names
            const summaryData = await ws.getSummaryDataAsync({ maxRows: 10 });
            const columns = summaryData.columns;
            
            // Classify fields as dimensions vs measures
            const dimensions = [];
            const measures = [];
            
            for (const col of columns) {
              const isMeasure = /^(SUM|AVG|COUNT|CNTD|MIN|MAX|AGG|MEDIAN)\s*\(/i.test(col.fieldName) ||
                               ['int', 'float', 'number'].includes(col.dataType);
              
              if (isMeasure) {
                measures.push(col.fieldName);
              } else {
                dimensions.push(col.fieldName);
              }
            }
            
            // Helper to find best match (exact first, then partial)
            function findBestMatch(requested, fieldList) {
              if (!requested) return { match: null, score: 0, alternatives: fieldList };
              
              const reqLower = requested.toLowerCase().trim();
              
              // 1. Exact match
              for (const field of fieldList) {
                if (field.toLowerCase() === reqLower) {
                  return { match: field, score: 100, alternatives: fieldList.filter(f => f !== field) };
                }
              }
              
              // 2. Exact match after removing aggregation wrapper
              const normalizeAgg = (s) => s.toLowerCase().replace(/^(sum|avg|count|cntd|min|max|agg|attr)\s*\(|\)$/gi, '').trim();
              const reqNorm = normalizeAgg(requested);
              
              for (const field of fieldList) {
                if (normalizeAgg(field) === reqNorm) {
                  return { match: field, score: 95, alternatives: fieldList.filter(f => f !== field) };
                }
              }
              
              // 3. Field contains the request (e.g., "AGG(Clickthrough Rate)" contains "Clickthrough Rate")
              for (const field of fieldList) {
                if (normalizeAgg(field).includes(reqNorm) && reqNorm.length > 3) {
                  return { match: field, score: 80, alternatives: fieldList.filter(f => f !== field) };
                }
              }
              
              // 4. No match found
              return { match: null, score: 0, alternatives: fieldList };
            }
            
            const dimResult = findBestMatch(args.requestedDimension, dimensions);
            const measureResult = findBestMatch(args.requestedMeasure, measures);
            
            // Build confirmation message
            let confirmationHtml = `
## Field Confirmation

**Worksheet:** ${args.worksheet}

### Dimension (for grouping/categories)
- **Requested:** "${args.requestedDimension}"
`;
            
            if (dimResult.match) {
              confirmationHtml += `- **✅ Matched:** \`${dimResult.match}\` (confidence: ${dimResult.score}%)\n`;
            } else {
              confirmationHtml += `- **⚠️ No match found!**\n`;
            }
            confirmationHtml += `- **Available dimensions:** ${dimensions.map(d => '`' + d + '`').join(', ')}\n`;
            
            confirmationHtml += `
### Measure (for values)
- **Requested:** "${args.requestedMeasure}"
`;
            
            if (measureResult.match) {
              confirmationHtml += `- **✅ Matched:** \`${measureResult.match}\` (confidence: ${measureResult.score}%)\n`;
            } else {
              confirmationHtml += `- **⚠️ No match found!**\n`;
            }
            confirmationHtml += `- **Available measures:** ${measures.map(m => '`' + m + '`').join(', ')}\n`;
            
            confirmationHtml += `
---
**Please confirm these fields are correct, or tell me which fields to use instead.**

If confirmed, I'll create the chart using:
- **Dimension:** \`${dimResult.match || 'NEEDS SELECTION'}\`
- **Measure:** \`${measureResult.match || 'NEEDS SELECTION'}\`
`;
            
            return {
              confirmation: confirmationHtml,
              matchedDimension: dimResult.match,
              matchedMeasure: measureResult.match,
              dimensionConfidence: dimResult.score,
              measureConfidence: measureResult.score,
              availableDimensions: dimensions,
              availableMeasures: measures,
              worksheet: args.worksheet
            };
          }
          
          // ==================== DATA PROFILING HANDLER ====================
          case 'profile_data_for_visualization': {
            const ws = dashboard.worksheets.find(w => w.name === args.worksheet);
            if (!ws) {
              const available = dashboard.worksheets.map(w => w.name).join(', ');
              throw new Error(`Worksheet "${args.worksheet}" not found. Available: ${available}`);
            }
            
            const dataTable = await ws.getSummaryDataAsync({ maxRows: 500 });
            const columns = dataTable.columns;
            const rows = dataTable.data;
            
            // ============================================
            // COMPREHENSIVE DATA PROFILING
            // ============================================
            
            const profile = {
              worksheet: args.worksheet,
              totalRows: rows.length,
              columns: [],
              dataQuality: {
                overallScore: 100,
                issues: [],
                warnings: []
              },
              recommendations: {
                suggestedVizTypes: [],
                aggregationNeeded: false,
                aggregationType: null,
                primaryDimension: null,
                primaryMeasure: null
              }
            };
            
            // Analyze each column
            for (let colIdx = 0; colIdx < columns.length; colIdx++) {
              const col = columns[colIdx];
              const values = rows.map(r => r[colIdx]);
              const formattedValues = values.map(v => v.formattedValue);
              const rawValues = values.map(v => v.value);
              
              // Basic stats
              const nonNullValues = rawValues.filter(v => v !== null && v !== undefined && v !== '');
              const nullCount = rawValues.length - nonNullValues.length;
              const nullPercent = (nullCount / rawValues.length * 100).toFixed(1);
              
              const uniqueValues = new Set(formattedValues.filter(v => v));
              const cardinality = uniqueValues.size;
              
              // Determine field type
              const fieldName = col.fieldName;
              const dataType = col.dataType;
              
              // Is it a date?
              const isDate = dataType === 'date' || dataType === 'datetime' ||
                /date|time|day|week|month|year|period|quarter/i.test(fieldName) ||
                /^(DAY|MONTH|YEAR|WEEK|HOUR|QUARTER|DATEPART|DATETRUNC)\s*\(/i.test(fieldName);
              
              // Is it a measure?
              const isMeasure = ['int', 'float', 'number'].includes(dataType) ||
                /^(SUM|AVG|COUNT|CNTD|MIN|MAX|AGG|MEDIAN)\s*\(/i.test(fieldName) ||
                /count|sum|avg|total|rate|amount|revenue|sales|profit|qty/i.test(fieldName);
              
              // Calculate numeric stats if measure
              let numericStats = null;
              if (isMeasure) {
                const numVals = nonNullValues.map(v => parseFloat(v)).filter(v => !isNaN(v));
                if (numVals.length > 0) {
                  numVals.sort((a, b) => a - b);
                  const sum = numVals.reduce((a, b) => a + b, 0);
                  const avg = sum / numVals.length;
                  const min = numVals[0];
                  const max = numVals[numVals.length - 1];
                  const median = numVals[Math.floor(numVals.length / 2)];
                  
                  // Calculate std dev
                  const squaredDiffs = numVals.map(v => Math.pow(v - avg, 2));
                  const avgSquaredDiff = squaredDiffs.reduce((a, b) => a + b, 0) / numVals.length;
                  const stdDev = Math.sqrt(avgSquaredDiff);
                  
                  // Detect outliers (values > 3 std devs from mean)
                  const outliers = numVals.filter(v => Math.abs(v - avg) > 3 * stdDev);
                  
                  // Is this a rate/percentage? (values 0-1 or 0-100)
                  const isRate = max <= 100 && min >= 0 && 
                    (/rate|percent|%|ratio/i.test(fieldName) || max <= 1);
                  
                  numericStats = {
                    min, max, avg: avg.toFixed(2), median, stdDev: stdDev.toFixed(2),
                    sum: sum.toFixed(2),
                    outlierCount: outliers.length,
                    isRate,
                    hasNegatives: min < 0
                  };
                }
              }
              
              // Check for timestamps in date fields
              let hasTimestamps = false;
              let duplicateDateCount = 0;
              let uniqueDateCount = 0;
              if (isDate) {
                // Check if values have time components
                hasTimestamps = formattedValues.some(v => 
                  v && (/\d{1,2}:\d{2}(:\d{2})?(\s*(AM|PM))?/i.test(v) || /T\d{2}:\d{2}/.test(v))
                );
                
                if (hasTimestamps) {
                  // Count unique dates (stripped of time)
                  const dateParts = formattedValues.map(v => {
                    if (!v) return null;
                    // Strip time portion
                    return v.replace(/,?\s*\d{1,2}:\d{2}(:\d{2})?\s*(AM|PM)?$/i, '').trim()
                      .replace(/T\d{2}:\d{2}.*$/, '');
                  });
                  const uniqueDates = new Set(dateParts.filter(v => v));
                  uniqueDateCount = uniqueDates.size;
                  duplicateDateCount = formattedValues.length - uniqueDateCount;
                }
              }
              
              // Build column profile
              const colProfile = {
                name: fieldName,
                dataType: dataType,
                classification: isDate ? 'date' : (isMeasure ? 'measure' : 'dimension'),
                cardinality: cardinality,
                nullCount: nullCount,
                nullPercent: parseFloat(nullPercent),
                sampleValues: Array.from(uniqueValues).slice(0, 5),
                numericStats: numericStats,
                dateAnalysis: isDate ? {
                  hasTimestamps,
                  uniqueDateCount,
                  duplicateDateCount,
                  needsAggregation: hasTimestamps && duplicateDateCount > cardinality * 0.2
                } : null
              };
              
              profile.columns.push(colProfile);
              
              // Check for data quality issues
              if (nullPercent > 20) {
                profile.dataQuality.issues.push({
                  field: fieldName,
                  issue: 'high_null_rate',
                  severity: nullPercent > 50 ? 'error' : 'warning',
                  message: `${nullPercent}% of values are null/empty`,
                  suggestion: 'Consider filtering out nulls or using a different field'
                });
                profile.dataQuality.overallScore -= nullPercent > 50 ? 20 : 10;
              }
              
              if (isDate && colProfile.dateAnalysis?.needsAggregation) {
                profile.dataQuality.warnings.push({
                  field: fieldName,
                  issue: 'timestamp_causes_duplicates',
                  message: `Date field has timestamps causing ${duplicateDateCount} duplicate dates. ${uniqueDateCount} unique dates across ${cardinality} values.`,
                  suggestion: 'Use aggregateByDate=true when rendering time series charts'
                });
              }
              
              if (numericStats?.outlierCount > 0) {
                profile.dataQuality.warnings.push({
                  field: fieldName,
                  issue: 'outliers_detected',
                  message: `${numericStats.outlierCount} outlier values detected (>3 std devs from mean)`,
                  suggestion: 'Consider filtering outliers or using logarithmic scale'
                });
              }
              
              if (cardinality > 20 && !isMeasure && !isDate) {
                profile.dataQuality.warnings.push({
                  field: fieldName,
                  issue: 'high_cardinality',
                  message: `${cardinality} unique values - too many for pie/donut charts`,
                  suggestion: 'Use bar chart or limit to top N categories'
                });
              }
              
              if (cardinality === 1 && rows.length > 1) {
                profile.dataQuality.warnings.push({
                  field: fieldName,
                  issue: 'single_value',
                  message: 'All rows have the same value - no variance to visualize',
                  suggestion: 'This field may not be useful for visualization'
                });
              }
            }
            
            // ============================================
            // VISUALIZATION RECOMMENDATIONS
            // ============================================
            
            const dateColumns = profile.columns.filter(c => c.classification === 'date');
            const measureColumns = profile.columns.filter(c => c.classification === 'measure');
            const dimensionColumns = profile.columns.filter(c => c.classification === 'dimension');
            
            // Identify primary dimension and measure
            profile.recommendations.primaryDimension = 
              (args.focusDimension && profile.columns.find(c => c.name.includes(args.focusDimension))) ||
              dateColumns[0] || 
              dimensionColumns.sort((a, b) => b.cardinality - a.cardinality)[0];
            
            profile.recommendations.primaryMeasure = 
              (args.focusMeasure && profile.columns.find(c => c.name.includes(args.focusMeasure))) ||
              measureColumns[0];
            
            // Check for aggregation needs
            const dateWithTimestamps = dateColumns.find(c => c.dateAnalysis?.needsAggregation);
            if (dateWithTimestamps) {
              profile.recommendations.aggregationNeeded = true;
              profile.recommendations.aggregationType = measureColumns.some(m => m.numericStats?.isRate) ? 'average' : 'sum';
              profile.recommendations.aggregationReason = `The date field "${dateWithTimestamps.name}" contains timestamps. Values should be aggregated by date.`;
            }
            
            // Recommend chart types based on data shape
            const vizRecommendations = [];
            
            if (dateColumns.length > 0 && measureColumns.length > 0) {
              vizRecommendations.push({
                type: 'line',
                confidence: 'high',
                reason: 'Date dimension + measure = time series visualization',
                parameters: {
                  aggregateByDate: dateWithTimestamps ? true : false,
                  aggregationType: profile.recommendations.aggregationType || 'sum'
                }
              });
              vizRecommendations.push({
                type: 'area',
                confidence: 'medium',
                reason: 'Area chart also works for time series with emphasis on volume'
              });
            }
            
            if (dimensionColumns.length > 0 && measureColumns.length > 0) {
              const bestDim = dimensionColumns.sort((a, b) => a.cardinality - b.cardinality)[0];
              
              if (bestDim.cardinality <= 6) {
                vizRecommendations.push({
                  type: 'pie',
                  confidence: 'medium',
                  reason: `${bestDim.cardinality} categories - good for part-to-whole comparison`
                });
                vizRecommendations.push({
                  type: 'donut',
                  confidence: 'medium',
                  reason: 'Donut works well for 2-6 categories with center for total/label'
                });
              }
              
              vizRecommendations.push({
                type: 'bar',
                confidence: bestDim.cardinality > 6 ? 'high' : 'medium',
                reason: `Bar chart is versatile, especially for ${bestDim.cardinality} categories`
              });
              
              if (bestDim.cardinality > 10) {
                vizRecommendations.push({
                  type: 'horizontal-bar',
                  confidence: 'high',
                  reason: 'Horizontal bars better for many categories - easier to read labels'
                });
              }
            }
            
            if (measureColumns.length >= 1 && rows.length <= 5) {
              vizRecommendations.push({
                type: 'kpi',
                confidence: 'high',
                reason: 'Single or few values - ideal for KPI cards'
              });
            }
            
            profile.recommendations.suggestedVizTypes = vizRecommendations;
            
            // Check compatibility with intended viz type
            if (args.intendedVizType && args.intendedVizType !== 'auto') {
              const compatibility = { compatible: true, warnings: [] };
              
              if ((args.intendedVizType === 'pie' || args.intendedVizType === 'donut')) {
                const dim = dimensionColumns[0];
                if (dim && dim.cardinality > 8) {
                  compatibility.compatible = false;
                  compatibility.warnings.push(`Pie/donut charts not recommended for ${dim.cardinality} categories. Use bar chart instead.`);
                }
              }
              
              if (args.intendedVizType === 'line' || args.intendedVizType === 'area') {
                if (dateColumns.length === 0) {
                  compatibility.warnings.push('No date field found. Line charts are best for time series data.');
                }
                if (dateWithTimestamps) {
                  compatibility.warnings.push(`Data has timestamps - use aggregateByDate=true`);
                }
              }
              
              profile.recommendations.intendedVizCompatibility = compatibility;
            }
            
            // ============================================
            // BUILD FINAL RESPONSE
            // ============================================
            
            // Create human-readable summary
            let summary = `## Data Profile: ${args.worksheet}\n\n`;
            summary += `**Rows:** ${rows.length} | **Columns:** ${columns.length}\n\n`;
            
            summary += `### Field Classification\n`;
            summary += `| Field | Type | Cardinality | Nulls | Notes |\n`;
            summary += `|-------|------|-------------|-------|-------|\n`;
            for (const col of profile.columns) {
              const notes = [];
              if (col.dateAnalysis?.hasTimestamps) notes.push('Has timestamps');
              if (col.numericStats?.isRate) notes.push('Rate/Percent');
              if (col.nullPercent > 10) notes.push(`${col.nullPercent}% null`);
              summary += `| ${col.name} | ${col.classification} | ${col.cardinality} | ${col.nullCount} | ${notes.join(', ')} |\n`;
            }
            
            if (profile.dataQuality.issues.length > 0 || profile.dataQuality.warnings.length > 0) {
              summary += `\n### Data Quality Alerts\n`;
              for (const issue of [...profile.dataQuality.issues, ...profile.dataQuality.warnings]) {
                summary += `- **${issue.field}**: ${issue.message}\n  - Suggestion: ${issue.suggestion}\n`;
              }
            }
            
            summary += `\n### Recommended Visualizations\n`;
            for (const rec of vizRecommendations.slice(0, 3)) {
              summary += `- **${rec.type}** (${rec.confidence} confidence): ${rec.reason}\n`;
            }
            
            if (profile.recommendations.aggregationNeeded) {
              summary += `\n### Aggregation Required\n`;
              summary += `${profile.recommendations.aggregationReason}\n`;
              summary += `Use: \`aggregateByDate: true, aggregationType: "${profile.recommendations.aggregationType}"\`\n`;
            }
            
            profile.summary = summary;
            
            return JSON.stringify(profile, null, 2);
          }
          
          case 'apply_filter': {
            const ws = dashboard.worksheets.find(w => w.name === args.worksheet);
            if (!ws) throw new Error('Worksheet not found: ' + args.worksheet);
            
            // Handle legacy 'exclude' boolean param
            const action = args.action || (args.exclude ? 'exclude' : 'set');
            
            if (action === 'clear') {
              // Clear the filter - use clearFilterAsync
              try {
                await ws.clearFilterAsync(args.field);
              } catch (e) {
                // If clearFilterAsync fails, try applyFilterAsync with All
                // Some filter types may need different handling
                console.log('clearFilterAsync failed, trying alternative:', e.message);
                await ws.applyFilterAsync(args.field, [], tableau.FilterUpdateType.All);
              }
              
              // Refresh dashboard context after filter change
              await fetchDashboardContext();
              
              return `Filter cleared: ${args.field} on "${args.worksheet}" - now showing all values`;
            } else {
              // Apply or exclude filter
              if (!args.values || args.values.length === 0) {
                throw new Error('Values are required for set/exclude actions. Use action="clear" to reset the filter.');
              }
              
              const updateType = action === 'exclude' 
                ? tableau.FilterUpdateType.Remove 
                : tableau.FilterUpdateType.Replace;
              
              await ws.applyFilterAsync(args.field, args.values, updateType);
              
              // Refresh dashboard context after filter change
              await fetchDashboardContext();
              
              return `Filter applied: ${action === 'exclude' ? 'Excluded' : 'Set'} ${args.field} ${action === 'exclude' ? 'to exclude' : 'to'} [${args.values.join(', ')}] on "${args.worksheet}"`;
            }
          }
          
          case 'set_parameter': {
            const params = await dashboard.getParametersAsync();
            const param = params.find(p => p.name === args.name);
            if (!param) throw new Error('Parameter not found: ' + args.name);
            
            await param.changeValueAsync(args.value);
            
            // Refresh dashboard context
            await fetchDashboardContext();
            
            return `Parameter "${args.name}" set to "${args.value}"`;
          }
          
          case 'get_worksheet_data': {
            const ws = dashboard.worksheets.find(w => w.name === args.worksheet);
            if (!ws) throw new Error('Worksheet not found: ' + args.worksheet);
            
            const dataTable = await ws.getSummaryDataAsync();
            const columns = dataTable.columns.map(c => ({
              name: c.fieldName,
              dataType: c.dataType
            }));
            const rows = dataTable.data.slice(0, args.maxRows || 100).map(row =>
              row.map(cell => cell.formattedValue)
            );
            
            // ============================================
            // INTELLIGENT DATA STRUCTURE ANALYSIS
            // ============================================
            
            // Helper: Check if a value looks like it has a timestamp
            const hasTimestamp = (val) => {
              if (!val) return false;
              const str = String(val);
              // Check for time patterns: HH:MM, H:MM AM/PM, ISO T format
              return /\d{1,2}:\d{2}(:\d{2})?(\s*(AM|PM))?/i.test(str) || 
                     /T\d{2}:\d{2}/.test(str);
            };
            
            // Helper: Extract just the date part (strip time)
            const extractDatePart = (val) => {
              if (!val) return null;
              const str = String(val);
              // Try to extract just the date portion
              // Match patterns like "October 26, 2025" or "2025-10-26" or "10/26/2025"
              const isoMatch = str.match(/^(\d{4}-\d{2}-\d{2})/);
              if (isoMatch) return isoMatch[1];
              
              const usMatch = str.match(/^(\d{1,2}\/\d{1,2}\/\d{2,4})/);
              if (usMatch) return usMatch[1];
              
              const fullMatch = str.match(/^(\w+\s+\d{1,2},?\s*\d{4})/);
              if (fullMatch) return fullMatch[1];
              
              // For timestamps, strip the time part
              const beforeTime = str.split(/,?\s*\d{1,2}:\d{2}/)[0];
              if (beforeTime && beforeTime.length > 5) return beforeTime.trim();
              
              return str;
            };
            
            // Analyze each column
            const columnAnalysis = columns.map((col, colIdx) => {
              const values = rows.map(row => row[colIdx]).filter(v => v);
              const uniqueValues = new Set(values);
              
              // Check if this looks like a date column
              const isDate = col.dataType === 'date' || col.dataType === 'datetime' ||
                /date|time|day|week|month|year|period/i.test(col.name) ||
                values.some(v => /\d{4}-\d{2}-\d{2}|^\w+\s+\d{1,2},?\s*\d{4}|\d{1,2}\/\d{1,2}\/\d{2,4}/.test(String(v)));
              
              // Check if values have timestamps
              const timestampCount = values.filter(hasTimestamp).length;
              const hasTimestamps = timestampCount > values.length * 0.5;
              
              // Check for duplicate dates (after stripping time)
              let hasDuplicateDates = false;
              let uniqueDateCount = 0;
              if (isDate && hasTimestamps) {
                const dateParts = values.map(extractDatePart);
                const uniqueDates = new Set(dateParts);
                uniqueDateCount = uniqueDates.size;
                hasDuplicateDates = uniqueDates.size < values.length * 0.8;
              }
              
              // Check if this looks like a measure
              const isMeasure = ['int', 'float', 'number'].includes(col.dataType) ||
                /sum|avg|count|total|rate|amount|qty|revenue|sales|profit/i.test(col.name) ||
                /^(SUM|AVG|COUNT|CNTD|MIN|MAX|AGG)\s*\(/i.test(col.name);
              
              return {
                name: col.name,
                dataType: col.dataType,
                uniqueValueCount: uniqueValues.size,
                isDateColumn: isDate,
                isMeasureColumn: isMeasure,
                hasTimestamps: hasTimestamps,
                hasDuplicateDates: hasDuplicateDates,
                uniqueDateCount: uniqueDateCount,
                sampleValues: values.slice(0, 3)
              };
            });
            
            // Overall analysis
            const dateColumns = columnAnalysis.filter(c => c.isDateColumn);
            const measureColumns = columnAnalysis.filter(c => c.isMeasureColumn);
            const hasTimestampData = dateColumns.some(c => c.hasTimestamps);
            const hasDuplicateDates = dateColumns.some(c => c.hasDuplicateDates);
            
            // Determine aggregation recommendation
            let suggestedAggregation = null;
            let aggregationReason = null;
            if (hasDuplicateDates) {
              const dateCol = dateColumns.find(c => c.hasDuplicateDates);
              suggestedAggregation = 'sum';
              aggregationReason = `The date column "${dateCol?.name}" contains timestamps, causing ${rows.length} rows to map to only ${dateCol?.uniqueDateCount} unique dates. Set aggregateByDate=true to sum values by date.`;
            }
            
            const result = {
              worksheet: args.worksheet,
              columns: columns.map(c => c.name),
              columnDetails: columnAnalysis,
              rowCount: rows.length,
              sampleRows: rows.slice(0, 5),
              
              // Intelligent analysis
              dataQuality: {
                hasTimestampData,
                hasDuplicateDates,
                suggestedAggregation,
                aggregationReason,
                dateColumns: dateColumns.map(c => c.name),
                measureColumns: measureColumns.map(c => c.name)
              },
              
              // Recommendation for LLM
              recommendation: hasDuplicateDates 
                ? `Note: This data has timestamps causing duplicate dates. When rendering a time series chart, use aggregateByDate=true to aggregate values by date.`
                : hasTimestampData
                  ? `This data includes timestamps. Charts will show individual time points.`
                  : `Data structure looks good for visualization.`
            };
            
            return JSON.stringify(result, null, 2);
          }
          
          case 'generate_documentation': {
            const docData = await generateDocumentationData(args);
            
            // Generate an AI summary of the dashboard
            let aiSummary = null;
            try {
              aiSummary = await generateDashboardSummary(docData);
            } catch (e) {
              console.log('Could not generate AI summary:', e);
            }
            
            const markdown = generateMarkdownFromData(docData, aiSummary);
            
            // Store the generated documentation for download
            lastGeneratedDoc = {
              markdown: markdown,
              data: docData,
              timestamp: new Date().toISOString()
            };
            
            // Return markdown with download instruction
            return markdown + '\n\n---\n*Click the "Download PDF" button below to save this documentation.*';
          }
          
          case 'analyze_design': {
            // Check if there's an uploaded image
            if (!uploadedImage) {
              // Auto-switch to Design tab to make it easy
              const designTab = document.querySelector('[data-panel="design"]');
              if (designTab) designTab.click();
              
              // Highlight the capture button briefly
              setTimeout(() => {
                const captureBtn = document.getElementById('btn-capture');
                if (captureBtn) {
                  captureBtn.classList.add('pulse-highlight');
                  setTimeout(() => captureBtn.classList.remove('pulse-highlight'), 3000);
                }
              }, 300);
              
              return `## I Need a Screenshot of Your Dashboard

I've switched you to the **Design tab**. To analyze your dashboard design:

1. **Click the "Capture Screen" button** (highlighted above)
2. **Select your Tableau browser window/tab** from the popup
3. The screenshot will appear in the drop zone
4. **Ask me again** to analyze it, or click "Analyze Design"

**Other options:**
- **Paste a screenshot** (Ctrl+V) if you already have one copied
- **Drag & drop** an image file into the drop zone

Once I can see your dashboard, I'll provide a comprehensive design review with specific recommendations!`;
            }
            
            const analysisType = args.analysisType || 'design-review';
            const focusArea = args.focusArea || '';
            
            // Build analysis prompt based on type - BE SPECIFIC AND ACTIONABLE
            let analysisPrompt = `You are an expert Tableau dashboard designer and data visualization consultant. Analyze this dashboard screenshot and provide SPECIFIC, ACTIONABLE feedback. 

DO NOT be vague. For every issue you identify:
- Describe EXACTLY what you see (e.g., "The bar chart in the top-right uses 8 different colors")
- Explain WHY it's a problem (e.g., "This exceeds the 5-color rule and makes comparison difficult")
- Give a SPECIFIC fix (e.g., "Use a single color with varying saturation, or highlight only the top 3 categories")

${focusArea ? `FOCUS AREA: ${focusArea}\n\n` : ''}`;
            
            if (analysisType === 'storytelling') {
              analysisPrompt += `## DATA STORYTELLING ANALYSIS

### 1. The "So What?" Test
- What story is this dashboard trying to tell? State it in ONE sentence.
- Can a viewer understand the main message in under 5 seconds?
- If the story is unclear, what specific title/headline would fix it?

### 2. Visual Flow Analysis
- Describe the eye path: Where does the eye go first, second, third?
- Is the most important insight in the top-left quadrant (where eyes start)?
- What element is competing for attention that shouldn't be?

### 3. Chart-by-Chart Audit
For EACH chart/viz visible:
- What is it showing?
- Does it support the main story or distract from it?
- Should it be removed, combined, or repositioned?

### 4. Missing Story Elements
- Are there annotations/callouts highlighting key numbers?
- Is there context (vs last year, vs target, vs benchmark)?
- What question does this dashboard NOT answer that it should?

### 5. Specific Rewrite
Provide a CONCRETE recommendation:
- Suggested new title that tells the story
- Which 1-2 charts to make the hero
- What to remove or minimize
- What annotation to add`;
            } else if (analysisType === 'accessibility') {
              analysisPrompt += `## ACCESSIBILITY AUDIT (WCAG 2.1 COMPLIANCE)

### 1. Color Contrast Issues
- Identify ANY text that appears low-contrast (estimate the contrast ratio)
- List specific colors that fail WCAG AA (4.5:1 for text, 3:1 for large text)
- Check: Are axis labels, legends, and tooltips readable?

### 2. Colorblind Simulation
- If you removed all color, could you still understand the data?
- Identify charts using red/green together (deuteranopia fail)
- Are there patterns, shapes, or labels as alternatives to color?

### 3. Text Legibility
- Estimate font sizes - anything below 12px?
- Are there labels that overlap or get cut off?
- Is there sufficient spacing between elements?

### 4. Specific Fixes Required
For each issue, provide:
| Issue | Location | Current State | Fix Required |
|-------|----------|---------------|--------------|
(fill in the table with specific issues)

### 5. Priority Remediation
List the top 3 accessibility fixes in order of impact.`;
            } else {
              // design-review or general - MAKE IT SPECIFIC
              analysisPrompt += `## COMPREHENSIVE DESIGN AUDIT

### 1. First Impressions (5-Second Test)
- What grabs attention first? Is that the RIGHT thing to highlight?
- What's the apparent purpose of this dashboard?
- Initial reaction: Clean/cluttered? Professional/amateur? Focused/scattered?

### 2. Layout Critique
- Describe the grid structure (or lack thereof)
- Are elements aligned? Point out specific misalignments
- Is there breathing room, or is everything crammed together?
- Suggested layout changes with specific positions

### 3. Color Audit
Count the colors used and list them:
- How many distinct colors? (Best practice: 5 or fewer meaningful colors)
- Is there a clear color hierarchy (primary, secondary, accent)?
- Are colors meaningful (red=bad, green=good) or arbitrary?
- Specific palette recommendation if needed

### 4. Chart-by-Chart Review
For EACH visualization:
| Chart | Type | What It Shows | Issue | Recommendation |
|-------|------|---------------|-------|----------------|
(fill in for each chart visible)

### 5. Typography Check
- How many font sizes are used? (Best practice: 3 levels max)
- Is there a clear hierarchy (title > subtitle > body > caption)?
- Any fonts that don't match or look unprofessional?

### 6. Data-Ink Ratio
- Identify any "chart junk" (unnecessary gridlines, 3D effects, borders)
- What visual elements can be removed without losing information?

### 7. Scoreboard
| Category | Score (1-10) | Key Issue |
|----------|--------------|-----------|
| Layout | ? | ... |
| Color | ? | ... |
| Typography | ? | ... |
| Chart Selection | ? | ... |
| Clarity | ? | ... |
| **OVERALL** | ? | ... |

### 8. Top 5 Action Items
Numbered list of the 5 most impactful changes, in priority order, with SPECIFIC instructions (not vague advice).`;
            }
            
            // Call the LLM with vision
            try {
              const response = await callLLM(analysisPrompt, uploadedImage);
              
              // Store for PDF download
              lastGeneratedAnalysis = {
                markdown: response,
                data: { analysisType, focusArea },
                timestamp: new Date().toISOString()
              };
              
              return `# Dashboard Design Analysis\n\n**Analysis Type:** ${analysisType}\n**Generated:** ${new Date().toLocaleString()}\n\n${response}\n\n---\n*Click the "Download Analysis PDF" button below to save this report.*`;
            } catch (error) {
              return `## Analysis Failed\n\n${error.message}\n\nPlease try again or check that your API key is configured correctly.`;
            }
          }
          
          case 'full_data_exploration': {
            // Comprehensive data exploration for data scientists
            const analysisDepth = args.analysisDepth || 'standard';
            const focusAreas = args.focusAreas || ['profiling', 'correlations', 'quality', 'outliers', 'distributions', 'trends', 'drivers'];
            const targetMeasure = args.targetMeasure || null;
            
            const startTime = Date.now();
            let report = `# 🔬 Comprehensive Data Exploration Report\n\n`;
            report += `**Analysis Depth:** ${analysisDepth.charAt(0).toUpperCase() + analysisDepth.slice(1)}\n`;
            report += `**Generated:** ${new Date().toLocaleString()}\n`;
            report += `**Dashboard:** ${dashboard.name || 'Connected Dashboard'}\n\n`;
            
            // Collect all data first
            const allFieldData = {}; // { fieldName: { values: [], type, worksheet } }
            const worksheetMeta = [];
            let totalRows = 0;
            let totalFields = 0;
            
            for (const ws of dashboard.worksheets.slice(0, 8)) {
              try {
                const dataTable = await ws.getSummaryDataAsync({ maxRows: 1000 });
                const columns = dataTable.columns;
                const rows = dataTable.data;
                totalRows += rows.length;
                
                const wsFields = [];
                
                for (let colIdx = 0; colIdx < columns.length; colIdx++) {
                  const col = columns[colIdx];
                  const fieldName = col.fieldName;
                  const dataType = col.dataType;
                  
                  // Skip internal fields
                  if (fieldName === 'Measure Names' || fieldName === 'Measure Values') continue;
                  
                  // Extract values
                  const rawValues = rows.map(r => r[colIdx]?.value);
                  const formattedValues = rows.map(r => r[colIdx]?.formattedValue);
                  const numericValues = rawValues.map(v => parseFloat(v)).filter(v => !isNaN(v));
                  
                  // Store field data for cross-field analysis
                  if (!allFieldData[fieldName]) {
                    allFieldData[fieldName] = {
                      values: rawValues,
                      numericValues,
                      formattedValues,
                      type: dataType,
                      worksheet: ws.name,
                      isNumeric: numericValues.length > rawValues.length * 0.5
                    };
                  }
                  
                  wsFields.push({ name: fieldName, type: dataType });
                  totalFields++;
                }
                
                worksheetMeta.push({ name: ws.name, rowCount: rows.length, fields: wsFields });
              } catch (e) {
                worksheetMeta.push({ name: ws.name, error: e.message });
              }
            }
            
            const fields = Object.entries(allFieldData);
            const numericFields = fields.filter(([_, d]) => d.isNumeric);
            const categoricalFields = fields.filter(([_, d]) => !d.isNumeric);
            
            // ==================== DATA OVERVIEW ====================
            report += `## 📊 Data Overview\n\n`;
            report += `| Metric | Value |\n|--------|-------|\n`;
            report += `| Worksheets Analyzed | ${worksheetMeta.length} |\n`;
            report += `| Total Data Points | ${totalRows.toLocaleString()} |\n`;
            report += `| Unique Fields | ${fields.length} |\n`;
            report += `| Numeric Fields | ${numericFields.length} |\n`;
            report += `| Categorical Fields | ${categoricalFields.length} |\n\n`;
            
            report += `### Worksheets\n\n`;
            for (const ws of worksheetMeta) {
              if (ws.error) {
                report += `- ❌ **${ws.name}**: ${ws.error}\n`;
              } else {
                report += `- ✅ **${ws.name}**: ${ws.rowCount} rows, ${ws.fields.length} fields\n`;
              }
            }
            report += `\n`;
            
            // ==================== FIELD PROFILING ====================
            if (focusAreas.includes('profiling')) {
              report += `## 📋 Field Profiles\n\n`;
              
              report += `### Numeric Fields\n\n`;
              if (numericFields.length > 0) {
                report += `| Field | Count | Min | Max | Mean | Median | Std Dev | Distribution |\n`;
                report += `|-------|-------|-----|-----|------|--------|---------|---------------|\n`;
                
                for (const [fieldName, data] of numericFields.slice(0, 15)) {
                  const vals = data.numericValues;
                  if (vals.length === 0) continue;
                  
                  const sum = vals.reduce((a, b) => a + b, 0);
                  const mean = sum / vals.length;
                  const sorted = [...vals].sort((a, b) => a - b);
                  const median = sorted[Math.floor(sorted.length / 2)];
                  const variance = vals.reduce((acc, v) => acc + Math.pow(v - mean, 2), 0) / vals.length;
                  const stdDev = Math.sqrt(variance);
                  const min = sorted[0];
                  const max = sorted[sorted.length - 1];
                  
                  const dist = detectDistribution(vals);
                  const cleanName = fieldName.replace(/^(AGG|SUM|AVG|CNTD?|COUNT|ATTR)\(|\)$/gi, '').substring(0, 25);
                  
                  report += `| ${cleanName} | ${vals.length} | ${min.toFixed(2)} | ${max.toFixed(2)} | ${mean.toFixed(2)} | ${median.toFixed(2)} | ${stdDev.toFixed(2)} | ${dist.type} |\n`;
                  
                  // Store in exploration cache
                  storyCache.explorationState.fieldProfiles[fieldName] = {
                    type: 'numeric',
                    count: vals.length,
                    min, max, mean, median, stdDev,
                    distribution: dist,
                    percentiles: calculatePercentiles(vals)
                  };
                }
                report += `\n`;
              } else {
                report += `*No numeric fields found*\n\n`;
              }
              
              report += `### Categorical Fields\n\n`;
              if (categoricalFields.length > 0) {
                report += `| Field | Unique Values | Top Value | Top % | Concentration |\n`;
                report += `|-------|---------------|-----------|-------|---------------|\n`;
                
                for (const [fieldName, data] of categoricalFields.slice(0, 15)) {
                  const vals = data.formattedValues.filter(v => v && v !== '%null%');
                  if (vals.length === 0) continue;
                  
                  const valueCounts = {};
                  for (const v of vals) {
                    valueCounts[v] = (valueCounts[v] || 0) + 1;
                  }
                  
                  const sorted = Object.entries(valueCounts).sort((a, b) => b[1] - a[1]);
                  const uniqueCount = sorted.length;
                  const topValue = sorted[0]?.[0] || '-';
                  const topPct = sorted[0] ? ((sorted[0][1] / vals.length) * 100).toFixed(1) : 0;
                  
                  // Calculate Gini for concentration
                  const counts = sorted.map(s => s[1]);
                  const gini = calculateGiniCoefficient(counts);
                  const concentration = gini > 0.6 ? 'High' : gini > 0.3 ? 'Moderate' : 'Low';
                  
                  const cleanName = fieldName.substring(0, 25);
                  const displayTop = topValue.length > 20 ? topValue.substring(0, 18) + '...' : topValue;
                  
                  report += `| ${cleanName} | ${uniqueCount} | ${displayTop} | ${topPct}% | ${concentration} (${gini}) |\n`;
                  
                  storyCache.explorationState.fieldProfiles[fieldName] = {
                    type: 'categorical',
                    uniqueCount,
                    topValues: sorted.slice(0, 5),
                    giniCoefficient: gini,
                    concentration
                  };
                }
                report += `\n`;
              } else {
                report += `*No categorical fields found*\n\n`;
              }
            }
            
            // ==================== DATA QUALITY ====================
            if (focusAreas.includes('quality')) {
              report += `## 🔍 Data Quality Assessment\n\n`;
              
              let qualityIssues = [];
              let totalNulls = 0;
              let totalValues = 0;
              
              for (const [fieldName, data] of fields) {
                const nullCount = data.values.filter(v => v === null || v === undefined || v === '' || v === '%null%').length;
                const total = data.values.length;
                totalNulls += nullCount;
                totalValues += total;
                
                const nullPct = (nullCount / total * 100);
                
                if (nullPct > 5) {
                  qualityIssues.push({
                    field: fieldName.substring(0, 30),
                    issue: 'Missing values',
                    severity: nullPct > 30 ? 'High' : nullPct > 15 ? 'Medium' : 'Low',
                    details: `${nullPct.toFixed(1)}% null (${nullCount}/${total})`
                  });
                }
                
                // Check for outliers in numeric fields
                if (data.isNumeric && data.numericValues.length > 10) {
                  const outliers = detectOutliers(data.numericValues, fieldName);
                  if (outliers.length > 0) {
                    qualityIssues.push({
                      field: fieldName.substring(0, 30),
                      issue: 'Outliers detected',
                      severity: outliers.length > 5 ? 'Medium' : 'Low',
                      details: `${outliers.length} outlier(s) found`
                    });
                  }
                }
              }
              
              const completeness = ((1 - totalNulls / totalValues) * 100).toFixed(1);
              
              report += `### Quality Metrics\n\n`;
              report += `| Metric | Score |\n|--------|-------|\n`;
              report += `| Overall Completeness | ${completeness}% |\n`;
              report += `| Fields with Issues | ${qualityIssues.length} |\n`;
              report += `| High Severity Issues | ${qualityIssues.filter(i => i.severity === 'High').length} |\n\n`;
              
              storyCache.explorationState.dataQuality = {
                completeness: parseFloat(completeness),
                issues: qualityIssues
              };
              
              if (qualityIssues.length > 0) {
                report += `### Issues Found\n\n`;
                report += `| Field | Issue | Severity | Details |\n`;
                report += `|-------|-------|----------|----------|\n`;
                for (const issue of qualityIssues.slice(0, 15)) {
                  const severityIcon = issue.severity === 'High' ? '🔴' : issue.severity === 'Medium' ? '🟡' : '🟢';
                  report += `| ${issue.field} | ${issue.issue} | ${severityIcon} ${issue.severity} | ${issue.details} |\n`;
                }
                report += `\n`;
              } else {
                report += `✅ **No significant data quality issues detected!**\n\n`;
              }
            }
            
            // ==================== CORRELATION ANALYSIS ====================
            if (focusAreas.includes('correlations') && numericFields.length >= 2 && analysisDepth !== 'quick') {
              report += `## 📈 Correlation Analysis\n\n`;
              
              const correlations = [];
              const fieldsToCorrelate = numericFields.slice(0, 8); // Limit for performance
              
              for (let i = 0; i < fieldsToCorrelate.length; i++) {
                for (let j = i + 1; j < fieldsToCorrelate.length; j++) {
                  const [name1, data1] = fieldsToCorrelate[i];
                  const [name2, data2] = fieldsToCorrelate[j];
                  
                  // Align arrays (use minimum length)
                  const len = Math.min(data1.numericValues.length, data2.numericValues.length);
                  if (len < 10) continue;
                  
                  const x = data1.numericValues.slice(0, len);
                  const y = data2.numericValues.slice(0, len);
                  
                  const corr = calculateCorrelation(x, y);
                  
                  const cleanName1 = name1.replace(/^(AGG|SUM|AVG|CNTD?|COUNT|ATTR)\(|\)$/gi, '').substring(0, 20);
                  const cleanName2 = name2.replace(/^(AGG|SUM|AVG|CNTD?|COUNT|ATTR)\(|\)$/gi, '').substring(0, 20);
                  
                  correlations.push({
                    field1: cleanName1,
                    field2: cleanName2,
                    r: corr.r,
                    strength: corr.strength,
                    direction: corr.direction,
                    significant: corr.significant
                  });
                  
                  storyCache.explorationState.correlationMatrix[`${name1}|${name2}`] = corr;
                }
              }
              
              // Sort by absolute correlation
              correlations.sort((a, b) => Math.abs(b.r) - Math.abs(a.r));
              
              const significant = correlations.filter(c => c.significant && Math.abs(c.r) > 0.3);
              
              if (significant.length > 0) {
                report += `### Significant Correlations\n\n`;
                report += `| Field 1 | Field 2 | r | Strength | Direction |\n`;
                report += `|---------|---------|---|----------|------------|\n`;
                
                for (const c of significant.slice(0, 10)) {
                  const icon = c.direction === 'positive' ? '📈' : '📉';
                  report += `| ${c.field1} | ${c.field2} | ${c.r} | ${c.strength} | ${icon} ${c.direction} |\n`;
                }
                report += `\n`;
                
                // Highlight key finding
                if (significant.length > 0) {
                  const strongest = significant[0];
                  report += `> **Key Finding:** ${strongest.field1} and ${strongest.field2} have a **${strongest.strength} ${strongest.direction}** correlation (r=${strongest.r})\n\n`;
                }
              } else {
                report += `*No statistically significant correlations found between numeric fields.*\n\n`;
              }
            }
            
            // ==================== OUTLIER ANALYSIS ====================
            if (focusAreas.includes('outliers') && numericFields.length > 0) {
              report += `## 🎯 Outlier Analysis\n\n`;
              
              let allOutliers = [];
              
              for (const [fieldName, data] of numericFields.slice(0, 10)) {
                if (data.numericValues.length < 10) continue;
                
                const outliers = detectOutliers(data.numericValues, fieldName);
                if (outliers.length > 0) {
                  const cleanName = fieldName.replace(/^(AGG|SUM|AVG|CNTD?|COUNT|ATTR)\(|\)$/gi, '');
                  allOutliers.push({
                    field: cleanName,
                    count: outliers.length,
                    highCount: outliers.filter(o => o.type === 'high').length,
                    lowCount: outliers.filter(o => o.type === 'low').length,
                    examples: outliers.slice(0, 3)
                  });
                }
              }
              
              if (allOutliers.length > 0) {
                report += `| Field | Outliers | High | Low | Example Values |\n`;
                report += `|-------|----------|------|-----|----------------|\n`;
                
                for (const o of allOutliers) {
                  const examples = o.examples.map(e => e.value.toFixed(2)).join(', ');
                  report += `| ${o.field.substring(0, 25)} | ${o.count} | ${o.highCount} | ${o.lowCount} | ${examples} |\n`;
                }
                report += `\n`;
                
                report += `*Outliers detected using IQR method (1.5× IQR from Q1/Q3)*\n\n`;
              } else {
                report += `✅ **No significant outliers detected in numeric fields.**\n\n`;
              }
            }
            
            // ==================== KEY DRIVERS (if target specified) ====================
            if (focusAreas.includes('drivers') && targetMeasure && analysisDepth === 'comprehensive') {
              report += `## 🎯 Key Drivers Analysis\n\n`;
              report += `**Target Variable:** ${targetMeasure}\n\n`;
              
              // Find the target field
              const targetField = numericFields.find(([name, _]) => 
                name.toLowerCase().includes(targetMeasure.toLowerCase()) ||
                targetMeasure.toLowerCase().includes(name.toLowerCase().replace(/^(agg|sum|avg)\(|\)$/gi, ''))
              );
              
              if (targetField) {
                const [targetName, targetData] = targetField;
                const targetValues = targetData.numericValues;
                
                report += `### Impact of Other Variables on ${targetMeasure}\n\n`;
                report += `| Driver | Correlation | Impact | Regression β | R² |\n`;
                report += `|--------|-------------|--------|--------------|----|\n`;
                
                const drivers = [];
                
                for (const [name, data] of numericFields) {
                  if (name === targetName) continue;
                  
                  const len = Math.min(data.numericValues.length, targetValues.length);
                  if (len < 10) continue;
                  
                  const x = data.numericValues.slice(0, len);
                  const y = targetValues.slice(0, len);
                  
                  const corr = calculateCorrelation(x, y);
                  const reg = linearRegression(x, y);
                  
                  if (reg && corr.significant) {
                    const cleanName = name.replace(/^(AGG|SUM|AVG|CNTD?|COUNT|ATTR)\(|\)$/gi, '').substring(0, 20);
                    const impact = corr.r > 0 ? (corr.strength === 'strong' || corr.strength === 'very strong' ? '⬆️ Strong +' : '↗️ Moderate +') : 
                                                (corr.strength === 'strong' || corr.strength === 'very strong' ? '⬇️ Strong -' : '↘️ Moderate -');
                    
                    drivers.push({
                      name: cleanName,
                      r: corr.r,
                      impact,
                      slope: reg.slope,
                      rSquared: reg.rSquared
                    });
                    
                    storyCache.explorationState.regressionModels[`${name}→${targetName}`] = {
                      ...reg,
                      correlation: corr
                    };
                  }
                }
                
                drivers.sort((a, b) => Math.abs(b.r) - Math.abs(a.r));
                
                for (const d of drivers.slice(0, 8)) {
                  report += `| ${d.name} | ${d.r} | ${d.impact} | ${d.slope} | ${d.rSquared} |\n`;
                }
                report += `\n`;
                
                if (drivers.length > 0) {
                  const topDriver = drivers[0];
                  report += `> **Top Driver:** "${topDriver.name}" explains ${(topDriver.rSquared * 100).toFixed(0)}% of variance in ${targetMeasure} (β=${topDriver.slope})\n\n`;
                }
              } else {
                report += `*Could not find target measure "${targetMeasure}" in the data.*\n\n`;
              }
            }
            
            // ==================== SUMMARY & RECOMMENDATIONS ====================
            report += `## 💡 Summary & Recommendations\n\n`;
            
            const quality = storyCache.explorationState.dataQuality;
            const significantCorrs = Object.values(storyCache.explorationState.correlationMatrix).filter(c => c.significant && Math.abs(c.r) > 0.4);
            
            report += `### Key Findings\n\n`;
            
            if (quality.completeness >= 95) {
              report += `- ✅ **Excellent data completeness** (${quality.completeness}%)\n`;
            } else if (quality.completeness >= 80) {
              report += `- ⚠️ **Good data completeness** (${quality.completeness}%) - some missing values\n`;
            } else {
              report += `- 🔴 **Data completeness needs attention** (${quality.completeness}%)\n`;
            }
            
            if (significantCorrs.length > 0) {
              report += `- 📈 Found **${significantCorrs.length} significant correlations** between variables\n`;
            }
            
            if (quality.issues && quality.issues.filter(i => i.severity === 'High').length > 0) {
              report += `- ⚠️ **${quality.issues.filter(i => i.severity === 'High').length} high-priority data issues** need attention\n`;
            }
            
            report += `\n### Recommended Next Steps\n\n`;
            report += `1. **Validate findings** with domain experts before acting\n`;
            report += `2. **Investigate correlations** to determine causality vs. coincidence\n`;
            report += `3. **Address data quality issues** before deep analysis\n`;
            
            if (analysisDepth !== 'comprehensive') {
              report += `4. **Run comprehensive analysis** with \`analysisDepth: "comprehensive"\` for more insights\n`;
            }
            
            const elapsedMs = Date.now() - startTime;
            report += `\n---\n*Analysis completed in ${(elapsedMs / 1000).toFixed(1)}s*\n`;
            
            return report;
          }
          
          case 'analyze_dashboard_smart': {
            // Comprehensive data profiling tool - field-centric approach
            let analysisGoal = (args.analysisGoal || 'quick-profile').toLowerCase().trim();
            const focusMeasures = args.focusMeasures || [];
            const focusDimensions = args.focusDimensions || [];
            const forceRefresh = args.forceRefresh || false;
            
            // Log received parameters for debugging
            console.log('[analyze_dashboard_smart] Received:', { analysisGoal, focusMeasures, focusDimensions });
            
            // ============================================================
            // CHECK CACHE FIRST - Use cached data if available
            // ============================================================
            const worksheetNames = dashboard.worksheets.map(ws => ws.name);
            let usingCache = false;
            let cachedData = null;
            
            if (!forceRefresh && !storyCache.isStale && storyCache.extractedData.worksheetSummaries.length > 0) {
              console.log('[analyze_dashboard_smart] Using cached data!');
              usingCache = true;
              cachedData = storyCache.extractedData;
            }
            
            // Normalize analysis goal - map user intent to correct analysis type
            // IMPORTANT: Check segment-deep-dive FIRST before other patterns that might match
            // Add null-safety with || '' fallback
            const goalStr = (analysisGoal || '').toLowerCase();
            if (goalStr === 'segment-deep-dive' || goalStr.includes('segment') || 
                goalStr.includes('breakdown') || goalStr.includes('by category') ||
                goalStr.includes('which') || goalStr.includes('compare')) {
              analysisGoal = 'segment-deep-dive';
            } else if (goalStr.includes('concentr') || goalStr.includes('pareto') || 
                       goalStr.includes('80/20') || goalStr.includes('80-20') ||
                       goalStr.includes('top contrib')) {
              analysisGoal = 'concentration-analysis';
            } else if (goalStr.includes('trend') || goalStr.includes('time') || 
                       goalStr.includes('over time') || goalStr.includes('pattern')) {
              analysisGoal = 'trend-analysis';
            } else if (goalStr.includes('anomal') || goalStr.includes('outlier') || 
                       goalStr.includes('unusual') || goalStr.includes('exception')) {
              analysisGoal = 'anomaly-scan';
            } else {
              // Default to quick-profile for general analysis requests
              analysisGoal = 'quick-profile';
            }
            
            console.log('[analyze_dashboard_smart] Normalized to:', analysisGoal, usingCache ? '(using cache)' : '(fresh extraction)');
            
            // ============================================================
            // FAST PATH: Use cache for segment-deep-dive if available
            // ============================================================
            if (usingCache && analysisGoal === 'segment-deep-dive' && cachedData.rankings && Object.keys(cachedData.rankings).length > 0) {
              console.log('[analyze_dashboard_smart] Fast path: Using cached rankings!');
              
              let report = `# Segment Performance Analysis\n\n`;
              report += `**Analysis Type:** Category Comparison by Metrics\n`;
              report += `**Generated:** ${new Date().toLocaleString()}\n`;
              report += `**Dashboard:** ${dashboard.name || 'Current Dashboard'}\n`;
              report += `**Source:** ⚡ Cached data (instant)\n`;
              if (focusMeasures.length > 0) report += `**Focus Measures:** ${focusMeasures.join(', ')}\n`;
              if (focusDimensions.length > 0) report += `**Focus Dimensions:** ${focusDimensions.join(', ')}\n`;
              report += `\n`;
              
              // Find relevant rankings from cache
              let foundRankings = false;
              
              for (const [rankKey, ranking] of Object.entries(cachedData.rankings)) {
                // Check if this ranking matches the focus
                const matchesMeasure = focusMeasures.length === 0 || focusMeasures.some(m => 
                  rankKey.toLowerCase().includes(m.toLowerCase()));
                const matchesDimension = focusDimensions.length === 0 || focusDimensions.some(d => 
                  rankKey.toLowerCase().includes(d.toLowerCase()));
                
                if (matchesMeasure || matchesDimension || (focusMeasures.length === 0 && focusDimensions.length === 0)) {
                  foundRankings = true;
                  report += `## ${rankKey}\n\n`;
                  report += `| Rank | Name | Value |\n`;
                  report += `|------|------|-------|\n`;
                  
                  for (const item of ranking.slice(0, 10)) {
                    report += `| ${item.rank} | ${item.name} | ${item.formatted || item.value} |\n`;
                  }
                  report += `\n`;
                  
                  if (ranking.length > 0) {
                    const top = ranking[0];
                    const parts = rankKey.split(' by ');
                    if (parts.length === 2) {
                      report += `> **Top Performer:** "${top.name}" leads with ${top.formatted || top.value} ${parts[0]}\n\n`;
                    }
                  }
                }
              }
              
              if (!foundRankings) {
                report += `*No cached rankings match the requested focus. Running fresh analysis...*\n\n`;
              } else {
                report += `---\n*Used cached analysis. Use \`forceRefresh: true\` to re-extract data.*\n`;
                return report;
              }
            }
            
            // Helper: Check if a field name looks like a meaningful measure (not an ID)
            function isMeaningfulMeasure(fieldName) {
              const name = fieldName.toLowerCase();
              // Skip ID fields, keys, and other non-analytical measures
              if (name === 'id' || name.endsWith(' id') || name.startsWith('id ') ||
                  name.includes('_id') || name.includes(' key') || name.includes('_key') ||
                  name === 'key' || name === 'row number' || name === 'index') {
                return false;
              }
              // Skip high-cardinality identifier patterns
              if (name.includes('guid') || name.includes('uuid') || name.includes('hash')) {
                return false;
              }
              return true;
            }
            
            // Helper: Clean up Tableau field names by removing aggregation prefixes
            function cleanFieldName(name) {
              if (!name) return name;
              // Remove common Tableau aggregation wrappers: AGG(), SUM(), AVG(), COUNT(), CNTD(), MIN(), MAX(), ATTR(), MEDIAN(), etc.
              // Also handles nested functions like HOUR(Activity Date)
              return name
                .replace(/^(AGG|SUM|AVG|COUNT|CNTD|CNT|MIN|MAX|ATTR|MEDIAN|STDEV|VAR|COUNTD|YEAR|QUARTER|MONTH|WEEK|DAY|HOUR|MINUTE|SECOND|DATEPART|DATETRUNC)\(/gi, '')
                .replace(/\)$/g, '')
                .trim();
            }
            
            // ============================================================
            // HELPER: Interpret viz purpose from fields and structure
            // ============================================================
            function interpretVizPurpose(wsName, fields, rowCount) {
              const dims = fields.filter(f => f.role === 'Dimension');
              const meas = fields.filter(f => f.role === 'Measure');
              const dateDims = dims.filter(f => f.dataCategory === 'Temporal');
              const catDims = dims.filter(f => f.dataCategory === 'Categorical');
              
              let vizType = 'summary';
              let purpose = '';
              let businessQuestion = '';
              let limitations = [];
              
              // Detect viz pattern based on field composition
              if (dateDims.length > 0 && meas.length > 0) {
                vizType = 'time-series';
                const dateField = dateDims[0].name;
                const measureNames = meas.map(m => cleanFieldName(m.name)).join(', ');
                purpose = `**Time Series Analysis** - Tracks ${measureNames} over ${cleanFieldName(dateField)}`;
                businessQuestion = `How have ${measureNames} changed over time?`;
                limitations.push('Only shows aggregated time points visible in the viz');
                limitations.push('Granularity limited to what\'s displayed (may hide daily/hourly detail)');
              } else if (catDims.length > 0 && meas.length > 0 && rowCount > 10) {
                vizType = 'breakdown';
                const dimName = cleanFieldName(catDims[0].name);
                const measureNames = meas.map(m => cleanFieldName(m.name)).join(', ');
                purpose = `**Category Breakdown** - Compares ${measureNames} across ${dimName}`;
                businessQuestion = `Which ${dimName} categories perform best/worst?`;
                limitations.push(`Only shows ${rowCount} data points in current view`);
                limitations.push('May be filtered - not showing full dataset');
              } else if (catDims.length >= 2 && meas.length > 0) {
                vizType = 'matrix';
                purpose = `**Cross-Analysis** - Examines ${meas[0]?.name} by ${catDims.map(d => d.name).join(' × ')}`;
                businessQuestion = `How do categories interact to affect ${meas[0]?.name}?`;
                limitations.push('Multi-dimensional view may hide individual record details');
              } else if (meas.length > 0 && dims.length === 0) {
                vizType = 'kpi';
                purpose = `**KPI Summary** - Displays key metrics: ${meas.map(m => m.name).join(', ')}`;
                businessQuestion = `What are the current performance numbers?`;
                limitations.push('Highly aggregated - single summary values');
                limitations.push('No dimensional breakdown available');
              } else if (dims.length > 0 && meas.length === 0) {
                vizType = 'list';
                purpose = `**Reference List** - Shows ${dims.map(d => d.name).join(', ')}`;
                businessQuestion = `What items/categories exist?`;
                limitations.push('No measures to quantify performance');
              } else {
                purpose = `**Data View** - Displays ${fields.length} fields with ${rowCount} records`;
                businessQuestion = `What does the data look like?`;
              }
              
              // Add common limitations
              limitations.push('Filters applied in Tableau affect what we see');
              limitations.push('Underlying data source may have more fields not used here');
              
              return { vizType, purpose, businessQuestion, limitations, dims, meas };
            }
            
            // Collect all fields across worksheets for unified profile
            const allFields = new Map(); // fieldName -> field info
            const worksheetProfiles = [];
            
            for (const ws of dashboard.worksheets) {
              try {
                const dataTable = await ws.getSummaryDataAsync();
                const columns = dataTable.columns;
                const data = dataTable.data;
                
                // Profile each field/column
                const fieldProfiles = [];
                
                for (let colIndex = 0; colIndex < columns.length; colIndex++) {
                  const col = columns[colIndex];
                  const fieldName = col.fieldName;
                  const dataType = col.dataType;
                  
                  // Extract values for this column
                  const values = data.map(row => row[colIndex]);
                  const rawValues = values.map(v => v?.value);
                  const formattedValues = values.map(v => v?.formattedValue);
                  
                  // Calculate field profile
                  const totalCount = values.length;
                  const nullCount = rawValues.filter(v => v === null || v === undefined || v === '' || v === '%null%').length;
                  const nullPercent = ((nullCount / totalCount) * 100).toFixed(1);
                  
                  // Determine field role
                  const isNumeric = dataType === 'float' || dataType === 'int';
                  const isDate = dataType === 'date' || dataType === 'date-time';
                  const isCalculated = fieldName.includes('AGG(') || fieldName.includes('SUM(') || 
                                       fieldName.includes('AVG(') || fieldName.includes('COUNT(') ||
                                       fieldName.includes('ATTR(');
                  const isMeasure = isNumeric || isCalculated;
                  const role = isMeasure ? 'Measure' : 'Dimension';
                  const dataCategory = isNumeric ? 'Quantitative' : (isDate ? 'Temporal' : 'Categorical');
                  
                  let fieldProfile = {
                    name: fieldName,
                    dataType: dataType,
                    role: role,
                    dataCategory: dataCategory,
                    isCalculated: isCalculated,
                    totalCount: totalCount,
                    nullCount: nullCount,
                    nullPercent: nullPercent + '%'
                  };
                  
                  if (isNumeric) {
                    // Numeric field statistics
                    const numericValues = rawValues
                      .map(v => parseFloat(v))
                      .filter(v => !isNaN(v));
                    
                    if (numericValues.length > 0) {
                      const sum = numericValues.reduce((a, b) => a + b, 0);
                      const avg = sum / numericValues.length;
                      const sorted = [...numericValues].sort((a, b) => a - b);
                      const min = sorted[0];
                      const max = sorted[sorted.length - 1];
                      const median = sorted[Math.floor(sorted.length / 2)];
                      const variance = numericValues.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / numericValues.length;
                      const stdDev = Math.sqrt(variance);
                      
                      // Detect zeros and negatives
                      const zeroCount = numericValues.filter(v => v === 0).length;
                      const negativeCount = numericValues.filter(v => v < 0).length;
                      
                      fieldProfile = {
                        ...fieldProfile,
                        validCount: numericValues.length,
                        min: min,
                        max: max,
                        sum: sum,
                        avg: avg,
                        median: median,
                        stdDev: stdDev,
                        zeroCount: zeroCount,
                        negativeCount: negativeCount
                      };
                    }
                  } else {
                    // Categorical/String field statistics
                    const validValues = formattedValues.filter(v => v !== null && v !== undefined && v !== '' && v !== '%null%');
                    const uniqueValues = new Set(validValues);
                    const cardinality = uniqueValues.size;
                    
                    // Top values by frequency
                    const valueCounts = {};
                    for (const val of validValues) {
                      valueCounts[val] = (valueCounts[val] || 0) + 1;
                    }
                    const topValues = Object.entries(valueCounts)
                      .sort((a, b) => b[1] - a[1])
                      .slice(0, 5)
                      .map(([val, count]) => ({ value: val, count: count, percent: ((count / validValues.length) * 100).toFixed(1) + '%' }));
                    
                    fieldProfile = {
                      ...fieldProfile,
                      validCount: validValues.length,
                      cardinality: cardinality,
                      topValues: topValues
                    };
                    
                    // Date-specific info
                    if (isDate && validValues.length > 0) {
                      const sortedDates = validValues.sort();
                      fieldProfile.minDate = sortedDates[0];
                      fieldProfile.maxDate = sortedDates[sortedDates.length - 1];
                    }
                  }
                  
                  fieldProfiles.push(fieldProfile);
                  
                  // Merge into allFields map
                  if (!allFields.has(fieldName)) {
                    allFields.set(fieldName, fieldProfile);
                  }
                }
                
                // Interpret viz purpose
                const vizInterpretation = interpretVizPurpose(ws.name, fieldProfiles, data.length);
                
                worksheetProfiles.push({
                  worksheet: ws.name,
                  rowCount: data.length,
                  fieldCount: columns.length,
                  fields: fieldProfiles,
                  interpretation: vizInterpretation
                });
                
              } catch (e) {
                worksheetProfiles.push({
                  worksheet: ws.name,
                  error: e.message
                });
              }
            }
            
            // Build report based on analysis goal
            let report = '';
            const successfulProfiles = worksheetProfiles.filter(p => !p.error);
            const totalRows = successfulProfiles.reduce((sum, p) => sum + p.rowCount, 0);
            const measures = [...allFields.values()].filter(f => f.role === 'Measure');
            const dimensions = [...allFields.values()].filter(f => f.role === 'Dimension');
            
            // Helper to format numbers
            const fmt = (n, decimals = 2) => typeof n === 'number' ? n.toLocaleString(undefined, {maximumFractionDigits: decimals}) : n;
            
            // ============================================================
            // CONCENTRATION ANALYSIS (Pareto / 80-20)
            // ============================================================
            if (analysisGoal === 'concentration-analysis') {
              report = `# Concentration Analysis Report\n\n`;
              report += `**Analysis Type:** Pareto / 80-20 Pattern Detection\n`;
              report += `**Generated:** ${new Date().toLocaleString()}\n`;
              report += `**Dashboard:** ${dashboard.name || 'Current Dashboard'}\n\n`;
              
              report += `## Key Question\n\n`;
              report += `> *Do a small number of items drive the majority of results?*\n\n`;
              
              // Perform concentration analysis for each worksheet with dimension + measure
              let concentrationResults = [];
              
              for (const profile of successfulProfiles) {
                const dims = profile.fields.filter(f => f.role === 'Dimension' && f.topValues);
                const meas = profile.fields.filter(f => f.role === 'Measure' && f.sum !== undefined);
                
                if (dims.length > 0 && meas.length > 0) {
                  // Use first suitable dimension and measure
                  const dim = dims[0];
                  const measure = meas[0];
                  
                  // Build concentration from topValues
                  if (dim.topValues && dim.topValues.length > 0) {
                    const total = measure.sum;
                    const cardinality = dim.cardinality || dim.topValues.length;
                    
                    // Calculate cumulative contribution
                    let cumulativePercent = 0;
                    const topContributors = [];
                    
                    // We need to re-aggregate from raw data for proper Pareto
                    // For now, use the dimension's value distribution as proxy
                    const sortedValues = [...(dim.topValues || [])].sort((a, b) => b.count - a.count);
                    const totalCount = dim.validCount || profile.rowCount;
                    
                    let runningSum = 0;
                    for (const tv of sortedValues) {
                      runningSum += tv.count;
                      const cumPct = (runningSum / totalCount * 100).toFixed(1);
                      topContributors.push({
                        value: tv.value,
                        count: tv.count,
                        percent: tv.percent,
                        cumulative: cumPct + '%'
                      });
                    }
                    
                    // Calculate top 20% contribution
                    const top20Count = Math.ceil(cardinality * 0.2);
                    const top20Sum = sortedValues.slice(0, top20Count).reduce((s, v) => s + v.count, 0);
                    const top20Pct = (top20Sum / totalCount * 100).toFixed(1);
                    
                    concentrationResults.push({
                      worksheet: profile.worksheet,
                      dimension: dim.name,
                      measure: measure.name,
                      cardinality: cardinality,
                      top20Contribution: top20Pct,
                      isConcentrated: parseFloat(top20Pct) > 60,
                      topContributors: topContributors
                    });
                  }
                }
              }
              
              // Summary findings
              report += `## Concentration Summary\n\n`;
              
              if (concentrationResults.length === 0) {
                report += `Could not perform concentration analysis. Need at least one dimension and one measure.\n\n`;
              } else {
                const concentrated = concentrationResults.filter(r => r.isConcentrated);
                const balanced = concentrationResults.filter(r => !r.isConcentrated);
                
                if (concentrated.length > 0) {
                  report += `### High Concentration Detected (${concentrated.length} areas)\n\n`;
                  report += `These show **Pareto patterns** where top 20% drives >60% of activity:\n\n`;
                  
                  for (const r of concentrated) {
                    report += `#### ${r.worksheet}\n\n`;
                    report += `- **Dimension:** ${r.dimension}\n`;
                    report += `- **Categories:** ${r.cardinality}\n`;
                    report += `- **Top 20% Contribution:** ${r.top20Contribution}%\n\n`;
                    
                    report += `| Rank | ${r.dimension} | Count | % of Total | Cumulative |\n`;
                    report += `|------|---------------|-------|------------|------------|\n`;
                    r.topContributors.slice(0, 10).forEach((tc, i) => {
                      report += `| ${i + 1} | ${tc.value} | ${tc.count} | ${tc.percent} | ${tc.cumulative} |\n`;
                    });
                    report += `\n`;
                  }
                }
                
                if (balanced.length > 0) {
                  report += `### Balanced Distribution (${balanced.length} areas)\n\n`;
                  for (const r of balanced) {
                    report += `- **${r.worksheet}**: ${r.dimension} (${r.cardinality} categories) - Top 20% = ${r.top20Contribution}%\n`;
                  }
                  report += `\n`;
                }
              }
              
              // Insights
              report += `## Insights & Actions\n\n`;
              const concentrated = concentrationResults.filter(r => r.isConcentrated);
              if (concentrated.length > 0) {
                report += `**Pareto Pattern Detected:**\n`;
                report += `- A small number of categories drive most results\n`;
                report += `- Consider: What happens if top performers decline?\n`;
                report += `- Action: Create focused views for top contributors\n`;
                report += `- Action: Investigate long-tail opportunities\n\n`;
              } else {
                report += `**Even Distribution:**\n`;
                report += `- Results are spread across many categories\n`;
                report += `- No single category dominates\n`;
                report += `- May indicate healthy diversification\n\n`;
              }
              
            // ============================================================
            // SEGMENT DEEP-DIVE
            // ============================================================
            } else if (analysisGoal === 'segment-deep-dive') {
              // Check if user specified focus measures/dimensions
              const hasFocusMeasures = focusMeasures && focusMeasures.length > 0;
              const hasFocusDimensions = focusDimensions && focusDimensions.length > 0;
              
              report = `# Segment Performance Analysis\n\n`;
              report += `**Analysis Type:** Category Comparison by Metrics\n`;
              report += `**Generated:** ${new Date().toLocaleString()}\n`;
              report += `**Dashboard:** ${dashboard.name || 'Current Dashboard'}\n`;
              if (hasFocusMeasures) {
                report += `**Focus Measures:** ${focusMeasures.join(', ')}\n`;
              }
              if (hasFocusDimensions) {
                report += `**Focus Dimensions:** ${focusDimensions.join(', ')}\n`;
              }
              report += `\n`;
              
              if (hasFocusMeasures && hasFocusDimensions) {
                report += `## Key Question\n\n`;
                report += `> *Which **${focusDimensions.join(', ')}** has the highest **${focusMeasures.join(', ')}**?*\n\n`;
              } else {
                report += `## Key Question\n\n`;
                report += `> *How do different segments compare in actual performance metrics?*\n\n`;
              }
              
              // We need to re-analyze with proper measure aggregation
              // Go back to worksheet data and aggregate measures by dimensions
              report += `## Segment Performance\n\n`;
              
              let segmentAnalyses = [];
              
              // Helper to check if a field matches a focus list (case-insensitive, partial match)
              function matchesFocus(fieldName, focusList) {
                if (!focusList || focusList.length === 0) return true; // No filter = match all
                const cleanName = cleanFieldName(fieldName).toLowerCase();
                return focusList.some(focus => 
                  cleanName.includes(focus.toLowerCase()) || 
                  focus.toLowerCase().includes(cleanName)
                );
              }
              
              for (const ws of dashboard.worksheets) {
                try {
                  const dataTable = await ws.getSummaryDataAsync();
                  const columns = dataTable.columns;
                  const data = dataTable.data;
                  
                  // Find dimension and measure columns
                  const dimCols = [];
                  const measCols = [];
                  
                  for (let i = 0; i < columns.length; i++) {
                    const col = columns[i];
                    const isNumeric = col.dataType === 'float' || col.dataType === 'int';
                    const isCalc = col.fieldName.includes('AGG(') || col.fieldName.includes('SUM(') || 
                                   col.fieldName.includes('COUNT(') || col.fieldName.includes('AVG(');
                    
                    // Skip internal fields like "Measure Names" and "Measure Values"
                    if (col.fieldName === 'Measure Names' || col.fieldName === 'Measure Values') {
                      continue;
                    }
                    
                    if (isNumeric || isCalc) {
                      // Only include meaningful measures (skip IDs, keys, etc.)
                      if (isMeaningfulMeasure(col.fieldName) && matchesFocus(col.fieldName, focusMeasures)) {
                        measCols.push({ index: i, name: col.fieldName, type: col.dataType });
                      }
                    } else if (col.dataType === 'string') {
                      // Skip high cardinality dimensions (like individual IDs)
                      const uniqueVals = new Set(data.map(row => row[i]?.formattedValue));
                      if (uniqueVals.size >= 2 && uniqueVals.size <= 50 && matchesFocus(col.fieldName, focusDimensions)) {
                        dimCols.push({ index: i, name: col.fieldName, cardinality: uniqueVals.size });
                      }
                    }
                  }
                  
                  if (dimCols.length === 0 || measCols.length === 0) continue;
                  
                  // For each suitable dimension, aggregate meaningful measures
                  // If user specified focus, only analyze those; otherwise limit to 2 each
                  const dimsToAnalyze = hasFocusDimensions ? dimCols : dimCols.slice(0, 2);
                  const measToAnalyze = hasFocusMeasures ? measCols : measCols.slice(0, 2);
                  
                  for (const dimCol of dimsToAnalyze) {
                    for (const measCol of measToAnalyze) {
                      // Determine if this is a rate metric (should use AVG) or volume (should use SUM)
                      const measName = measCol.name.toLowerCase();
                      const isRateMetric = measName.includes('rate') || measName.includes('percent') || 
                                           measName.includes('%') || measName.includes('ratio') || 
                                           measName.includes('pct') || measName.includes('avg(');
                      
                      // Aggregate: sum or avg measure by dimension
                      const aggregated = {};
                      let grandTotal = 0;
                      let grandCount = 0;
                      
                      for (const row of data) {
                        const dimValue = row[dimCol.index]?.formattedValue || 'Unknown';
                        const measValue = parseFloat(row[measCol.index]?.value) || 0;
                        
                        if (!aggregated[dimValue]) {
                          aggregated[dimValue] = { sum: 0, count: 0, min: Infinity, max: -Infinity };
                        }
                        aggregated[dimValue].sum += measValue;
                        aggregated[dimValue].count += 1;
                        aggregated[dimValue].min = Math.min(aggregated[dimValue].min, measValue);
                        aggregated[dimValue].max = Math.max(aggregated[dimValue].max, measValue);
                        grandTotal += measValue;
                        grandCount += 1;
                      }
                      
                      // Sort by avg for rate metrics, by sum for volume metrics
                      const sorted = Object.entries(aggregated)
                        .map(([name, stats]) => ({
                          name,
                          sum: stats.sum,
                          count: stats.count,
                          avg: stats.sum / stats.count,
                          value: isRateMetric ? (stats.sum / stats.count) : stats.sum,
                          percent: grandTotal > 0 ? (stats.sum / grandTotal * 100) : 0
                        }))
                        .sort((a, b) => b.value - a.value);
                      
                      if (sorted.length >= 2) {
                        segmentAnalyses.push({
                          worksheet: ws.name,
                          dimension: dimCol.name,
                          measure: cleanFieldName(measCol.name),
                          isRateMetric,
                          grandTotal,
                          grandAvg: grandCount > 0 ? grandTotal / grandCount : 0,
                          segments: sorted
                        });
                      }
                    }
                  }
                } catch (e) {
                  // Skip worksheets with errors
                }
              }
              
              if (segmentAnalyses.length === 0) {
                report += `Could not find suitable dimension-measure pairs for segment analysis.\n\n`;
                if (hasFocusMeasures || hasFocusDimensions) {
                  report += `**Note:** Could not find fields matching:\n`;
                  if (hasFocusMeasures) report += `- Measures: ${focusMeasures.join(', ')}\n`;
                  if (hasFocusDimensions) report += `- Dimensions: ${focusDimensions.join(', ')}\n`;
                  report += `\nPlease check the exact field names in the dashboard.\n\n`;
                }
                report += `Segment analysis works best when:\n`;
                report += `- There are categorical dimensions (like Region, Product, Campaign)\n`;
                report += `- There are numeric measures to aggregate (like Sales, Count, Revenue)\n`;
                report += `- Dimensions have between 2-50 unique values\n\n`;
              } else {
                for (const analysis of segmentAnalyses) {
                  report += `### ${analysis.measure} by ${analysis.dimension}\n\n`;
                  report += `*Source: ${analysis.worksheet}*\n\n`;
                  
                  // Different formatting for rate metrics vs volume metrics
                  if (analysis.isRateMetric) {
                    report += `| Rank | ${analysis.dimension} | Avg ${analysis.measure} | Records | Visual |\n`;
                    report += `|------|-------------|----------|---------|--------|\n`;
                    
                    // Top segments sorted by average
                    for (let i = 0; i < Math.min(analysis.segments.length, 10); i++) {
                      const seg = analysis.segments[i];
                      const avgPct = (seg.avg * 100).toFixed(1) + '%';
                      const barLen = Math.max(1, Math.round(seg.avg * 100 / 5));
                      const bar = '█'.repeat(Math.min(barLen, 20));
                      report += `| ${i + 1} | ${seg.name} | ${avgPct} | ${seg.count} | ${bar} |\n`;
                    }
                    report += `\n`;
                    
                    // Top performer callout
                    if (analysis.segments.length > 0) {
                      const top = analysis.segments[0];
                      const topAvgPct = (top.avg * 100).toFixed(1);
                      report += `**Winner: "${top.name}"** with ${topAvgPct}% average ${analysis.measure}\n\n`;
                      
                      // Compare to overall average
                      const overallAvgPct = (analysis.grandAvg * 100).toFixed(1);
                      const diff = ((top.avg - analysis.grandAvg) * 100).toFixed(1);
                      report += `*Overall average: ${overallAvgPct}% · Top performer is ${diff > 0 ? '+' : ''}${diff}pp above average*\n\n`;
                    }
                  } else {
                    report += `| ${analysis.dimension} | ${analysis.measure} | % of Total | Visual |\n`;
                    report += `|-------------|----------|------------|--------|\n`;
                    
                    // Top 10 segments
                    for (const seg of analysis.segments.slice(0, 10)) {
                      const bar = '█'.repeat(Math.max(1, Math.round(seg.percent / 5)));
                      report += `| ${seg.name} | ${fmt(seg.sum)} | ${seg.percent.toFixed(1)}% | ${bar} |\n`;
                    }
                    
                    if (analysis.segments.length > 10) {
                      const remaining = analysis.segments.slice(10);
                      const remainingSum = remaining.reduce((s, seg) => s + seg.sum, 0);
                      const remainingPct = (remainingSum / analysis.grandTotal * 100).toFixed(1);
                      report += `| *(${remaining.length} others)* | ${fmt(remainingSum)} | ${remainingPct}% | |\n`;
                    }
                    report += `\n`;
                    report += `*Total: ${fmt(analysis.grandTotal)}*\n\n`;
                  }
                  
                  // Quick insight for concentration
                  if (!analysis.isRateMetric) {
                    const top3Pct = analysis.segments.slice(0, 3).reduce((s, seg) => s + seg.percent, 0);
                    if (top3Pct > 50) {
                      report += `**Insight:** Top 3 segments account for ${top3Pct.toFixed(0)}% of total ${analysis.measure}\n\n`;
                    }
                  }
                }
              }
              
              // Key observations
              report += `## Key Findings\n\n`;
              
              // Separate rate and volume analyses for better insights
              const rateAnalyses = segmentAnalyses.filter(a => a.isRateMetric && a.segments.length > 0);
              const volumeAnalyses = segmentAnalyses.filter(a => !a.isRateMetric && a.segments.length > 0);
              
              if (rateAnalyses.length > 0) {
                for (const a of rateAnalyses.slice(0, 3)) {
                  const top = a.segments[0];
                  const topAvgPct = (top.avg * 100).toFixed(1);
                  report += `- **${a.dimension}**: "${top.name}" has the highest ${a.measure} at ${topAvgPct}%\n`;
                }
              }
              
              if (volumeAnalyses.length > 0) {
                const dominantSegments = volumeAnalyses
                  .filter(a => a.segments[0].percent > 25)
                  .map(a => `**${a.dimension}**: "${a.segments[0].name}" leads with ${a.segments[0].percent.toFixed(0)}% of ${a.measure}`);
                
                for (const obs of dominantSegments.slice(0, 3)) {
                  report += `- ${obs}\n`;
                }
              }
              
              if (rateAnalyses.length === 0 && volumeAnalyses.length === 0) {
                report += `- Distribution appears relatively balanced across segments\n`;
              }
              report += `\n`;
              
              report += `## Recommended Next Steps\n\n`;
              report += `1. **Deep dive** into top-performing segments to understand success factors\n`;
              report += `2. **Investigate** underperforming segments for improvement opportunities\n`;
              report += `3. **Compare** segment performance over time with \`trend-analysis\`\n\n`;
              
            // ============================================================
            // TREND ANALYSIS
            // ============================================================
            } else if (analysisGoal === 'trend-analysis') {
              report = `# Trend Analysis Report\n\n`;
              report += `**Analysis Type:** Time-Based Pattern Detection\n`;
              report += `**Generated:** ${new Date().toLocaleString()}\n`;
              report += `**Dashboard:** ${dashboard.name || 'Current Dashboard'}\n\n`;
              
              report += `## Key Question\n\n`;
              report += `> *How do metrics change over time?*\n\n`;
              
              // Re-analyze worksheets looking for time-series data
              let trendAnalyses = [];
              
              for (const ws of dashboard.worksheets) {
                try {
                  const dataTable = await ws.getSummaryDataAsync();
                  const columns = dataTable.columns;
                  const data = dataTable.data;
                  
                  // Find date columns and measure columns
                  let dateColIndex = -1;
                  let dateColName = '';
                  const measCols = [];
                  
                  for (let i = 0; i < columns.length; i++) {
                    const col = columns[i];
                    if (col.dataType === 'date' || col.dataType === 'date-time') {
                      dateColIndex = i;
                      dateColName = col.fieldName;
                    } else if ((col.dataType === 'float' || col.dataType === 'int') && 
                               isMeaningfulMeasure(col.fieldName)) {
                      measCols.push({ index: i, name: col.fieldName });
                    }
                  }
                  
                  if (dateColIndex === -1 || measCols.length === 0) continue;
                  
                  // Aggregate measures by date
                  for (const measCol of measCols.slice(0, 2)) {
                    const byDate = {};
                    
                    for (const row of data) {
                      const dateVal = row[dateColIndex]?.formattedValue || 'Unknown';
                      const measVal = parseFloat(row[measCol.index]?.value) || 0;
                      
                      if (!byDate[dateVal]) {
                        byDate[dateVal] = { sum: 0, count: 0 };
                      }
                      byDate[dateVal].sum += measVal;
                      byDate[dateVal].count += 1;
                    }
                    
                    // Sort by date
                    const sortedDates = Object.entries(byDate)
                      .map(([date, stats]) => ({ date, value: stats.sum, count: stats.count }))
                      .sort((a, b) => new Date(a.date) - new Date(b.date));
                    
                    if (sortedDates.length >= 3) {
                      // Calculate trend metrics
                      const values = sortedDates.map(d => d.value);
                      const first = values[0];
                      const last = values[values.length - 1];
                      const avg = values.reduce((a, b) => a + b, 0) / values.length;
                      const max = Math.max(...values);
                      const min = Math.min(...values);
                      const maxDate = sortedDates.find(d => d.value === max)?.date;
                      const minDate = sortedDates.find(d => d.value === min)?.date;
                      
                      // Calculate change
                      const absoluteChange = last - first;
                      const percentChange = first !== 0 ? ((last - first) / first * 100) : 0;
                      
                      // Detect trend direction
                      let trend = 'stable';
                      if (percentChange > 10) trend = 'increasing';
                      else if (percentChange < -10) trend = 'decreasing';
                      
                      // Detect volatility
                      const variance = values.reduce((acc, v) => acc + Math.pow(v - avg, 2), 0) / values.length;
                      const stdDev = Math.sqrt(variance);
                      const cv = avg !== 0 ? (stdDev / avg * 100) : 0;
                      const isVolatile = cv > 50;
                      
                      trendAnalyses.push({
                        worksheet: ws.name,
                        dateField: dateColName,
                        measure: measCol.name.replace(/AGG\(|\)/g, ''),
                        periods: sortedDates.length,
                        dateRange: { start: sortedDates[0].date, end: sortedDates[sortedDates.length - 1].date },
                        trend,
                        first: { date: sortedDates[0].date, value: first },
                        last: { date: sortedDates[sortedDates.length - 1].date, value: last },
                        peak: { date: maxDate, value: max },
                        trough: { date: minDate, value: min },
                        average: avg,
                        absoluteChange,
                        percentChange,
                        isVolatile,
                        volatility: cv,
                        timeSeries: sortedDates.slice(0, 15) // First 15 for display
                      });
                    }
                  }
                } catch (e) {
                  // Skip worksheets with errors
                }
              }
              
              if (trendAnalyses.length === 0) {
                report += `**No time-series data found in this dashboard.**\n\n`;
                report += `Trend analysis requires:\n`;
                report += `- A date or date-time field\n`;
                report += `- Numeric measures to track over time\n`;
                report += `- At least 3 data points over time\n\n`;
              } else {
                for (const trend of trendAnalyses) {
                  report += `## ${trend.worksheet}\n\n`;
                  report += `### ${trend.measure} over ${trend.dateField}\n\n`;
                  
                  // Trend indicator
                  const trendLabel = trend.trend.charAt(0).toUpperCase() + trend.trend.slice(1);
                  const changeSign = trend.percentChange >= 0 ? '+' : '';
                  
                  report += `**Overall Trend:** ${trendLabel} (${changeSign}${trend.percentChange.toFixed(1)}%)\n\n`;
                  
                  // Key metrics table
                  report += `| Metric | Value |\n`;
                  report += `|--------|-------|\n`;
                  report += `| Date Range | ${trend.dateRange.start} → ${trend.dateRange.end} |\n`;
                  report += `| Periods | ${trend.periods} |\n`;
                  report += `| Starting Value | ${fmt(trend.first.value)} |\n`;
                  report += `| Ending Value | ${fmt(trend.last.value)} |\n`;
                  report += `| Change | ${changeSign}${fmt(trend.absoluteChange)} (${changeSign}${trend.percentChange.toFixed(1)}%) |\n`;
                  report += `| Peak | ${fmt(trend.peak.value)} on ${trend.peak.date} |\n`;
                  report += `| Trough | ${fmt(trend.trough.value)} on ${trend.trough.date} |\n`;
                  report += `| Average | ${fmt(trend.average)} |\n`;
                  report += `| Volatility | ${trend.isVolatile ? 'High' : 'Normal'} (${trend.volatility.toFixed(1)}% CV) |\n\n`;
                  
                  // Time series sparkline table
                  report += `**Timeline:**\n\n`;
                  report += `| Period | ${trend.measure} | Visual |\n`;
                  report += `|--------|----------|--------|\n`;
                  
                  const maxVal = Math.max(...trend.timeSeries.map(t => t.value));
                  for (const point of trend.timeSeries) {
                    const barLen = maxVal > 0 ? Math.round((point.value / maxVal) * 10) : 0;
                    const bar = '█'.repeat(barLen) || '▏';
                    report += `| ${point.date} | ${fmt(point.value)} | ${bar} |\n`;
                  }
                  
                  if (trend.periods > 15) {
                    report += `| *(${trend.periods - 15} more periods...)* | | |\n`;
                  }
                  report += `\n`;
                  
                  // Insights
                  if (trend.isVolatile) {
                    report += `**Insight:** High volatility detected - ${trend.measure} varies significantly across periods\n\n`;
                  }
                  if (trend.trend !== 'stable') {
                    report += `**Insight:** ${trend.measure} is ${trend.trend} - from ${fmt(trend.first.value)} to ${fmt(trend.last.value)}\n\n`;
                  }
                }
                
                // PEAK ANALYSIS - What campaigns/programs were driving peaks?
                report += `## Peak Analysis: What's Driving the Spikes?\n\n`;
                
                // Find worksheets with dimension breakdowns (not time-based)
                const peakContributors = [];
                for (const ws of dashboard.worksheets) {
                  try {
                    const dataTable = await ws.getSummaryDataAsync();
                    const columns = dataTable.columns;
                    const data = dataTable.data;
                    
                    // Look for dimension columns (Name, Program Name, etc.) that aren't dates
                    const dimCols = [];
                    const measCols = [];
                    
                    for (let i = 0; i < columns.length; i++) {
                      const col = columns[i];
                      const name = col.fieldName.toLowerCase();
                      // Skip meta-fields
                      if (name.includes('measure names') || name.includes('measure values')) continue;
                      
                      if (col.dataType === 'string' && !name.includes('date') && !name.includes('time')) {
                        // Good dimension candidates: Name, Program Name, Campaign, etc.
                        if (name === 'name' || name.includes('program') || name.includes('campaign') || 
                            name.includes('category') || name.includes('type') || name.includes('source')) {
                          dimCols.push({ index: i, name: col.fieldName });
                        }
                      } else if ((col.dataType === 'float' || col.dataType === 'int') && isMeaningfulMeasure(col.fieldName)) {
                        measCols.push({ index: i, name: col.fieldName });
                      }
                    }
                    
                    if (dimCols.length > 0 && measCols.length > 0) {
                      // Aggregate by dimension
                      const primaryDim = dimCols[0];
                      const primaryMeas = measCols[0];
                      
                      const byDim = {};
                      for (const row of data) {
                        const dimVal = row[primaryDim.index]?.formattedValue || 'Unknown';
                        const measVal = parseFloat(row[primaryMeas.index]?.value) || 0;
                        
                        if (!byDim[dimVal]) byDim[dimVal] = 0;
                        byDim[dimVal] += measVal;
                      }
                      
                      // Sort by value descending
                      const sorted = Object.entries(byDim)
                        .map(([name, value]) => ({ name, value }))
                        .sort((a, b) => b.value - a.value);
                      
                      const total = sorted.reduce((sum, item) => sum + item.value, 0);
                      
                      peakContributors.push({
                        worksheet: ws.name,
                        dimension: primaryDim.name,
                        measure: primaryMeas.name.replace(/AGG\(|\)/g, ''),
                        topContributors: sorted.slice(0, 5).map(item => ({
                          name: item.name,
                          value: item.value,
                          percent: total > 0 ? ((item.value / total) * 100).toFixed(1) : 0
                        })),
                        total
                      });
                    }
                  } catch (e) {
                    // Skip worksheet errors
                  }
                }
                
                if (peakContributors.length > 0) {
                  for (const contrib of peakContributors) {
                    report += `### Top ${contrib.dimension}s by ${contrib.measure}\n\n`;
                    report += `*From ${contrib.worksheet}*\n\n`;
                    report += `| ${contrib.dimension} | ${contrib.measure} | Share |\n`;
                    report += `|---|---:|---:|\n`;
                    
                    for (const c of contrib.topContributors) {
                      report += `| ${c.name} | ${fmt(c.value)} | ${c.percent}% |\n`;
                    }
                    report += `\n`;
                    
                    // Add insight about concentration
                    const topShare = parseFloat(contrib.topContributors[0]?.percent || 0);
                    if (topShare > 30) {
                      report += `> **${contrib.topContributors[0].name}** drives **${topShare}%** of ${contrib.measure} - this is likely your main contributor to spikes.\n\n`;
                    }
                  }
                } else {
                  report += `No campaign/program breakdown available in this dashboard to analyze peak contributors.\n\n`;
                }
                
                report += `## Analysis Summary\n\n`;
                
                const increasing = trendAnalyses.filter(t => t.trend === 'increasing');
                const decreasing = trendAnalyses.filter(t => t.trend === 'decreasing');
                const volatile = trendAnalyses.filter(t => t.isVolatile);
                
                if (increasing.length > 0) {
                  report += `**Growing:** ${increasing.map(t => t.measure).join(', ')}\n`;
                }
                if (decreasing.length > 0) {
                  report += `**Declining:** ${decreasing.map(t => t.measure).join(', ')}\n`;
                }
                if (volatile.length > 0) {
                  report += `**Volatile:** ${volatile.map(t => t.measure).join(', ')}\n`;
                }
                report += `\n`;
              }
              
            // ============================================================
            // ANOMALY SCAN
            // ============================================================
            } else if (analysisGoal === 'anomaly-scan') {
              report = `# Anomaly Detection Report\n\n`;
              report += `**Analysis Type:** Outlier & Anomaly Scan\n`;
              report += `**Generated:** ${new Date().toLocaleString()}\n`;
              report += `**Dashboard:** ${dashboard.name || 'Current Dashboard'}\n\n`;
              
              report += `## Key Question\n\n`;
              report += `> *Are there unusual patterns or outliers in the data?*\n\n`;
              
              // Check for anomalies in measures
              report += `## Statistical Anomalies\n\n`;
              
              let anomaliesFound = false;
              
              for (const m of measures) {
                const anomalies = [];
                
                // Check for high variance
                if (m.stdDev && m.avg && m.avg !== 0) {
                  const cv = (m.stdDev / Math.abs(m.avg)) * 100; // Coefficient of variation
                  if (cv > 100) {
                    anomalies.push(`High variance (CV: ${cv.toFixed(1)}%)`);
                  }
                }
                
                // Check for extreme range
                if (m.min !== undefined && m.max !== undefined && m.avg) {
                  const range = m.max - m.min;
                  if (range > m.avg * 10) {
                    anomalies.push(`Extreme range (${fmt(m.min)} to ${fmt(m.max)})`);
                  }
                }
                
                // Check for zeros in unexpected places
                if (m.zeroCount > 0 && m.validCount) {
                  const zeroPct = (m.zeroCount / m.validCount) * 100;
                  if (zeroPct > 20 && zeroPct < 80) {
                    anomalies.push(`${zeroPct.toFixed(1)}% zero values`);
                  }
                }
                
                // Check for negatives
                if (m.negativeCount > 0) {
                  anomalies.push(`Contains ${m.negativeCount} negative values`);
                }
                
                if (anomalies.length > 0) {
                  anomaliesFound = true;
                  report += `### ${m.name}\n\n`;
                  for (const a of anomalies) {
                    report += `- ${a}\n`;
                  }
                  report += `\n`;
                }
              }
              
              // Data quality anomalies
              const highNullFields = [...allFields.values()].filter(f => parseFloat(f.nullPercent) > 20);
              if (highNullFields.length > 0) {
                anomaliesFound = true;
                report += `### Missing Data\n\n`;
                for (const f of highNullFields) {
                  report += `- **${f.name}**: ${f.nullPercent} null values\n`;
                }
                report += `\n`;
              }
              
              if (!anomaliesFound) {
                report += `**No major anomalies detected**\n\n`;
                report += `The data appears consistent with expected patterns.\n\n`;
              }
              
              report += `## Anomaly Investigation Tips\n\n`;
              report += `1. Drill down into flagged measures to understand root cause\n`;
              report += `2. Compare anomalous periods to normal baselines\n`;
              report += `3. Check data collection process for quality issues\n\n`;
              
            // ============================================================
            // QUICK PROFILE (default) - INSIGHT-DRIVEN Analysis
            // ============================================================
            } else {
              // Helper: Check if field is Tableau's meta-field (not real business data)
              const isMetaField = (name) => {
                const lower = name.toLowerCase();
                return lower === 'measure names' || lower === 'measure values' || 
                       lower.includes('measure names') || lower.includes('measure values') ||
                       lower === 'number of records' || lower === 'table calculation';
              };
              
              // Helper: Get business-meaningful measures (not IDs, meta-fields)
              const businessMeasures = measures.filter(m => {
                const name = m.name.toLowerCase();
                // Exclude meta-fields
                if (isMetaField(m.name)) return false;
                // Exclude ID-based measures
                if (name.includes('cntd(id)') || name.includes('cnt(id)')) return false;
                if (name === 'id' || name.endsWith('_id') || name.includes('guid') || name.includes('key')) return false;
                return true;
              });
              
              // Sort business measures: rates first, then volumes
              const sortedMeasures = [...businessMeasures].sort((a, b) => {
                const aName = a.name.toLowerCase();
                const bName = b.name.toLowerCase();
                const aIsRate = aName.includes('rate') || aName.includes('ratio') || aName.includes('percent');
                const bIsRate = bName.includes('rate') || bName.includes('ratio') || bName.includes('percent');
                if (aIsRate && !bIsRate) return -1;
                if (!aIsRate && bIsRate) return 1;
                return 0;
              });
              
              // Helper: Get business dimensions (not meta-fields, not dates)
              const businessDimensions = dimensions.filter(d => {
                if (isMetaField(d.name)) return false;
                // Skip pure date fields for dimension analysis (they're for trends)
                if (d.dataType === 'date' || d.dataType === 'date-time') return false;
                return true;
              });
              
              // Find best dimension for analysis (prefer ones with meaningful cardinality)
              const findBestDimension = () => {
                // Prefer dimensions with 3-50 unique values (good for grouping)
                const ideal = businessDimensions.find(d => d.cardinality >= 3 && d.cardinality <= 50);
                if (ideal) return ideal;
                // Fall back to any with at least 2 values
                return businessDimensions.find(d => d.cardinality >= 2 && d.topValues?.length >= 2);
              };
              
              // Helper: Find top/bottom performers from dimension data
              const findTopPerformers = (dim) => {
                if (!dim || !dim.topValues || dim.topValues.length === 0) return null;
                const sorted = [...dim.topValues].sort((a, b) => b.count - a.count);
                const total = sorted.reduce((sum, v) => sum + v.count, 0);
                return sorted.slice(0, 5).map(v => ({
                  name: v.value,
                  count: v.count,
                  percent: total > 0 ? ((v.count / total) * 100).toFixed(1) : 0
                }));
              };
              
              // Find the worksheet with the most data for the "main" analysis
              const mainWorksheet = successfulProfiles.reduce((best, p) => 
                (p.rowCount > (best?.rowCount || 0)) ? p : best, null);
              
              // Build the story from actual business metrics
              const buildStory = () => {
                // List actual metrics being tracked (excluding meta-fields)
                const actualMetrics = sortedMeasures.slice(0, 5).map(m => m.name.replace(/AGG\(|\)/g, ''));
                const actualDims = businessDimensions.slice(0, 2).map(d => d.name);
                
                if (actualMetrics.length === 0) {
                  return 'This dashboard displays data across multiple views.';
                }
                
                let story = `This dashboard tracks **${actualMetrics.join(', ')}**`;
                if (actualDims.length > 0) {
                  story += ` across **${actualDims.join(' and ')}**`;
                }
                story += '.';
                
                // Add context about what we're measuring
                const hasRates = actualMetrics.some(m => m.toLowerCase().includes('rate'));
                const hasEmails = actualMetrics.some(m => m.toLowerCase().includes('email'));
                if (hasRates && hasEmails) {
                  story += ` It focuses on email campaign performance metrics.`;
                }
                
                return story;
              };
              
              // Build key findings from REAL data
              const keyFindings = [];
              const dataQualityIssues = [];
              const highNullFields = [...allFields.values()].filter(f => 
                parseFloat(f.nullPercent) > 20 && !isMetaField(f.name)
              );
              
              // Finding 1: Top performers by REAL dimension
              const primaryDim = findBestDimension();
              if (primaryDim) {
                const topPerformers = findTopPerformers(primaryDim);
                if (topPerformers && topPerformers.length >= 2) {
                  const leader = topPerformers[0];
                  const runner = topPerformers[1];
                  keyFindings.push({
                    type: 'concentration',
                    insight: `**${leader.name}** leads in ${primaryDim.name} with ${leader.percent}% of records (${leader.count.toLocaleString()}), followed by **${runner.name}** at ${runner.percent}%`,
                    metric: primaryDim.name
                  });
                }
              }
              
              // Finding 2: Key rate metrics (most important for business)
              const rateMetrics = sortedMeasures.filter(m => {
                const name = m.name.toLowerCase();
                return name.includes('rate') || name.includes('ratio') || name.includes('percent');
              });
              for (const m of rateMetrics.slice(0, 2)) {
                const cleanName = m.name.replace(/AGG\(|\)/g, '');
                if (m.avg !== undefined) {
                  // Format as percentage if it looks like a rate
                  const avgDisplay = m.avg < 1 ? `${(m.avg * 100).toFixed(1)}%` : fmt(m.avg);
                  const maxDisplay = m.max < 1 ? `${(m.max * 100).toFixed(1)}%` : fmt(m.max);
                  keyFindings.push({
                    type: 'metric',
                    insight: `**${cleanName}** averages ${avgDisplay} (best: ${maxDisplay})`,
                    metric: cleanName
                  });
                }
              }
              
              // Finding 3: Volume metrics
              const volumeMetrics = sortedMeasures.filter(m => {
                const name = m.name.toLowerCase();
                return name.includes('sent') || name.includes('delivered') || name.includes('opened') || 
                       name.includes('clicked') || name.includes('count') || name.includes('total');
              });
              for (const m of volumeMetrics.slice(0, 2)) {
                const cleanName = m.name.replace(/AGG\(|\)/g, '');
                if (m.avg !== undefined && m.max !== undefined) {
                  keyFindings.push({
                    type: 'metric',
                    insight: `**${cleanName}** averages ${fmt(m.avg)} per record (max: ${fmt(m.max)})`,
                    metric: cleanName
                  });
                }
              }
              
              // Finding 4: Data quality issues as business impact
              for (const f of highNullFields.slice(0, 3)) {
                const cleanName = f.name.replace(/AGG\(|\)/g, '');
                dataQualityIssues.push({
                  field: cleanName,
                  nullPercent: f.nullPercent,
                  insight: `**${cleanName}** has ${f.nullPercent} missing data - incomplete visibility`
                });
              }
              
              // Start the report - LEAD WITH INSIGHTS
              report = `# Email Campaign Performance Analysis\n\n`;
              report += `**Dashboard:** ${dashboard.name || 'Email Performance Dashboard'}\n`;
              report += `**Data Points:** ${totalRows.toLocaleString()} across ${successfulProfiles.length} views\n\n`;
              
              // THE STORY - What's the headline?
              report += `## What This Dashboard Shows\n\n`;
              report += buildStory() + `\n\n`;
              
              // KEY FINDINGS - The meat
              if (keyFindings.length > 0) {
                report += `## Key Findings\n\n`;
                for (const finding of keyFindings) {
                  report += `- ${finding.insight}\n`;
                }
                report += `\n`;
              }
              
              // TOP PERFORMERS - Who's winning? (only if we have real dimension)
              if (primaryDim) {
                const topPerformers = findTopPerformers(primaryDim);
                if (topPerformers && topPerformers.length >= 3) {
                  report += `## Top ${primaryDim.name}s by Volume\n\n`;
                  report += `| ${primaryDim.name} | Records | Share |\n`;
                  report += `|---|---:|---:|\n`;
                  for (const p of topPerformers) {
                    report += `| ${p.name} | ${p.count.toLocaleString()} | ${p.percent}% |\n`;
                  }
                  report += `\n`;
                  
                  // Concentration insight
                  const top3Share = topPerformers.slice(0, 3).reduce((sum, p) => sum + parseFloat(p.percent), 0);
                  if (top3Share > 50) {
                    report += `> **Concentration:** Top 3 account for **${top3Share.toFixed(0)}%** of all activity.\n\n`;
                  }
                }
              }
              
              // METRIC SNAPSHOT - Key numbers (only business metrics)
              if (sortedMeasures.length > 0) {
                report += `## Metrics Overview\n\n`;
                report += `| Metric | Average | Best | Worst |\n`;
                report += `|---|---:|---:|---:|\n`;
                for (const m of sortedMeasures.slice(0, 8)) {
                  const cleanName = m.name.replace(/AGG\(|\)/g, '');
                  const isRate = cleanName.toLowerCase().includes('rate');
                  const avgStr = isRate && m.avg < 1 ? `${(m.avg * 100).toFixed(1)}%` : fmt(m.avg);
                  const maxStr = isRate && m.max < 1 ? `${(m.max * 100).toFixed(1)}%` : fmt(m.max);
                  const minStr = isRate && m.min < 1 ? `${(m.min * 100).toFixed(1)}%` : fmt(m.min);
                  report += `| ${cleanName} | ${avgStr} | ${maxStr} | ${minStr} |\n`;
                }
                report += `\n`;
              }
              
              // DATA QUALITY - What's broken?
              if (dataQualityIssues.length > 0) {
                report += `## Data Quality Alerts\n\n`;
                for (const issue of dataQualityIssues) {
                  report += `- ${issue.insight}\n`;
                }
                report += `\n`;
              }
              
              // WHAT EACH VIEW SHOWS - Brief
              report += `## Dashboard Components\n\n`;
              for (const profile of successfulProfiles) {
                if (profile.interpretation) {
                  const interp = profile.interpretation;
                  // Filter out meta-field descriptions
                  let purpose = interp.purpose.split('.')[0];
                  purpose = purpose.replace(/Measure Values|Measure Names/gi, 'metrics');
                  report += `- **${profile.worksheet}:** ${purpose}.\n`;
                }
              }
              report += `\n`;
              
              // QUESTIONS TO EXPLORE - Actionable next steps
              report += `## Dig Deeper\n\n`;
              report += `Based on this data, consider exploring:\n\n`;
              
              if (primaryDim) {
                report += `- "Which **${primaryDim.name}** has the highest Open Rate?"\n`;
                report += `- "Show me campaign performance by **${primaryDim.name}**"\n`;
              }
              if (rateMetrics.length > 0) {
                const topRate = rateMetrics[0].name.replace(/AGG\(|\)/g, '');
                report += `- "Which campaigns have the best **${topRate}**?"\n`;
              }
              if (dataQualityIssues.length > 0) {
                report += `- "Why is **${dataQualityIssues[0].field}** data missing for some campaigns?"\n`;
              }
              report += `- "Show me trends over time"\n`;
              report += `- "Do concentration analysis - which campaigns drive the most volume?"\n\n`;
            }
            
            // ============================================================
            // POPULATE CACHE from analyze_dashboard_smart extraction
            // ============================================================
            try {
              if (storyCache.isStale || storyCache.extractedData.worksheetSummaries.length === 0) {
                console.log('[analyze_dashboard_smart] Populating cache for future use');
                
                const cacheData = storyCache.extractedData;
                cacheData.worksheetSummaries = worksheetProfiles.filter(p => !p.error).map(p => ({
                  name: p.worksheet,
                  rowCount: p.rowCount,
                  dimensions: p.fields.filter(f => f.role === 'Dimension').map(f => f.name),
                  measures: p.fields.filter(f => f.role === 'Measure').map(f => f.name)
                }));
                
                // Extract statistics from field profiles
                for (const profile of worksheetProfiles.filter(p => !p.error)) {
                  for (const field of profile.fields) {
                    if (field.role === 'Measure' && field.avg !== undefined) {
                      const cleanName = cleanFieldName(field.name);
                      cacheData.statistics[cleanName] = {
                        count: field.validCount || field.totalCount,
                        sum: field.sum,
                        avg: field.avg,
                        min: field.min,
                        max: field.max,
                        formattedAvg: formatAsPercentage(field.avg, cleanName)
                      };
                    }
                  }
                }
                
                storyCache.cacheKey = {
                  worksheetNames: worksheetProfiles.map(p => p.worksheet),
                  dataHash: generateDataHash(cacheData),
                  rowCount: totalRows,
                  timestamp: Date.now()
                };
                storyCache.isStale = false;
                storyCache.staleReason = null;
                
                console.log('[analyze_dashboard_smart] Cache populated:', {
                  worksheets: cacheData.worksheetSummaries.length,
                  statistics: Object.keys(cacheData.statistics).length
                });
              }
            } catch (cacheError) {
              console.error('[analyze_dashboard_smart] Cache population error:', cacheError);
            }
            
            // Store for PDF download
            lastGeneratedAnalysis = {
              markdown: report,
              data: { worksheetProfiles, allFields: Object.fromEntries(allFields), analysisGoal },
              timestamp: new Date().toISOString()
            };
            
            return report + '\n---\n*Click the "Download Analysis PDF" button below to save this report.*';
          }
          
          case 'render_visualization': {
            console.log('render_visualization called with args:', args);
            const ws = dashboard.worksheets.find(w => w.name === args.worksheet);
            if (!ws) {
              // List available worksheets
              const available = dashboard.worksheets.map(w => w.name).join(', ');
              throw new Error(`Worksheet "${args.worksheet}" not found. Available: ${available}`);
            }
            console.log('Found worksheet:', ws.name);
            
            // Create config for this visualization
            const vizConfig = { ...args, worksheetObj: ws, vizId: 'viz-' + Date.now() };
            
            // If not appending, clear previous configs, listeners, AND dashboard base HTML
            if (!args.append) {
              currentVizConfigs = [];
              dashboardBaseHtml = ''; // Clear base HTML when not appending
              for (const listener of vizEventListeners) {
                try { listener.unregister(); } catch (e) {}
              }
              vizEventListeners = [];
            }
            
            // Add this config to the array
            currentVizConfigs.push(vizConfig);
            
            // Render the visualization with LLM fallback for error recovery
            console.log('Rendering visualization...');
            let html;
            let usedFallback = false;
            
            try {
              html = await renderVisualization(vizConfig);
              
              // Validate the generated HTML
              if (!html || html.includes('undefined') || html.includes('NaN') || html.length < 50) {
                throw new Error('Generated HTML appears invalid or incomplete');
              }
              
              console.log('Visualization rendered successfully, HTML length:', html.length);
            } catch (renderError) {
              // Fallback to LLM code generation model
              console.log('[Fallback] Tool rendering failed:', renderError.message);
              console.log('[Fallback] Invoking Code Generation model to fix...');
              
              const genModelConfig = settings.getModelConfig('generation');
              if (genModelConfig.apiKey) {
                usedFallback = true;
                
                // Build context-rich prompt for the LLM
                const fallbackPrompt = `You are a visualization code generator. A tool-based renderer failed to create a chart. Generate valid HTML/CSS to create the requested visualization.

## Original Request
- Chart Type: ${args.vizType}
- Worksheet: ${args.worksheet}
- Dimension: ${args.dimensionField || 'auto-detect'}
- Measure: ${args.measureField || 'auto-detect'}
- Title: ${args.title || 'auto'}
- Theme: ${args.theme || 'professional'}
- Max Items: ${args.maxItems || 10}
- Color Scheme: ${args.colorScheme || 'blue'}
- Custom Colors: ${args.customColors ? args.customColors.join(', ') : 'none'}

## Error That Occurred
${renderError.message}

## Sample Data (if available)
${vizConfig.sampleData ? JSON.stringify(vizConfig.sampleData.slice(0, 5), null, 2) : 'No sample data available'}

## Instructions
1. Generate a complete, self-contained HTML visualization
2. Use inline CSS (no external stylesheets)
3. Make it responsive and professional
4. Match the requested theme (${args.theme === 'modern' ? 'dark background, light text' : 'light background, dark text'})
5. Return ONLY the HTML code, no explanations

Generate the HTML now:`;

                try {
                  html = await callLLM(fallbackPrompt, null, 'generation');
                  
                  // Extract HTML from markdown code blocks if present
                  const htmlMatch = html.match(/```html\s*([\s\S]*?)```/);
                  if (htmlMatch) {
                    html = htmlMatch[1].trim();
                  }
                  
                  console.log('[Fallback] LLM generated HTML, length:', html.length);
                } catch (llmError) {
                  console.error('[Fallback] LLM also failed:', llmError.message);
                  throw new Error(`Visualization failed: ${renderError.message}. LLM fallback also failed: ${llmError.message}`);
                }
              } else {
                // No API key for generation model, re-throw original error
                throw renderError;
              }
            }
            
            // Store the rendered HTML in the config for refresh
            vizConfig.renderedHtml = html;
            if (usedFallback) {
              vizConfig.usedLLMFallback = true;
            }
            
            console.log('Visualization ready, HTML length:', html.length);
            
            // Display in preview - combine dashboard base HTML with new visualizations
            let finalHtml = '';
            if (dashboardBaseHtml && args.append) {
              // Append to existing dashboard - add visualizations after the dashboard
              const vizLayoutHtml = await buildDashboardLayout();
              // Insert the new visualizations at the end of the dashboard content
              // Find the closing </div> of the main dashboard container and insert before it
              if (dashboardBaseHtml.includes('</div>\n</div>')) {
                // Insert new charts before the final closing divs
                finalHtml = dashboardBaseHtml.replace(
                  /<\/div>\s*<\/div>\s*$/,
                  `${vizLayoutHtml}</div>\n</div>`
                );
              } else {
                // Fallback: just append
                finalHtml = dashboardBaseHtml + vizLayoutHtml;
              }
            } else {
              // No base HTML - just use the layout
              finalHtml = await buildDashboardLayout();
            }
            
            previewContainer.innerHTML = finalHtml;
            generatedHtml = previewContainer.innerHTML;
            
            // Apply dark theme background to preview container if any viz uses modern theme
            const usesDarkTheme = currentVizConfigs.some(cfg => cfg.theme === 'modern');
            if (usesDarkTheme) {
              previewContainer.style.backgroundColor = '#0f172a';
              previewContainer.style.borderColor = '#334155';
            } else {
              previewContainer.style.backgroundColor = '';
              previewContainer.style.borderColor = '';
            }
            
            // Set up auto-refresh on filter/selection changes (debounced)
            const refreshAllVisualizations = async () => {
              // Debounce to avoid multiple rapid refreshes
              if (refreshDebounceTimer) {
                clearTimeout(refreshDebounceTimer);
              }
              
              refreshDebounceTimer = setTimeout(async () => {
                try {
                  console.log('Event detected, refreshing all visualizations...');
                  console.log('Number of viz configs to refresh:', currentVizConfigs.length);
                  
                  // Re-render - preserve dashboard base HTML if we have it
                  let finalHtml = '';
                  if (dashboardBaseHtml && currentVizConfigs.length > 0) {
                    const vizLayoutHtml = await buildDashboardLayout();
                    if (dashboardBaseHtml.includes('</div>\n</div>')) {
                      finalHtml = dashboardBaseHtml.replace(
                        /<\/div>\s*<\/div>\s*$/,
                        `${vizLayoutHtml}</div>\n</div>`
                      );
                    } else {
                      finalHtml = dashboardBaseHtml + vizLayoutHtml;
                    }
                  } else if (currentVizConfigs.length > 0) {
                    finalHtml = await buildDashboardLayout();
                  } else if (dashboardBaseHtml) {
                    finalHtml = dashboardBaseHtml;
                  }
                  
                  if (finalHtml) {
                    previewContainer.innerHTML = finalHtml;
                    generatedHtml = previewContainer.innerHTML;
                    
                    // Apply dark theme background on refresh as well
                    const usesDarkTheme = currentVizConfigs.some(cfg => cfg.theme === 'modern');
                    if (usesDarkTheme) {
                      previewContainer.style.backgroundColor = '#0f172a';
                      previewContainer.style.borderColor = '#334155';
                    } else {
                      previewContainer.style.backgroundColor = '';
                      previewContainer.style.borderColor = '';
                    }
                  }
                  console.log('All visualizations refreshed successfully');
                } catch (e) {
                  console.log('Viz refresh error:', e);
                }
              }, 300); // 300ms debounce
            };
            
            // Only set up listeners once (when this is the first viz or we cleared them)
            if (vizEventListeners.length === 0) {
              console.log('Setting up event listeners for auto-refresh...');
              
              // Listen to filter changes on ALL worksheets
              for (const worksheet of dashboard.worksheets) {
                try {
                  const filterListener = worksheet.addEventListener(
                    tableau.TableauEventType.FilterChanged,
                    () => {
                      console.log('FilterChanged event on:', worksheet.name);
                      markStoryCacheStale('filter_changed');
                      refreshAllVisualizations();
                    }
                  );
                  vizEventListeners.push(filterListener);
                  console.log('Added filter listener to:', worksheet.name);
                } catch (e) {
                  console.log('Could not add filter listener to', worksheet.name, e.message);
                }
              }
              
              // Listen to mark selection changes (this is what happens when you click on a bar)
              for (const worksheet of dashboard.worksheets) {
                try {
                  const markListener = worksheet.addEventListener(
                    tableau.TableauEventType.MarkSelectionChanged,
                    () => {
                      console.log('MarkSelectionChanged event on:', worksheet.name);
                      markStoryCacheStale('selection_changed');
                      refreshAllVisualizations();
                    }
                  );
                  vizEventListeners.push(markListener);
                  console.log('Added mark listener to:', worksheet.name);
                } catch (e) {
                  console.log('Could not add mark listener to', worksheet.name, e.message);
                }
              }
              
              // Listen to parameter changes
              try {
                const params = await dashboard.getParametersAsync();
                for (const param of params) {
                  try {
                    const paramListener = param.addEventListener(
                      tableau.TableauEventType.ParameterChanged,
                      () => {
                        console.log('ParameterChanged event on:', param.name);
                        markStoryCacheStale('parameter_changed');
                        refreshAllVisualizations();
                      }
                    );
                    vizEventListeners.push(paramListener);
                    console.log('Added param listener to:', param.name);
                  } catch (e) {
                    console.log('Could not add param listener to', param.name);
                  }
                }
              } catch (e) {
                console.log('Could not get parameters for listeners:', e.message);
              }
              
              console.log('Total event listeners set up:', vizEventListeners.length);
            }
            
            // Show the refresh and clear buttons
            const refreshBtn = document.getElementById('btn-refresh-viz');
            const clearBtn = document.getElementById('btn-clear-viz');
            if (refreshBtn) {
              refreshBtn.style.display = 'inline-block';
            }
            if (clearBtn) {
              clearBtn.style.display = 'inline-block';
            }
            
            // Save configs to localStorage for persistence
            saveVizConfigs();
            
            // Notify user if LLM fallback was used
            const fallbackNote = usedFallback 
              ? '\n\n⚠️ *Note: The standard renderer encountered an issue, so the Code Generation model was used to create this visualization.*' 
              : '';
            
            return `Created ${args.vizType} visualization from "${args.worksheet}" worksheet. The visualization is now displayed in the Preview panel. Click the "Refresh Data" button to update after applying filters in Tableau.${fallbackNote}`;
          }
          
          // ==================== DESIGN ANALYSIS TOOL HANDLERS ====================
          
          case 'analyze_iron_viz_style': {
            // Analyze dashboard against Iron Viz design principles
            const focusAreas = args.focusAreas || ['color', 'layout', 'typography', 'storytelling', 'impact'];
            
            // Get screenshot - either from args or capture current
            let imageBase64 = args.screenshotBase64;
            if (!imageBase64 && uploadedImage) {
              imageBase64 = uploadedImage;
            }
            
            if (!imageBase64) {
              return 'Please drop a dashboard screenshot into the chat, or go to the Design tab and capture your dashboard first.';
            }
            
            // Build the Iron Viz analysis prompt
            const analysisPrompt = `You are an expert design judge from the Iron Viz competition. Analyze this Tableau dashboard screenshot against Iron Viz competition design principles.

**EVALUATION CRITERIA (Score each 1-10):**

1. **VISUAL HIERARCHY** (${focusAreas.includes('layout') ? 'FOCUS' : 'Standard'})
   - Clear focal point that draws the eye
   - Logical flow from most to least important
   - Proper use of size, color, and position for emphasis

2. **COLOR HARMONY** (${focusAreas.includes('color') ? 'FOCUS' : 'Standard'})
   - Cohesive color palette (2-4 main colors)
   - Purposeful color choices that support the story
   - Accessibility considerations
   - No jarring or competing colors

3. **WHITE SPACE & LAYOUT** (${focusAreas.includes('layout') ? 'FOCUS' : 'Standard'})
   - Breathing room between elements
   - Intentional padding and margins
   - Grid-based alignment
   - Not cluttered or cramped

4. **TYPOGRAPHY** (${focusAreas.includes('typography') ? 'FOCUS' : 'Standard'})
   - Limited font families (1-2 max)
   - Clear hierarchy in text sizes
   - Readable font sizes
   - Consistent styling

5. **STORYTELLING** (${focusAreas.includes('storytelling') ? 'FOCUS' : 'Standard'})
   - Clear narrative or insight
   - Obvious "so what?" takeaway
   - Context provided for data
   - Annotations where needed

6. **CUSTOM ELEMENTS & POLISH** (${focusAreas.includes('impact') ? 'FOCUS' : 'Standard'})
   - Custom shapes, icons, or imagery
   - Thoughtful chart choices
   - Attention to detail
   - Unique visual identity

7. **OVERALL IMPACT** (${focusAreas.includes('impact') ? 'FOCUS' : 'Standard'})
   - Would this stop someone scrolling?
   - Memorable and distinctive
   - Professional quality
   - Emotional resonance

**OUTPUT FORMAT:**

## Iron Viz Style Scorecard

### Overall Score: X/10

| Criterion | Score | Quick Take |
|-----------|-------|------------|
| Visual Hierarchy | X/10 | [one-liner] |
| Color Harmony | X/10 | [one-liner] |
| White Space | X/10 | [one-liner] |
| Typography | X/10 | [one-liner] |
| Storytelling | X/10 | [one-liner] |
| Custom Elements | X/10 | [one-liner] |
| Overall Impact | X/10 | [one-liner] |

### Top 3 Strengths
1. [specific strength with why it works]
2. [specific strength with why it works]
3. [specific strength with why it works]

### Top 3 Improvements
1. **[Issue]**: [Specific suggestion with Iron Viz examples]
2. **[Issue]**: [Specific suggestion with Iron Viz examples]
3. **[Issue]**: [Specific suggestion with Iron Viz examples]

### Iron Viz Inspiration
[Suggest 1-2 past Iron Viz winners with similar themes that could inspire improvements]

### Quick Wins
[3 changes that could be made in under 30 minutes for biggest impact]`;
            
            try {
              const visionResponse = await callLLM(analysisPrompt, imageBase64, 'vision');
              return visionResponse;
            } catch (error) {
              return `Error analyzing dashboard: ${error.message}`;
            }
          }
          
          case 'analyze_color_harmony': {
            // Analyze color palette for harmony and accessibility
            let colors = args.colors || [];
            const checkAccessibility = args.checkAccessibility !== false;
            
            // If no colors provided, try to extract from screenshot
            if (colors.length === 0 && args.screenshotBase64) {
              // Use vision API to extract colors
              const extractPrompt = `Extract the main colors from this dashboard. List exactly the hex color codes used for:
1. Primary/accent colors
2. Background colors  
3. Text colors
4. Chart colors

Return ONLY a JSON array of hex codes, like: ["#0B5CAD", "#1F9FB5", "#F4A261", "#FFFFFF", "#333333"]`;
              
              try {
                const colorResponse = await callLLM(extractPrompt, args.screenshotBase64, 'vision');
                // Try to parse the color array from response
                const match = colorResponse.match(/\[([^\]]+)\]/);
                if (match) {
                  colors = JSON.parse(`[${match[1]}]`);
                }
              } catch (e) {
                return 'Could not extract colors from screenshot. Please provide colors array directly.';
              }
            }
            
            if (colors.length === 0) {
              return 'Please provide colors array (e.g., ["#0B5CAD", "#1F9FB5"]) or drop a screenshot to extract colors from.';
            }
            
            // Build color analysis prompt
            const colorPrompt = `Analyze this color palette for a data visualization dashboard:

**COLORS:** ${colors.join(', ')}

**PROVIDE:**

## Color Harmony Analysis

### Harmony Type
[Identify: Complementary, Analogous, Triadic, Split-Complementary, Monochromatic, or Custom]

### Palette Assessment
| Color | Role Suggestion | Emotional Association |
|-------|----------------|----------------------|
${colors.map(c => `| ${c} | [suggested use] | [emotion/meaning] |`).join('\n')}

### Harmony Score: X/10
[Explain why these colors work or don't work together]

${checkAccessibility ? `### Accessibility Check
| Color Pair | Contrast Ratio | WCAG AA | WCAG AAA |
|------------|---------------|---------|----------|
[Check main color combinations for text readability]

**Colorblind Safety:**
- Protanopia (red-blind): [Safe/Caution/Fail]
- Deuteranopia (green-blind): [Safe/Caution/Fail]  
- Tritanopia (blue-blind): [Safe/Caution/Fail]` : ''}

### Suggested Improvements
1. [Specific color swap or addition with hex codes]
2. [Specific color swap or addition with hex codes]
3. [Specific color swap or addition with hex codes]

### Recommended Palette
[Provide optimized 5-color palette with hex codes that fixes any issues while maintaining the original intent]`;
            
            try {
              // Use text-based analysis (no vision needed for hex codes)
              const response = await callLLM(colorPrompt, null, 'analysis');
              return response;
            } catch (error) {
              return `Error analyzing colors: ${error.message}`;
            }
          }
          
          case 'generate_tableau_palette': {
            // Generate a custom Tableau color palette (.tps file)
            const theme = args.theme;
            const brandColors = args.brandColors || [];
            const paletteType = args.paletteType || 'categorical';
            const paletteName = args.paletteName || `DashAgent ${theme} Palette`;
            const colorCount = args.colorCount || 10;
            
            // Gather dashboard context for smarter recommendations
            let dashboardContext = '';
            let dataContext = '';
            const dashboard = tableau.extensions.dashboardContent?.dashboard;
            
            if (dashboard) {
              dashboardContext = `Dashboard: "${dashboard.name}"`;
              
              // Get worksheet info and sample data
              const worksheets = dashboard.worksheets;
              if (worksheets.length > 0) {
                const wsNames = worksheets.map(ws => ws.name).join(', ');
                dashboardContext += `\nWorksheets: ${wsNames}`;
                
                // Try to get field names from first worksheet
                try {
                  const ws = worksheets[0];
                  const dataTable = await ws.getSummaryDataAsync();
                  const columns = dataTable.columns.map(c => c.fieldName);
                  dataContext = `\nData fields: ${columns.slice(0, 15).join(', ')}${columns.length > 15 ? '...' : ''}`;
                  
                  // Identify data domain from field names
                  const fieldStr = columns.join(' ').toLowerCase();
                  if (fieldStr.includes('email') || fieldStr.includes('campaign') || fieldStr.includes('open rate') || fieldStr.includes('click')) {
                    dataContext += '\nDomain detected: Email Marketing / Campaign Analytics';
                  } else if (fieldStr.includes('sales') || fieldStr.includes('revenue') || fieldStr.includes('profit')) {
                    dataContext += '\nDomain detected: Sales / Financial Analytics';
                  } else if (fieldStr.includes('customer') || fieldStr.includes('churn') || fieldStr.includes('retention')) {
                    dataContext += '\nDomain detected: Customer Analytics';
                  } else if (fieldStr.includes('product') || fieldStr.includes('inventory') || fieldStr.includes('sku')) {
                    dataContext += '\nDomain detected: Product / Inventory Analytics';
                  } else if (fieldStr.includes('hr') || fieldStr.includes('employee') || fieldStr.includes('headcount')) {
                    dataContext += '\nDomain detected: HR / People Analytics';
                  } else if (fieldStr.includes('web') || fieldStr.includes('traffic') || fieldStr.includes('session') || fieldStr.includes('pageview')) {
                    dataContext += '\nDomain detected: Web Analytics';
                  }
                } catch (e) {
                  // Ignore data fetch errors
                }
              }
            }
            
            // Generate colors based on theme with context
            const palettePrompt = `You are a senior data visualization designer creating a Tableau color palette.

**CONTEXT:**
Theme requested: "${theme}"
${dashboardContext}${dataContext}
${brandColors.length > 0 ? `Brand colors to incorporate: ${brandColors.join(', ')}` : ''}

**REQUIREMENTS:**
- Palette type: ${paletteType}
- Number of colors: ${colorCount}
- Must work well for data visualization (sufficient contrast between adjacent colors)
- Must be colorblind-safe (avoid red-green only distinctions)
- ${paletteType === 'sequential' ? 'Colors should progress from light to dark for showing magnitude' : ''}
- ${paletteType === 'diverging' ? 'Colors should diverge from a neutral middle for above/below comparisons' : ''}
- ${paletteType === 'categorical' ? 'Colors should be maximally distinct for comparing categories' : ''}

**OUTPUT FORMAT (EXACT JSON):**
{
  "paletteName": "${paletteName}",
  "colors": ["#HEX1", "#HEX2", ...],
  "colorNames": ["descriptive name for each color"],
  "description": "Brief description of the palette and why it fits this data",
  "designRationale": "Explain why these colors work for the detected domain/context",
  "fontRecommendations": {
    "title": { "font": "Font Name", "weight": "bold/semibold", "size": "18-24px" },
    "subtitle": { "font": "Font Name", "weight": "normal", "size": "12-14px" },
    "body": { "font": "Font Name", "weight": "normal", "size": "10-12px" },
    "kpiValue": { "font": "Font Name", "weight": "bold", "size": "28-36px" },
    "rationale": "Why these fonts work for this dashboard type"
  },
  "usageTips": ["tip 1 for using this palette effectively", "tip 2", "tip 3"]
}

**FONT GUIDELINES:**
- For corporate/professional: Tableau Book, Segoe UI, Arial, Helvetica
- For modern/tech: Inter, SF Pro, Roboto, Source Sans Pro
- For editorial/storytelling: Georgia, Merriweather, Lora
- For finance: Consolas for numbers, Helvetica for labels
- Ensure fonts are web-safe or commonly available in Tableau

ONLY return the JSON, no other text.`;
            
            try {
              const response = await callLLM(palettePrompt, null, 'analysis');
              
              // Parse the response
              let paletteData;
              try {
                paletteData = JSON.parse(response.trim());
              } catch (e) {
                // Try to extract JSON from response
                const match = response.match(/\{[\s\S]*\}/);
                if (match) {
                  paletteData = JSON.parse(match[0]);
                } else {
                  throw new Error('Could not parse palette response');
                }
              }
              
              // Generate Tableau Preferences.tps XML
              const tpsXml = `<?xml version='1.0'?>
<workbook>
  <preferences>
    <color-palette name="${paletteData.paletteName}" type="${paletteType}">
${paletteData.colors.map(c => `      <color>${c}</color>`).join('\n')}
    </color-palette>
  </preferences>
</workbook>`;
              
              // Display in preview with download option
              const fonts = paletteData.fontRecommendations || {};
              const previewHtml = `
<div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: white; border-radius: 12px;">
  <h2 style="margin-top:0; display:flex; align-items:center; gap:8px;">
    ${paletteData.paletteName}
  </h2>
  <p style="opacity:0.8; margin-bottom:20px;">${paletteData.description || `A ${paletteType} palette for ${theme}-themed dashboards`}</p>
  
  <div style="display:flex; gap:4px; margin-bottom:20px; flex-wrap:wrap;">
    ${paletteData.colors.map((c, i) => `
      <div style="text-align:center;">
        <div style="width:60px; height:60px; background:${c}; border-radius:8px; border:2px solid rgba(255,255,255,0.2);"></div>
        <div style="font-size:10px; margin-top:4px; opacity:0.8;">${c}</div>
        ${paletteData.colorNames?.[i] ? `<div style="font-size:9px; opacity:0.6;">${paletteData.colorNames[i]}</div>` : ''}
      </div>
    `).join('')}
  </div>
  
  ${fonts.title ? `
  <div style="background:rgba(0,0,0,0.3); padding:12px; border-radius:8px; margin-bottom:15px;">
    <strong style="display:block; margin-bottom:10px;">Font Recommendations</strong>
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; font-size:12px;">
      <div><span style="opacity:0.7;">Title:</span> <span style="font-family:${fonts.title.font};">${fonts.title.font}</span> (${fonts.title.size})</div>
      <div><span style="opacity:0.7;">Subtitle:</span> <span style="font-family:${fonts.subtitle?.font || 'inherit'};">${fonts.subtitle?.font || 'Tableau Medium'}</span></div>
      <div><span style="opacity:0.7;">Body:</span> <span style="font-family:${fonts.body?.font || 'inherit'};">${fonts.body?.font || 'Tableau Book'}</span></div>
      <div><span style="opacity:0.7;">KPI Values:</span> <span style="font-family:${fonts.kpiValue?.font || 'inherit'}; font-weight:bold;">${fonts.kpiValue?.font || 'Tableau Bold'}</span></div>
    </div>
  </div>
  ` : ''}
  
  <details style="background:rgba(0,0,0,0.3); padding:12px; border-radius:8px; margin-bottom:15px;">
    <summary style="cursor:pointer; font-weight:600;">Tableau Preferences.tps Content</summary>
    <pre style="font-size:11px; overflow-x:auto; margin-top:10px; background:rgba(0,0,0,0.4); padding:10px; border-radius:6px;">${tpsXml.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
  </details>
  
  <div style="background:rgba(255,255,255,0.1); padding:12px; border-radius:8px;">
    <strong>How to Install:</strong>
    <ol style="margin:10px 0 0 0; padding-left:20px; font-size:13px;">
      <li>Copy the XML content above</li>
      <li>Navigate to your Tableau Repository folder:
        <br><code style="font-size:11px; background:rgba(0,0,0,0.3); padding:2px 6px; border-radius:4px;">Documents/My Tableau Repository/Preferences.tps</code></li>
      <li>Open Preferences.tps in a text editor</li>
      <li>Paste the color-palette section inside the preferences tags</li>
      <li>Restart Tableau Desktop</li>
      <li>Find your palette under "Color" → "Select Color Palette"</li>
    </ol>
  </div>
</div>`;
              
              previewContainer.innerHTML = previewHtml;
              generatedHtml = previewHtml;
              
              // Store for refresh
              currentVizConfigs = [{ type: 'palette', data: paletteData }];
              localStorage.setItem('dashagent_viz_configs', JSON.stringify(currentVizConfigs));
              
              // Build color list with names
              const colorList = paletteData.colors.map((c, i) => {
                const name = paletteData.colorNames?.[i] || '';
                return name ? `${i + 1}. ${c} (${name})` : `${i + 1}. ${c}`;
              }).join('\n');
              
              // Build font recommendations section
              let fontSection = '';
              if (paletteData.fontRecommendations) {
                const fonts = paletteData.fontRecommendations;
                fontSection = `

---

## Font Recommendations

| Element | Font | Weight | Size |
|---------|------|--------|------|
| **Title** | ${fonts.title?.font || 'Tableau Bold'} | ${fonts.title?.weight || 'bold'} | ${fonts.title?.size || '20-24px'} |
| **Subtitle** | ${fonts.subtitle?.font || 'Tableau Medium'} | ${fonts.subtitle?.weight || 'normal'} | ${fonts.subtitle?.size || '12-14px'} |
| **Body/Labels** | ${fonts.body?.font || 'Tableau Book'} | ${fonts.body?.weight || 'normal'} | ${fonts.body?.size || '10-12px'} |
| **KPI Values** | ${fonts.kpiValue?.font || 'Tableau Bold'} | ${fonts.kpiValue?.weight || 'bold'} | ${fonts.kpiValue?.size || '28-36px'} |

${fonts.rationale ? `**Why these fonts:** ${fonts.rationale}` : ''}`;
              }
              
              // Build usage tips section
              let tipsSection = '';
              if (paletteData.usageTips && paletteData.usageTips.length > 0) {
                tipsSection = `

---

## Usage Tips

${paletteData.usageTips.map((tip, i) => `${i + 1}. ${tip}`).join('\n')}`;
              }
              
              // Build design rationale section
              let rationaleSection = '';
              if (paletteData.designRationale) {
                rationaleSection = `

### Design Rationale
${paletteData.designRationale}`;
              }
              
              return `## ${paletteData.paletteName}

${paletteData.description || `A ${paletteType} palette for ${theme}-themed dashboards`}
${rationaleSection}

### Colors (${paletteType})

${colorList}
${fontSection}
${tipsSection}

---

## Tableau Preferences.tps

\`\`\`xml
${tpsXml}
\`\`\`

**Installation:** Copy the XML above and paste it into your \`Documents/My Tableau Repository/Preferences.tps\` file, then restart Tableau Desktop.`;
            } catch (error) {
              return `Error generating palette: ${error.message}`;
            }
          }
          
          case 'suggest_annotations': {
            // Suggest where to add annotations based on data
            const worksheetName = args.worksheetName;
            const annotationStyle = args.annotationStyle || 'detailed';
            
            // Get dashboard data
            const dashboard = tableau.extensions.dashboardContent?.dashboard;
            if (!dashboard) {
              return 'No Tableau dashboard detected. Please ensure the extension is connected to a dashboard.';
            }
            
            // Find worksheet(s) to analyze
            const worksheets = worksheetName 
              ? dashboard.worksheets.filter(ws => ws.name.toLowerCase().includes(worksheetName.toLowerCase()))
              : dashboard.worksheets;
            
            if (worksheets.length === 0) {
              return `No worksheets found${worksheetName ? ` matching "${worksheetName}"` : ''}. Available: ${dashboard.worksheets.map(ws => ws.name).join(', ')}`;
            }
            
            // Collect data from worksheets
            let dataContext = '';
            for (const ws of worksheets.slice(0, 3)) { // Limit to 3 worksheets
              try {
                const data = await ws.getSummaryDataAsync();
                const columns = data.columns.map(c => c.fieldName);
                const rows = data.data.slice(0, 20).map(row => 
                  row.map(cell => cell.formattedValue)
                );
                
                dataContext += `\n### Worksheet: ${ws.name}\n`;
                dataContext += `Columns: ${columns.join(', ')}\n`;
                dataContext += `Sample data (first ${Math.min(20, data.data.length)} rows):\n`;
                dataContext += rows.map(r => r.join(' | ')).join('\n');
                dataContext += '\n';
              } catch (e) {
                dataContext += `\n### Worksheet: ${ws.name}\n(Could not retrieve data)\n`;
              }
            }
            
            const annotationPrompt = `Based on this dashboard data, suggest where to add annotations:

${dataContext}

**Annotation Style:** ${annotationStyle}
- minimal: Just highlight 1-2 key points
- detailed: Provide context for important findings
- storytelling: Create a narrative flow with connected annotations

**PROVIDE:**

## 📝 Annotation Suggestions

### Priority Annotations (Add These First!)

${annotationStyle === 'minimal' ? '**1 Key Annotation:**' : '**Top 3-5 Annotations:**'}

For each annotation:
| Location | Annotation Text | Why It Matters |
|----------|-----------------|----------------|
| [Chart/data point] | "[Exact text to use]" | [Impact/insight] |

### Annotation Placement Tips
[Specific advice for positioning annotations in Tableau]

### Formatting Recommendations
- Font size: [recommendation]
- Style: [box, line, point annotation]
- Color: [recommendation matching dashboard]

${annotationStyle === 'storytelling' ? `### Narrative Flow
[Describe how annotations should guide the reader through the story]` : ''}`;
            
            try {
              const response = await callLLM(annotationPrompt, null, 'analysis');
              return response;
            } catch (error) {
              return `Error suggesting annotations: ${error.message}`;
            }
          }
          
          case 'transform_to_story': {
            // Transform plain dashboard into storytelling format using multi-stage pipeline
            const storyAngle = args.storyAngle || 'performance';
            const audience = args.audience || 'executive';
            const includeRecommendations = args.includeRecommendations !== false;
            const forceRefresh = args.forceRefresh === true;
            const designRequest = args.designRequest || null; // For custom design requests
            
            // Get dashboard data
            const dashboard = tableau.extensions.dashboardContent?.dashboard;
            if (!dashboard) {
              return 'No Tableau dashboard detected. Please ensure the extension is connected.';
            }
            
            const dashboardName = dashboard.name;
            let statusMessages = [];
            
            try {
              // ============ STAGE 1: DATA EXTRACTION ============
              const stage1Start = Date.now();
              const extractResult = await extractStoryData(dashboard, forceRefresh);
              const stage1Time = Date.now() - stage1Start;
              
              if (extractResult.cached) {
                statusMessages.push(`📦 Using cached data extraction`);
              } else {
                statusMessages.push(`📊 Extracted data from ${extractResult.data.worksheetSummaries.length} worksheets (${stage1Time}ms)`);
              }
              
              // Check if we have enough data
              if (Object.keys(extractResult.data.rankings).length === 0) {
                return 'Could not extract meaningful data from the dashboard. Ensure worksheets have dimensions and measures.';
              }
              
              // ============ STAGE 2: ANALYSIS LLM ============
              const stage2Start = Date.now();
              const analysisResult = await generateStoryAnalysis(
                extractResult.data, 
                storyAngle, 
                audience, 
                forceRefresh
              );
              const stage2Time = Date.now() - stage2Start;
              
              if (analysisResult.cached) {
                statusMessages.push(`📦 Using cached analysis`);
              } else {
                statusMessages.push(`🧠 Generated narrative insights (${stage2Time}ms)`);
              }
              
              // ============ STAGE 3: DESIGN LLM (optional) ============
              const stage3Start = Date.now();
              const designResult = await generateStoryDesign(
                analysisResult.analysis,
                { customRequest: designRequest }
              );
              const stage3Time = Date.now() - stage3Start;
              
              if (designResult.cached) {
                statusMessages.push(`🎨 Using default design`);
              } else {
                statusMessages.push(`🎨 Custom design applied (${stage3Time}ms)`);
              }
              
              // ============ STAGE 4: RENDER HTML ============
              const storyHtml = renderStoryHtml(analysisResult.analysis, designResult.design);
              
              previewContainer.innerHTML = storyHtml;
              generatedHtml = storyHtml;
              
              currentVizConfigs = [{ 
                type: 'story', 
                data: analysisResult.analysis,
                design: designResult.design
              }];
              localStorage.setItem('dashagent_viz_configs', JSON.stringify(currentVizConfigs));
              
              // Show buttons
              const clearBtn = document.getElementById('btn-clear-viz');
              if (clearBtn) clearBtn.style.display = 'flex';
              
              // Build response with cache status
              const cacheStatus = storyCache.isStale ? '' : '🔄 ';
              const topRankings = Object.entries(extractResult.data.rankings).slice(0, 3).map(([key, ranking]) => {
                if (ranking.length > 0) {
                  return `• **${key}**: #1 ${ranking[0].name} (${ranking[0].formatted})`;
                }
                return null;
              }).filter(Boolean).join('\n');
              
              return `${cacheStatus}Created a storytelling narrative for "${dashboardName}"!

**Pipeline Status:**
${statusMessages.map(m => `• ${m}`).join('\n')}

**Verified Rankings Used:**
${topRankings}

**Hero Headline:** ${analysisResult.analysis.heroHeadline}

The story panel with key takeaway, insights, and ${includeRecommendations ? 'recommended actions' : 'analysis'} is now displayed.

💡 **Tip:** Say "refresh the analysis" to re-analyze if data changed, or "make it darker/corporate/modern" to change the design without re-analyzing.`;
            } catch (error) {
              return `Error creating story: ${error.message}`;
            }
          }
          
          case 'generate_custom_assets': {
            // Generate AI-powered custom visual assets
            const assetType = args.assetType;
            const theme = args.theme;
            const style = args.style || 'minimal';
            const colorScheme = args.colorScheme || ['#0B5CAD', '#FFFFFF'];
            const description = args.description || '';
            const size = args.size || 'medium';
            
            // Map size to dimensions
            const sizeMap = {
              'small': '64x64',
              'medium': '256x256', 
              'large': '512x512',
              'banner': '1200x400'
            };
            const dimensions = sizeMap[size] || '256x256';
            
            // Build the image generation prompt
            let imagePrompt = '';
            
            switch (assetType) {
              case 'icon':
                imagePrompt = `A clean, professional ${style} style icon representing "${theme}". ${description ? description : ''} Simple design suitable for a business dashboard. Colors: ${colorScheme.join(', ')}. White or transparent background. No text. Flat design, centered, high quality.`;
                break;
              case 'pictogram':
                imagePrompt = `A ${style} pictogram/infographic icon representing "${theme}". ${description ? description : ''} Simple, bold design suitable for data visualization. Limited colors: ${colorScheme.join(', ')}. Clean white background. No text. Vector-style, centered.`;
                break;
              case 'background':
                imagePrompt = `A subtle, professional ${style} background pattern for a "${theme}" themed dashboard. ${description ? description : ''} Muted colors that won't distract from data: ${colorScheme.join(', ')}. Suitable as a dashboard background. No text or focal elements.`;
                break;
              case 'header-image':
                imagePrompt = `A professional ${style} header banner image for a "${theme}" dashboard. ${description ? description : ''} Wide aspect ratio, subtle and professional. Colors: ${colorScheme.join(', ')}. Space for overlaid text on left side. Corporate quality.`;
                break;
              case 'decorative':
                imagePrompt = `A decorative ${style} element for a "${theme}" themed dashboard. ${description ? description : ''} Can be used as accent or divider. Colors: ${colorScheme.join(', ')}. Subtle and elegant. Transparent or white background.`;
                break;
              default:
                imagePrompt = `A professional ${style} visual asset for a "${theme}" themed data dashboard. ${description ? description : ''} Colors: ${colorScheme.join(', ')}. Clean, minimal, business appropriate.`;
            }
            
            try {
              // Call OpenAI image generation (GPT Image 1 - latest model)
              // Note: gpt-image-1 uses 'output_format' not 'response_format', and different size options
              const imageResponse = await fetch('https://api.openai.com/v1/images/generations', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${settings.openaiApiKey}`
                },
                body: JSON.stringify({
                  model: 'gpt-image-1',
                  prompt: imagePrompt,
                  n: 1,
                  size: dimensions === '1200x400' ? '1536x1024' : '1024x1024',
                  quality: 'medium'
                })
              });
              
              if (!imageResponse.ok) {
                const errorData = await imageResponse.json();
                throw new Error(errorData.error?.message || 'Image generation failed');
              }
              
              const imageData = await imageResponse.json();
              
              // gpt-image-1 returns base64 data directly in 'b64_json' field by default
              // or it may return a URL - handle both cases
              let imageUrl;
              if (imageData.data[0].b64_json) {
                imageUrl = `data:image/png;base64,${imageData.data[0].b64_json}`;
              } else if (imageData.data[0].url) {
                // If URL is returned, fetch and convert to base64 for download capability
                imageUrl = imageData.data[0].url;
              } else {
                throw new Error('Unexpected response format from image API');
              }
              
              const revisedPrompt = imageData.data[0].revised_prompt;
              
              // Display in preview
              const assetHtml = `
<div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: white; border-radius: 12px;">
  <h2 style="margin-top:0; display:flex; align-items:center; gap:8px;">
    Custom ${assetType.charAt(0).toUpperCase() + assetType.slice(1)} Generated
  </h2>
  <p style="opacity:0.8; margin-bottom:20px;">Theme: ${theme} | Style: ${style}</p>
  
  <div style="text-align:center; margin-bottom:20px;">
    <img src="${imageUrl}" alt="${theme} ${assetType}" style="max-width:100%; max-height:400px; border-radius:12px; box-shadow:0 8px 32px rgba(0,0,0,0.4);" />
  </div>
  
  <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center; margin-bottom:20px;">
    <a href="${imageUrl}" download="${theme}-${assetType}.png" style="background:#0B5CAD; color:white; padding:10px 20px; border-radius:6px; text-decoration:none; font-weight:600; display:flex; align-items:center; gap:6px;">
      Download Image
    </a>
  </div>
  
  <details style="background:rgba(0,0,0,0.3); padding:12px; border-radius:8px;">
    <summary style="cursor:pointer; font-weight:600;">Generation Details</summary>
    <div style="margin-top:10px; font-size:12px; opacity:0.9;">
      <strong>Prompt used:</strong><br/>
      ${revisedPrompt || imagePrompt}
    </div>
  </details>
  
  <div style="background:rgba(255,255,255,0.1); padding:12px; border-radius:8px; margin-top:15px; font-size:13px;">
    <strong>How to use in Tableau:</strong>
    <ol style="margin:8px 0 0 0; padding-left:20px;">
      <li>Right-click the image above and "Save Image As"</li>
      <li>In Tableau: Map → Background Images, or drag an Image object onto the dashboard</li>
      <li>For icons: Use in tooltips with image:// or as floating images</li>
    </ol>
  </div>
</div>`;
              
              previewContainer.innerHTML = assetHtml;
              generatedHtml = assetHtml;
              
              currentVizConfigs = [{ type: 'asset', url: imageUrl, assetType, theme, style }];
              localStorage.setItem('dashagent_viz_configs', JSON.stringify(currentVizConfigs));
              
              // Show clear button
              const clearBtn = document.getElementById('btn-clear-viz');
              if (clearBtn) clearBtn.style.display = 'flex';
              
              return `Generated a custom ${assetType} for "${theme}" theme! 

The image is displayed in the Preview panel. You can:
- Click "Download Image" to save it
- Right-click to copy or save
- Use it in Tableau as a background image, floating element, or tooltip icon

**Tip:** For best results in Tableau, resize the image to match your needs before importing.`;
            } catch (error) {
              return `Error generating asset: ${error.message}

This may be due to:
- Invalid OpenAI API key
- Content policy restrictions
- Rate limiting

Try again with a different description or theme.`;
            }
          }
          
          case 'clear_visualization': {
            // Clear all visualizations from preview
            previewContainer.innerHTML = '<p style="color:var(--text-muted);font-size:13px">No content generated yet. Use Chat to generate visualizations.</p>';
            generatedHtml = '';
            
            // Reset preview container styling (remove dark theme)
            previewContainer.style.backgroundColor = '';
            previewContainer.style.borderColor = '';
            
            // Clear viz configs and listeners
            currentVizConfigs = [];
            for (const listener of vizEventListeners) {
              try { listener.unregister(); } catch (e) {}
            }
            vizEventListeners = [];
            
            // Clear localStorage
            localStorage.removeItem('dashagent_viz_configs');
            
            // Hide buttons
            const refreshBtn = document.getElementById('btn-refresh-viz');
            const clearBtn = document.getElementById('btn-clear-viz');
            if (refreshBtn) refreshBtn.style.display = 'none';
            if (clearBtn) clearBtn.style.display = 'none';
            
            return 'Visualizations cleared. The Preview panel is now empty.';
          }
          
          case 'toggle_tooltips': {
            const enabled = args.enabled !== undefined ? args.enabled : !tooltipsEnabled;
            tooltipsEnabled = enabled;
            
            // Update all existing chart elements with tooltips
            const previewContainer = document.getElementById('generated-output');
            if (previewContainer) {
              // Find all elements with title attribute and toggle visibility
              const tooltipElements = previewContainer.querySelectorAll('[data-tooltip]');
              tooltipElements.forEach(el => {
                if (enabled) {
                  el.setAttribute('title', el.getAttribute('data-tooltip'));
                } else {
                  el.removeAttribute('title');
                }
              });
              
              // Toggle CSS class on container for tooltip visibility
              if (enabled) {
                previewContainer.classList.remove('tooltips-disabled');
              } else {
                previewContainer.classList.add('tooltips-disabled');
              }
            }
            
            const status = enabled ? 'enabled' : 'disabled';
            return `Tooltips are now **${status}**. ${enabled ? 'Hover over chart elements to see details.' : 'Tooltips will be hidden on all charts.'}`;
          }
          
          case 'build_dashboard': {
            // UNIFIED INTELLIGENT DASHBOARD BUILDER
            // Consolidates create_dashboard and redesign_dashboard
            const worksheetName = args.worksheet;
            const focusMetrics = args.focusMetrics || [];
            const focusDimension = args.focusDimension;
            const mode = args.mode || 'auto';
            const theme = args.theme || 'professional';
            const maxMetrics = args.maxMetrics || 6;
            const maxItems = args.maxItems || 7;
            const dashboardTitle = args.title || null;
            const designGuidance = args.designGuidance || null;
            const labelOverrides = args.labelOverrides || {};
            
            // Log design guidance if provided
            if (designGuidance) {
              console.log('[DashAgent] Design Guidance received from LLM:', designGuidance);
            }
            
            // ============================================
            // ROBUST FIELD NAME NORMALIZER
            // Strips aggregation prefixes and creates human-readable labels
            // ============================================
            function normalizeFieldName(name, context = {}) {
              if (!name) return name;
              
              // Check labelOverrides first (exact match)
              if (labelOverrides[name]) return labelOverrides[name];
              
              // Try variations for labelOverrides
              const nameWithParen = name.endsWith(')') ? name : name + ')';
              const nameWithoutParen = name.replace(/\)$/, '');
              if (labelOverrides[nameWithParen]) return labelOverrides[nameWithParen];
              if (labelOverrides[nameWithoutParen]) return labelOverrides[nameWithoutParen];
              
              // Strip ALL aggregation prefixes (including nested)
              let cleaned = name
                .replace(/^(AGG|SUM|AVG|CNTD?|COUNT|ATTR|MIN|MAX|MEDIAN|STDEV|VAR)\s*\(\s*/gi, '')
                .replace(/\s*\)$/g, '')
                .trim();
              
              // If still has parentheses (nested), clean again
              if (/^(AGG|SUM|AVG|CNTD?|COUNT)\s*\(/i.test(cleaned)) {
                cleaned = cleaned
                  .replace(/^(AGG|SUM|AVG|CNTD?|COUNT|ATTR|MIN|MAX)\s*\(\s*/gi, '')
                  .replace(/\s*\)$/g, '')
                  .trim();
              }
              
              // Common field name mappings for email/marketing domain
              const fieldMappings = {
                'id': 'Total Emails',
                'click-to-open': 'Click-to-Open Rate',
                'click to open': 'Click-to-Open Rate',
                'clickthrough': 'Clickthrough Rate',
                'clickthrough emails': 'Total Clicks',
                'delivered email': 'Delivered Emails',
                'delivered emails': 'Delivered Emails',
                'delivery': 'Delivery Rate',
                'open': 'Open Rate',
                'opened email': 'Opened Emails',
                'opened emails': 'Opened Emails',
                'open rate': 'Open Rate',
                'sent': 'Sent Emails',
                'sent email': 'Sent Emails',
                'sent emails': 'Sent Emails',
                'bounce': 'Bounce Rate',
                'bounced': 'Bounced Emails',
                'unsubscribe': 'Unsubscribe Rate',
                'complaint': 'Complaint Rate',
                'revenue': 'Revenue',
                'sales': 'Sales',
                'profit': 'Profit',
                'cost': 'Cost',
                'count': 'Count',
                'qty': 'Quantity',
                'quantity': 'Quantity'
              };
              
              // Check if cleaned name matches a known mapping (case-insensitive)
              const lowerCleaned = cleaned.toLowerCase();
              if (fieldMappings[lowerCleaned]) {
                return fieldMappings[lowerCleaned];
              }
              
              // Convert to Title Case and clean up
              cleaned = cleaned
                .replace(/[_-]/g, ' ')  // Replace underscores/hyphens with spaces
                .replace(/\s+/g, ' ')   // Normalize whitespace
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');
              
              // Add "Rate" suffix if context indicates it's a rate
              if (context.isRate && !cleaned.toLowerCase().includes('rate')) {
                cleaned += ' Rate';
              }
              
              return cleaned || name;
            }
            
            // Alias for backward compatibility
            const getLabel = normalizeFieldName;
            
            // Theme definitions with extended palette
            const themes = {
              professional: {
                name: 'Professional',
                bg: '#f8fafc',
                cardBg: '#ffffff',
                headerBg: 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)',
                headerText: '#ffffff',
                primary: '#1e40af',
                secondary: '#059669',
                tertiary: '#7c3aed',
                text: '#1f2937',
                textMuted: '#6b7280',
                border: '#e5e7eb',
                volumeColor: '#3b82f6',
                rateColor: '#10b981',
                kpiColors: ['#3b82f6', '#10b981', '#8b5cf6', '#f59e0b', '#ef4444', '#06b6d4'],
                pieColors: ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ef4444', '#06b6d4', '#84cc16']
              },
              modern: {
                name: 'Modern Dark',
                bg: '#0f172a',
                cardBg: '#1e293b',
                headerBg: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)',
                headerText: '#ffffff',
                primary: '#6366f1',
                secondary: '#22d3ee',
                tertiary: '#f472b6',
                text: '#f8fafc',
                textMuted: '#94a3b8',
                border: '#334155',
                volumeColor: '#818cf8',
                rateColor: '#34d399',
                kpiColors: ['#818cf8', '#34d399', '#f472b6', '#fbbf24', '#fb7185', '#22d3ee'],
                pieColors: ['#818cf8', '#34d399', '#fbbf24', '#f472b6', '#fb7185', '#22d3ee', '#a3e635']
              },
              minimal: {
                name: 'Minimal',
                bg: '#ffffff',
                cardBg: '#ffffff',
                headerBg: '#111827',
                headerText: '#ffffff',
                primary: '#111827',
                secondary: '#4b5563',
                tertiary: '#6b7280',
                text: '#111827',
                textMuted: '#9ca3af',
                border: '#f3f4f6',
                volumeColor: '#374151',
                rateColor: '#4b5563',
                kpiColors: ['#111827', '#374151', '#4b5563', '#6b7280', '#9ca3af', '#d1d5db'],
                pieColors: ['#111827', '#374151', '#4b5563', '#6b7280', '#9ca3af', '#d1d5db', '#e5e7eb']
              },
              colorful: {
                name: 'Colorful',
                bg: '#faf5ff',
                cardBg: '#ffffff',
                headerBg: 'linear-gradient(135deg, #7c3aed 0%, #ec4899 100%)',
                headerText: '#ffffff',
                primary: '#7c3aed',
                secondary: '#06b6d4',
                tertiary: '#f59e0b',
                text: '#1f2937',
                textMuted: '#6b7280',
                border: '#e9d5ff',
                volumeColor: '#8b5cf6',
                rateColor: '#14b8a6',
                kpiColors: ['#8b5cf6', '#14b8a6', '#f97316', '#ec4899', '#3b82f6', '#84cc16'],
                pieColors: ['#8b5cf6', '#14b8a6', '#f97316', '#ec4899', '#3b82f6', '#84cc16', '#fbbf24']
              },
              blue: {
                name: 'Blue',
                bg: '#eff6ff',
                cardBg: '#ffffff',
                headerBg: 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)',
                headerText: '#ffffff',
                primary: '#1e40af',
                secondary: '#3b82f6',
                tertiary: '#60a5fa',
                text: '#1f2937',
                textMuted: '#6b7280',
                border: '#e5e7eb',
                volumeColor: '#3b82f6',
                rateColor: '#10b981',
                kpiColors: ['#1e40af', '#3b82f6', '#60a5fa', '#93c5fd', '#10b981', '#059669'],
                pieColors: ['#1e40af', '#3b82f6', '#60a5fa', '#93c5fd', '#bfdbfe', '#dbeafe', '#10b981']
              },
              green: {
                name: 'Green',
                bg: '#ecfdf5',
                cardBg: '#ffffff',
                headerBg: 'linear-gradient(135deg, #065f46 0%, #10b981 100%)',
                headerText: '#ffffff',
                primary: '#065f46',
                secondary: '#10b981',
                tertiary: '#34d399',
                text: '#1f2937',
                textMuted: '#6b7280',
                border: '#d1fae5',
                volumeColor: '#10b981',
                rateColor: '#059669',
                kpiColors: ['#065f46', '#10b981', '#34d399', '#6ee7b7', '#a7f3d0', '#d1fae5'],
                pieColors: ['#065f46', '#10b981', '#34d399', '#6ee7b7', '#a7f3d0', '#d1fae5', '#ecfdf5']
              },
              purple: {
                name: 'Purple',
                bg: '#f5f3ff',
                cardBg: '#ffffff',
                headerBg: 'linear-gradient(135deg, #5b21b6 0%, #8b5cf6 100%)',
                headerText: '#ffffff',
                primary: '#5b21b6',
                secondary: '#8b5cf6',
                tertiary: '#a78bfa',
                text: '#1f2937',
                textMuted: '#6b7280',
                border: '#e9d5ff',
                volumeColor: '#8b5cf6',
                rateColor: '#7c3aed',
                kpiColors: ['#5b21b6', '#8b5cf6', '#a78bfa', '#c4b5fd', '#ddd6fe', '#ede9fe'],
                pieColors: ['#5b21b6', '#8b5cf6', '#a78bfa', '#c4b5fd', '#ddd6fe', '#ede9fe', '#f5f3ff']
              },
              corporate: {
                name: 'Corporate',
                bg: '#f9fafb',
                cardBg: '#ffffff',
                headerBg: '#1f2937',
                headerText: '#ffffff',
                primary: '#1f2937',
                secondary: '#4b5563',
                tertiary: '#2563eb',
                text: '#1f2937',
                textMuted: '#9ca3af',
                border: '#e5e7eb',
                volumeColor: '#2563eb',
                rateColor: '#4b5563',
                kpiColors: ['#1f2937', '#4b5563', '#2563eb', '#6b7280', '#9ca3af', '#d1d5db'],
                pieColors: ['#1f2937', '#4b5563', '#2563eb', '#6b7280', '#9ca3af', '#d1d5db', '#e5e7eb']
              }
            };
            let t = themes[theme] || themes.professional;
            
            // Apply custom colors if provided
            const customColors = args.customColors;
            if (customColors && customColors.length > 0) {
              const primary = customColors[0];
              const secondary = customColors[1] || primary;
              const tertiary = customColors[2] || secondary;
              
              // Generate color variations for KPIs and charts
              const generateColorVariations = (baseColor, count = 6) => {
                // Simple color variation: create lighter/darker shades
                const variations = [baseColor];
                for (let i = 1; i < count; i++) {
                  // Alternate between different custom colors and shades
                  if (customColors[i]) {
                    variations.push(customColors[i]);
                  } else {
                    // Create a shade by adjusting opacity (will be handled in rendering)
                    variations.push(baseColor);
                  }
                }
                return variations;
              };
              
              // Override theme colors with custom colors
              t = {
                ...t,
                primary: primary,
                secondary: secondary,
                tertiary: tertiary,
                volumeColor: primary,
                rateColor: secondary,
                headerBg: customColors.length >= 2 
                  ? `linear-gradient(135deg, ${primary} 0%, ${secondary} 100%)`
                  : primary,
                kpiColors: customColors.length >= 2 
                  ? customColors.slice(0, 6).concat(t.kpiColors.slice(customColors.length)) 
                  : [primary, secondary, tertiary, primary, secondary, tertiary],
                pieColors: customColors.length >= 2 
                  ? customColors.slice(0, 7).concat(t.pieColors.slice(customColors.length))
                  : [primary, secondary, tertiary, primary, secondary, tertiary, primary]
              };
              
              console.log('[DashAgent] Applied custom colors:', customColors);
            }
            
            // Get worksheets to analyze
            const worksheetsToAnalyze = worksheetName 
              ? dashboard.worksheets.filter(ws => ws.name === worksheetName)
              : dashboard.worksheets;
            
            if (worksheetsToAnalyze.length === 0) {
              return `Worksheet "${worksheetName}" not found. Available: ${dashboard.worksheets.map(w => w.name).join(', ')}`;
            }
            
            // Analyze all worksheet data
            const analyzedData = [];
            
            for (const ws of worksheetsToAnalyze) {
              try {
                const summary = await ws.getSummaryDataAsync({ maxRows: 1000 });
                const columns = summary.columns;
                const rows = summary.data;
                
                if (rows.length === 0) continue;
                
                // Categorize columns
                const measures = [];
                const dimensions = [];
                const dateFields = [];
                
                for (let i = 0; i < columns.length; i++) {
                  const col = columns[i];
                  const name = col.fieldName;
                  const dtype = col.dataType;
                  
                  // Skip Tableau meta fields
                  if (['Measure Names', 'Measure Values'].includes(name)) continue;
                  
                  if (['int', 'float', 'number'].includes(dtype)) {
                    // Analyze the measure
                    let sum = 0, min = Infinity, max = -Infinity, count = 0;
                    const values = [];
                    
                    for (const row of rows) {
                      const val = parseFloat(row[i].value) || 0;
                      values.push(val);
                      sum += val;
                      min = Math.min(min, val);
                      max = Math.max(max, val);
                      count++;
                    }
                    
                    const avg = count > 0 ? sum / count : 0;
                    const isRate = name.toLowerCase().match(/rate|percent|%|ratio|pct|margin|share/) || (max <= 1 && min >= 0 && avg > 0);
                    const isCount = name.toLowerCase().match(/count|total|sum|volume|quantity|num|number|sales|revenue|profit|amount/);
                    
                    measures.push({
                      name,
                      index: i,
                      sum,
                      avg,
                      min,
                      max,
                      count,
                      values,
                      isRate: !!isRate,
                      isCount: !!isCount,
                      type: isRate ? 'rate' : (isCount ? 'volume' : 'value')
                    });
                  } else if (dtype === 'string') {
                    // Check unique values
                    const uniqueVals = new Set();
                    const sampleValues = [];
                    for (const row of rows) {
                      const val = row[i].formattedValue || row[i].value;
                      uniqueVals.add(val);
                      if (sampleValues.length < 5) sampleValues.push(val);
                    }
                    
                    // Check if this string field is actually a date field
                    // Look for date-like field names or date-parseable values
                    const isDateField = name.toLowerCase().match(/date|time|day|week|month|year|period|quarter/) ||
                      (sampleValues.length > 0 && sampleValues.every(v => {
                        if (!v) return false;
                        // Check for common date formats
                        const datePatterns = [
                          /^\d{4}-\d{2}-\d{2}/, // 2024-01-15
                          /^\d{1,2}\/\d{1,2}\/\d{2,4}/, // 1/15/2024 or 01/15/24
                          /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i, // Jan 2024
                          /^\d{4}$/, // 2024 (year only)
                          /^Q[1-4]\s*\d{4}/i // Q1 2024
                        ];
                        return datePatterns.some(p => p.test(v)) || !isNaN(Date.parse(v));
                      }));
                    
                    if (isDateField) {
                      dateFields.push({ name, index: i, values: [...uniqueVals] });
                    } else if (uniqueVals.size > 1 && uniqueVals.size <= 100) {
                      dimensions.push({
                        name,
                        index: i,
                        cardinality: uniqueVals.size,
                        values: [...uniqueVals].slice(0, maxItems)
                      });
                    }
                  } else if (dtype === 'date' || dtype === 'datetime') {
                    dateFields.push({ name, index: i });
                  }
                }
                
                // Select best dimension for bars (prefer 3-15 unique values)
                const bestDim = focusDimension 
                  ? dimensions.find(d => d.name.toLowerCase().includes(focusDimension.toLowerCase()))
                  : dimensions.find(d => d.cardinality >= 3 && d.cardinality <= 15) || dimensions[0];
                
                // Select best dimension for donut (prefer 3-7 unique values)
                const donutDim = dimensions.find(d => d.cardinality >= 2 && d.cardinality <= 7) || bestDim;
                
                // Filter measures if focusMetrics specified
                let selectedMeasures = measures;
                if (focusMetrics.length > 0) {
                  selectedMeasures = measures.filter(m => 
                    focusMetrics.some(fm => m.name.toLowerCase().includes(fm.toLowerCase()))
                  );
                  if (selectedMeasures.length === 0) selectedMeasures = measures;
                }
                selectedMeasures = selectedMeasures.slice(0, maxMetrics);
                
                // Build breakdown data for bar charts
                const breakdowns = [];
                if (bestDim) {
                  for (const measure of selectedMeasures) {
                    const agg = {};
                    const counts = {};
                    
                    for (const row of rows) {
                      const dimVal = row[bestDim.index].formattedValue || row[bestDim.index].value || 'Unknown';
                      const measureVal = parseFloat(row[measure.index].value) || 0;
                      
                      if (!agg[dimVal]) {
                        agg[dimVal] = 0;
                        counts[dimVal] = 0;
                      }
                      agg[dimVal] += measureVal;
                      counts[dimVal]++;
                    }
                    
                    const data = Object.entries(agg).map(([label, sum]) => ({
                      label,
                      value: measure.isRate ? (sum / counts[label]) : sum,
                      count: counts[label]
                    }));
                    
                    data.sort((a, b) => b.value - a.value);
                    
                    breakdowns.push({
                      measure,
                      dimension: bestDim.name,
                      data: data.slice(0, maxItems)
                    });
                  }
                }
                
                // Build donut chart data (for composition view)
                let donutData = null;
                if (donutDim && selectedMeasures.length > 0) {
                  const volumeMeasure = selectedMeasures.find(m => !m.isRate) || selectedMeasures[0];
                  const agg = {};
                  
                  for (const row of rows) {
                    const dimVal = row[donutDim.index].formattedValue || row[donutDim.index].value || 'Unknown';
                    const measureVal = parseFloat(row[volumeMeasure.index].value) || 0;
                    
                    if (!agg[dimVal]) agg[dimVal] = 0;
                    agg[dimVal] += measureVal;
                  }
                  
                  const data = Object.entries(agg).map(([label, value]) => ({ label, value }));
                  data.sort((a, b) => b.value - a.value);
                  
                  donutData = {
                    measure: volumeMeasure,
                    dimension: donutDim.name,
                    data: data.slice(0, 7) // Max 7 slices
                  };
                }
                
                // Build timeline data if we have date fields
                let timelineData = null;
                if (dateFields.length > 0 && selectedMeasures.length > 0) {
                  const dateField = dateFields[0]; // Use first date field
                  const volumeMeasure = volumeMeasures[0] || selectedMeasures[0];
                  
                  // Aggregate measure values by date (grouping to month for clarity)
                  const dateAgg = {};
                  
                  for (const row of rows) {
                    // Try both formattedValue and value for date
                    const dateVal = row[dateField.index].formattedValue || row[dateField.index].value;
                    if (!dateVal) continue;
                    
                    // Try to parse the date - handle multiple formats
                    let date = new Date(dateVal);
                    
                    // If standard parsing fails, try common formats
                    if (isNaN(date.getTime())) {
                      // Try MM/DD/YYYY format
                      const parts = dateVal.split(/[\/\-]/);
                      if (parts.length === 3) {
                        // Assume MM/DD/YYYY or YYYY-MM-DD
                        if (parts[0].length === 4) {
                          date = new Date(parts[0], parts[1] - 1, parts[2]);
                        } else {
                          date = new Date(parts[2], parts[0] - 1, parts[1]);
                        }
                      }
                    }
                    
                    // If still invalid, try to extract year-month from formatted value (e.g., "Jan 2024")
                    if (isNaN(date.getTime())) {
                      const monthMatch = dateVal.match(/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s*(\d{4})/i);
                      if (monthMatch) {
                        const months = { jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5, jul: 6, aug: 7, sep: 8, oct: 9, nov: 10, dec: 11 };
                        date = new Date(parseInt(monthMatch[2]), months[monthMatch[1].toLowerCase().substring(0, 3)], 1);
                      }
                    }
                    
                    if (isNaN(date.getTime())) continue;
                    
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    const displayLabel = date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                    const measureVal = parseFloat(row[volumeMeasure.index].value) || 0;
                    
                    if (!dateAgg[monthKey]) {
                      dateAgg[monthKey] = { sum: 0, count: 0, label: displayLabel };
                    }
                    dateAgg[monthKey].sum += measureVal;
                    dateAgg[monthKey].count++;
                  }
                  
                  // Convert to sorted array
                  const timelinePoints = Object.entries(dateAgg)
                    .sort((a, b) => a[0].localeCompare(b[0]))
                    .map(([key, data]) => ({
                      date: key,
                      label: data.label,
                      value: volumeMeasure.isRate ? (data.sum / data.count) : data.sum
                    }));
                  
                  // Only create timeline if we have multiple time points
                  if (timelinePoints.length >= 2) {
                    timelineData = {
                      measure: volumeMeasure,
                      dateField: dateField.name,
                      data: timelinePoints
                    };
                  }
                }
                
                analyzedData.push({
                  worksheet: ws.name,
                  measures: selectedMeasures,
                  dimensions,
                  bestDimension: bestDim,
                  donutDimension: donutDim,
                  breakdowns,
                  donutData,
                  timelineData,
                  rowCount: rows.length,
                  hasDateField: dateFields.length > 0,
                  dateFields
                });
                
                // Debug logging for timeline issues
                console.log('[DashAgent] build_dashboard data analysis:', {
                  worksheet: ws.name,
                  rowCount: rows.length,
                  dateFieldsFound: dateFields.length,
                  dateFieldNames: dateFields.map(d => d.name),
                  dimensionsFound: dimensions.length,
                  dimensionNames: dimensions.map(d => d.name),
                  hasTimelineData: !!timelineData,
                  timelinePoints: timelineData?.data?.length || 0
                });
                
              } catch (e) {
                console.error('Error analyzing worksheet:', ws.name, e);
              }
            }
            
            if (analyzedData.length === 0) {
              return 'No data available to create dashboard. Please ensure worksheets have data.';
            }
            
            // ============================================
            // POPULATE STORY CACHE from build_dashboard extraction
            // This allows transform_to_story to reuse the data
            // ============================================
            try {
              const cacheData = storyCache.extractedData;
              
              // Only update cache if it's stale or empty
              if (storyCache.isStale || cacheData.worksheetSummaries.length === 0) {
                console.log('[Cache] Populating storyCache from build_dashboard data');
                
                // Build worksheet summaries
                cacheData.worksheetSummaries = analyzedData.map(d => ({
                  name: d.worksheet,
                  rowCount: d.rowCount,
                  dimensions: d.dimensions.map(dim => dim.name),
                  measures: d.measures.map(m => m.name)
                }));
                
                // Build statistics from measures
                for (const wsData of analyzedData) {
                  for (const measure of wsData.measures) {
                    const measureName = measure.name
                      .replace(/^(AGG|SUM|AVG|CNTD?|COUNT|ATTR|MIN|MAX)\s*\(\s*/gi, '')
                      .replace(/\s*\)$/g, '')
                      .trim();
                    
                    cacheData.statistics[measureName] = {
                      count: measure.count,
                      sum: measure.sum,
                      avg: measure.avg,
                      min: measure.min,
                      max: measure.max,
                      formattedAvg: formatAsPercentage(measure.avg, measureName),
                      formattedMax: formatAsPercentage(measure.max, measureName),
                      formattedMin: formatAsPercentage(measure.min, measureName)
                    };
                    
                    // Track totals for volume metrics
                    if (measure.isCount || /count|total|sum|sends|emails/i.test(measureName)) {
                      cacheData.totals[measureName] = measure.sum;
                    }
                  }
                  
                  // Build dimension breakdowns from existing breakdowns
                  for (const breakdown of wsData.breakdowns || []) {
                    const dimName = breakdown.dimension;
                    if (!cacheData.dimensionBreakdowns[dimName]) {
                      cacheData.dimensionBreakdowns[dimName] = [];
                    }
                    
                    // Add items to breakdown
                    for (const item of breakdown.data || []) {
                      const existing = cacheData.dimensionBreakdowns[dimName].find(x => x.name === item.label);
                      if (existing) {
                        existing.metrics[breakdown.measure] = {
                          value: item.value,
                          formatted: formatAsPercentage(item.value, breakdown.measure)
                        };
                      } else {
                        cacheData.dimensionBreakdowns[dimName].push({
                          name: item.label,
                          metrics: {
                            [breakdown.measure]: {
                              value: item.value,
                              formatted: formatAsPercentage(item.value, breakdown.measure)
                            }
                          }
                        });
                      }
                    }
                  }
                  
                  // Build rankings from breakdowns
                  for (const breakdown of wsData.breakdowns || []) {
                    if (breakdown.data && breakdown.data.length > 0) {
                      const sorted = [...breakdown.data].sort((a, b) => b.value - a.value);
                      const rankingKey = `${breakdown.measure} by ${breakdown.dimension}`;
                      cacheData.rankings[rankingKey] = sorted.map((item, idx) => ({
                        rank: idx + 1,
                        name: item.label,
                        value: item.value,
                        formatted: formatAsPercentage(item.value, breakdown.measure)
                      }));
                      
                      // Track top performers
                      if (!cacheData.topPerformers[breakdown.dimension]) {
                        cacheData.topPerformers[breakdown.dimension] = {};
                      }
                      cacheData.topPerformers[breakdown.dimension][breakdown.measure] = {
                        name: sorted[0].label,
                        value: sorted[0].value,
                        formatted: formatAsPercentage(sorted[0].value, breakdown.measure)
                      };
                    }
                  }
                }
                
                // Update cache key
                storyCache.cacheKey = {
                  worksheetNames: analyzedData.map(d => d.worksheet),
                  dataHash: generateDataHash(cacheData),
                  rowCount: analyzedData.reduce((sum, d) => sum + d.rowCount, 0),
                  filterState: '',
                  timestamp: Date.now()
                };
                storyCache.isStale = false;
                storyCache.staleReason = null;
                
                console.log('[Cache] StoryCache populated:', {
                  worksheets: cacheData.worksheetSummaries.length,
                  rankings: Object.keys(cacheData.rankings).length,
                  statistics: Object.keys(cacheData.statistics).length
                });
              }
            } catch (cacheError) {
              console.error('[Cache] Error populating storyCache:', cacheError);
              // Non-fatal, continue with dashboard building
            }
            
            const wsData = analyzedData[0];
            const allMeasures = analyzedData.flatMap(d => d.measures);
            const uniqueMeasures = allMeasures.filter((m, i, arr) => 
              arr.findIndex(x => x.name === m.name) === i
            ).slice(0, maxMetrics);
            
            const rateMeasures = uniqueMeasures.filter(m => m.isRate);
            const volumeMeasures = uniqueMeasures.filter(m => !m.isRate);
            
            // ============================================
            // DESIGN PLAN - Describe what we're building
            // ============================================
            const designPlan = {
              title: dashboardTitle || `${wsData.worksheet} Performance Dashboard`,
              theme: t.name,
              colorStrategy: `Volume metrics: ${theme === 'modern' ? 'Indigo' : 'Blue'} tones | Rate metrics: ${theme === 'modern' ? 'Teal' : 'Green'} tones`,
              layout: {
                structure: 'Header → KPIs → Charts Grid → Footer',
                grid: `${Math.min(uniqueMeasures.length, 4)} KPI cards in top row`,
                charts: []
              },
              chartSelections: []
            };
            
            // Decide chart types for each metric
            for (let i = 0; i < Math.min(wsData.breakdowns.length, 4); i++) {
              const breakdown = wsData.breakdowns[i];
              let chartType, reason;
              
              if (breakdown.measure.isRate) {
                chartType = 'Horizontal Bar Chart';
                reason = 'Rate metric - bars show comparison across categories';
              } else if (breakdown.data.length <= 5) {
                chartType = 'Horizontal Bar Chart';
                reason = 'Few categories - bars are clear and direct';
              } else {
                chartType = 'Horizontal Bar Chart';
                reason = 'Volume metric - bars effectively show ranking';
              }
              
              designPlan.chartSelections.push({
                metric: breakdown.measure.name.replace(/^SUM\(|\)$/g, '').replace(/^AVG\(|\)$/g, ''),
                dimension: breakdown.dimension,
                chartType,
                reason,
                color: breakdown.measure.isRate ? 'Green (rate)' : 'Blue (volume)'
              });
            }
            
            // Add donut chart to plan if we have composition data
            if (wsData.donutData) {
              designPlan.chartSelections.push({
                metric: wsData.donutData.measure.name.replace(/^SUM\(|\)$/g, ''),
                dimension: wsData.donutData.dimension,
                chartType: 'Donut Chart',
                reason: 'Composition/share view with few categories (≤7)',
                color: 'Multi-color palette for distinct segments'
              });
            }
            
            // ============================================
            // BUILD THE HTML DASHBOARD (with LLM fallback)
            // ============================================
            let html = '';
            let usedFallback = false;
            
            try {
            const title = designPlan.title;
            const subtitle = `${wsData.rowCount.toLocaleString()} records · ${uniqueMeasures.length} metrics · ${wsData.dimensions.length} dimensions`;
            
            html = `
<div class="smart-dashboard-v2" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: ${t.bg}; min-height: 100%;">
  
  <!-- Dashboard Header -->
  <div style="background: ${t.headerBg}; padding: 28px 32px; margin-bottom: 24px;">
    <h1 style="margin: 0 0 8px 0; font-size: 26px; font-weight: 700; color: ${t.headerText};">
      ${title}
    </h1>
    <p style="margin: 0; font-size: 14px; color: rgba(255,255,255,0.8);">
      ${subtitle}
    </p>
    <div style="margin-top: 12px; display: flex; gap: 16px; flex-wrap: wrap;">
      <span style="font-size: 11px; background: rgba(255,255,255,0.2); padding: 4px 10px; border-radius: 12px; color: ${t.headerText};">
        Theme: ${t.name}
      </span>
      <span style="font-size: 11px; background: rgba(255,255,255,0.2); padding: 4px 10px; border-radius: 12px; color: ${t.headerText};">
        Data: ${wsData.worksheet}
      </span>
      <span style="font-size: 11px; background: rgba(255,255,255,0.2); padding: 4px 10px; border-radius: 12px; color: ${t.headerText};">
        Updated: ${new Date().toLocaleTimeString()}
      </span>
    </div>
  </div>

  <div style="padding: 0 24px 24px 24px;">

  <!-- KPI Cards Section -->
  <div style="margin-bottom: 28px;">
    <h2 style="margin: 0 0 16px 0; font-size: 14px; font-weight: 600; color: ${t.textMuted}; text-transform: uppercase; letter-spacing: 1px;">
      Key Performance Indicators
    </h2>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px;">`;
            
            // Generate KPI cards
            for (let i = 0; i < uniqueMeasures.length; i++) {
              const m = uniqueMeasures[i];
              const color = m.isRate ? t.rateColor : t.kpiColors[i % t.kpiColors.length];
              // Use normalizeFieldName for consistent labeling
              let displayLabel = normalizeFieldName(m.name, { isRate: m.isRate });
              let displayValue;
              if (m.isRate) {
                displayValue = (m.avg * 100).toFixed(1) + '%';
              } else {
                displayValue = m.sum >= 1000000 
                  ? (m.sum / 1000000).toFixed(1) + 'M'
                  : m.sum >= 1000 
                    ? (m.sum / 1000).toFixed(1) + 'K'
                    : m.sum.toLocaleString(undefined, { maximumFractionDigits: 0 });
              }
              const sparkValues = m.values.slice(0, 20);
              const sparkMax = Math.max(...sparkValues);
              const sparkMin = Math.min(...sparkValues);
              const sparkRange = sparkMax - sparkMin || 1;
              const sparkPoints = sparkValues.map((v, idx) => {
                const x = (idx / (sparkValues.length - 1)) * 60;
                const y = 20 - ((v - sparkMin) / sparkRange) * 18;
                return `${x},${y}`;
              }).join(' ');
              html += `
      <div style="background: ${t.cardBg}; border-radius: 12px; padding: 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border-top: 3px solid ${color};">
        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
          <div>
            <div style="font-size: 11px; color: ${t.textMuted}; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">${displayLabel}</div>
            <div style="font-size: 32px; font-weight: 700; color: ${t.text}; line-height: 1;">${displayValue}</div>
            <div style="font-size: 11px; color: ${t.textMuted}; margin-top: 6px;">
              ${m.isRate ? `Range: ${(m.min * 100).toFixed(0)}% - ${(m.max * 100).toFixed(0)}%` : `${m.count.toLocaleString()} records`}
            </div>
          </div>
          <svg width="60" height="24" style="opacity: 0.6;">
            <polyline points="${sparkPoints}" fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
      </div>`;
            }
            
            html += `
    </div>
  </div>`;
            
            // Debug logging to understand data structure
            console.log('[DashAgent] Dashboard Data Analysis:', {
              worksheet: wsData.worksheet,
              measuresCount: wsData.measures.length,
              dimensionsCount: wsData.dimensions.length,
              breakdownsCount: wsData.breakdowns.length,
              hasDonutData: !!wsData.donutData,
              dimensions: wsData.dimensions.map(d => ({ name: d.name, cardinality: d.cardinality })),
              bestDimension: wsData.bestDimension?.name,
              measures: wsData.measures.map(m => m.name)
            });
            
            // Charts Section
            const hasDonut = wsData.donutData && wsData.donutData.data.length >= 2;
            const numBarCharts = Math.min(wsData.breakdowns.length, hasDonut ? 3 : 4);
            
            if (numBarCharts > 0 || hasDonut) {
              html += `

  <!-- Charts Section -->
  <div style="margin-bottom: 28px;">
    <h2 style="margin: 0 0 16px 0; font-size: 14px; font-weight: 600; color: ${t.textMuted}; text-transform: uppercase; letter-spacing: 1px;">
      Detailed Analysis
    </h2>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px;">`;
              
              // Bar Charts
              for (let bi = 0; bi < numBarCharts; bi++) {
                const breakdown = wsData.breakdowns[bi];
                const measure = breakdown.measure;
                const data = breakdown.data;
                const maxVal = Math.max(...data.map(d => d.value));
                const total = data.reduce((s, d) => s + d.value, 0);
                const chartColor = measure.isRate ? t.rateColor : t.volumeColor;
                // Use normalizeFieldName for consistent chart titles
                const metricName = normalizeFieldName(measure.name, { isRate: measure.isRate });
                html += `
      <div style="background: ${t.cardBg}; border-radius: 12px; padding: 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.08);">
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px;">
          <div>
            <h3 style="margin: 0 0 4px 0; font-size: 16px; font-weight: 600; color: ${t.text};">
              ${metricName}
            </h3>
            <p style="margin: 0; font-size: 12px; color: ${t.textMuted};">
              by ${labelOverrides[breakdown.dimension] || breakdown.dimension} · ${measure.isRate ? 'Avg' : 'Total'} · Top ${data.length}
            </p>
          </div>
          <div style="width: 10px; height: 10px; border-radius: 50%; background: ${chartColor};"></div>
        </div>
        <div style="display: flex; flex-direction: column; gap: 8px;">`;
                
                for (const item of data) {
                  const pct = maxVal > 0 ? (item.value / maxVal) * 100 : 0;
                  const displayVal = measure.isRate 
                    ? (item.value * 100).toFixed(1) + '%'
                    : item.value >= 1000 
                      ? (item.value / 1000).toFixed(1) + 'K'
                      : item.value.toLocaleString(undefined, { maximumFractionDigits: 0 });
                  
                  html += `
          <div style="display: flex; align-items: center; gap: 10px;">
            <div style="width: 80px; font-size: 12px; color: ${t.text}; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${item.label}">${item.label}</div>
            <div style="flex: 1; height: 20px; background: ${t.border}; border-radius: 4px; overflow: hidden;">
              <div style="width: ${pct}%; height: 100%; background: ${chartColor}; border-radius: 4px;"></div>
            </div>
            <div style="width: 55px; font-size: 12px; font-weight: 600; color: ${t.text}; text-align: right;">${displayVal}</div>
          </div>`;
                }
                
                html += `
        </div>
        
        <div style="margin-top: 14px; padding-top: 10px; border-top: 1px solid ${t.border}; font-size: 11px; color: ${t.textMuted};">
          ${measure.isRate ? 'Average across categories' : `Total: ${total >= 1000 ? (total / 1000).toFixed(1) + 'K' : total.toLocaleString()}`}
        </div>
      </div>`;
              }
              
              // Donut Chart
              if (hasDonut) {
                const donut = wsData.donutData;
                
                // Limit to top 4 + "Other" for cleaner visualization
                let chartData = [...donut.data];
                if (chartData.length > 4) {
                  const top4 = chartData.slice(0, 4);
                  const otherTotal = chartData.slice(4).reduce((sum, item) => sum + item.value, 0);
                  chartData = [...top4, { label: 'Other', value: otherTotal }];
                }
                
                const total = chartData.reduce((s, d) => s + d.value, 0);
                // Use normalizeFieldName for consistent donut title
                const metricName = normalizeFieldName(donut.measure.name, { isRate: donut.measure.isRate });
                // Calculate donut segments
                let cumulativePercent = 0;
                const segments = chartData.map((item, idx) => {
                  const percent = total > 0 ? (item.value / total) * 100 : 0;
                  const startPercent = cumulativePercent;
                  cumulativePercent += percent;
                  return {
                    ...item,
                    percent,
                    startPercent,
                    color: t.pieColors[idx % t.pieColors.length]
                  };
                });
                // Build SVG donut
                const size = 140;
                const center = size / 2;
                const radius = 55;
                const innerRadius = 35;
                let donutPaths = '';
                for (const seg of segments) {
                  const startAngle = (seg.startPercent / 100) * 360 - 90;
                  const endAngle = ((seg.startPercent + seg.percent) / 100) * 360 - 90;
                  const startRad = (startAngle * Math.PI) / 180;
                  const endRad = (endAngle * Math.PI) / 180;
                  const x1 = center + radius * Math.cos(startRad);
                  const y1 = center + radius * Math.sin(startRad);
                  const x2 = center + radius * Math.cos(endRad);
                  const y2 = center + radius * Math.sin(endRad);
                  const x3 = center + innerRadius * Math.cos(endRad);
                  const y3 = center + innerRadius * Math.sin(endRad);
                  const x4 = center + innerRadius * Math.cos(startRad);
                  const y4 = center + innerRadius * Math.sin(startRad);
                  const largeArc = seg.percent > 50 ? 1 : 0;
                  const path = `M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} L ${x3} ${y3} A ${innerRadius} ${innerRadius} 0 ${largeArc} 0 ${x4} ${y4} Z`;
                  donutPaths += `<path d="${path}" fill="${seg.color}" stroke="${t.cardBg}" stroke-width="2"/>`;
                }
                html += `
      <div style="background: ${t.cardBg}; border-radius: 12px; padding: 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.08);">
        <div style="margin-bottom: 16px;">
          <h3 style="margin: 0 0 4px 0; font-size: 16px; font-weight: 600; color: ${t.text};">
            ${metricName} Composition
          </h3>
          <p style="margin: 0; font-size: 12px; color: ${t.textMuted};">
            by ${labelOverrides[donut.dimension] || donut.dimension} · Share of total
          </p>
        </div>
        <div style="display: flex; align-items: center; gap: 20px;">
          <div style="position: relative;">
            <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
              ${donutPaths}
            </svg>
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
              <div style="font-size: 18px; font-weight: 700; color: ${t.text};">${total >= 1000 ? (total / 1000).toFixed(1) + 'K' : total.toLocaleString()}</div>
              <div style="font-size: 10px; color: ${t.textMuted};">Total</div>
            </div>
          </div>
          <div style="flex: 1; display: flex; flex-direction: column; gap: 6px;">`;
                for (const seg of segments) {
                  html += `
            <div style="display: flex; align-items: center; gap: 8px;">
              <div style="width: 10px; height: 10px; border-radius: 2px; background: ${seg.color};"></div>
              <div style="flex: 1; font-size: 12px; color: ${t.text}; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${labelOverrides[seg.label] || seg.label}</div>
              <div style="font-size: 12px; font-weight: 600; color: ${t.text};">${seg.percent.toFixed(1)}%</div>
            </div>`;
                }
                html += `
          </div>
        </div>
      </div>`;
              }
              
              // Timeline Chart (if we have date data with multiple points)
              if (wsData.timelineData && wsData.timelineData.data.length >= 2) {
                const timeline = wsData.timelineData;
                const timeData = timeline.data;
                const maxVal = Math.max(...timeData.map(d => d.value));
                const minVal = Math.min(...timeData.map(d => d.value));
                const range = maxVal - minVal || 1;
                
                const chartWidth = 600;
                const chartHeight = 180;
                const padding = { top: 20, right: 20, bottom: 40, left: 20 };
                const plotWidth = chartWidth - padding.left - padding.right;
                const plotHeight = chartHeight - padding.top - padding.bottom;
                
                // Build SVG path for line chart
                let linePath = '';
                let areaPath = '';
                const points = [];
                
                timeData.forEach((d, idx) => {
                  const x = padding.left + (idx / (timeData.length - 1)) * plotWidth;
                  const y = padding.top + (1 - (d.value - minVal) / range) * plotHeight;
                  points.push({ x, y, ...d });
                  
                  if (idx === 0) {
                    linePath = `M ${x} ${y}`;
                    areaPath = `M ${padding.left} ${chartHeight - padding.bottom}`;
                  }
                  linePath += ` L ${x} ${y}`;
                  areaPath += ` L ${x} ${y}`;
                });
                areaPath += ` L ${padding.left + plotWidth} ${chartHeight - padding.bottom} Z`;
                
                const timelineColor = timeline.measure.isRate ? t.rateColor : t.volumeColor;
                const metricName = normalizeFieldName(timeline.measure.name, { isRate: timeline.measure.isRate });
                
                html += `
      <div style="background: ${t.cardBg}; border-radius: 12px; padding: 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); grid-column: 1 / -1;">
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px;">
          <div>
            <h3 style="margin: 0 0 4px 0; font-size: 16px; font-weight: 600; color: ${t.text};">
              ${metricName} Over Time
            </h3>
            <p style="margin: 0; font-size: 12px; color: ${t.textMuted};">
              ${timeData.length} months · ${timeData[0].label} to ${timeData[timeData.length - 1].label}
            </p>
          </div>
          <div style="width: 10px; height: 10px; border-radius: 50%; background: ${timelineColor};"></div>
        </div>
        <svg width="100%" viewBox="0 0 ${chartWidth} ${chartHeight}" style="display: block; max-width: 100%;">
          <!-- Area fill -->
          <path d="${areaPath}" fill="${timelineColor}" fill-opacity="0.1" />
          <!-- Line -->
          <path d="${linePath}" fill="none" stroke="${timelineColor}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
          <!-- Data points -->
          ${points.map(p => `<circle cx="${p.x}" cy="${p.y}" r="4" fill="${timelineColor}" stroke="${t.cardBg}" stroke-width="2"/>`).join('')}
          <!-- X-axis labels (show first, middle, last) -->
          <text x="${padding.left}" y="${chartHeight - 10}" font-size="10" fill="${t.textMuted}" text-anchor="start">${timeData[0].label}</text>
          <text x="${chartWidth / 2}" y="${chartHeight - 10}" font-size="10" fill="${t.textMuted}" text-anchor="middle">${timeData[Math.floor(timeData.length / 2)].label}</text>
          <text x="${chartWidth - padding.right}" y="${chartHeight - 10}" font-size="10" fill="${t.textMuted}" text-anchor="end">${timeData[timeData.length - 1].label}</text>
          <!-- Min/Max annotations -->
          <text x="${padding.left + 5}" y="${padding.top + 12}" font-size="10" fill="${t.textMuted}">
            Max: ${timeline.measure.isRate ? (maxVal * 100).toFixed(1) + '%' : maxVal >= 1000 ? (maxVal / 1000).toFixed(1) + 'K' : maxVal.toLocaleString()}
          </text>
        </svg>
      </div>`;
              }
              
              html += `
    </div>
  </div>`;
            } else {
              // Fallback when no breakdown charts can be created
              // Create charts from measures over row indices as a simple trend
              console.log('[DashAgent] No dimension found for bar charts. Creating measure trend charts instead.');
              
              html += `

  <!-- Measure Trends Section (Fallback) -->
  <div style="margin-bottom: 28px;">
    <h2 style="margin: 0 0 16px 0; font-size: 14px; font-weight: 600; color: ${t.textMuted}; text-transform: uppercase; letter-spacing: 1px;">
      Metric Trends
    </h2>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px;">`;
              
              // Create sparkline/area charts for each measure
              for (let mi = 0; mi < Math.min(uniqueMeasures.length, 4); mi++) {
                const measure = uniqueMeasures[mi];
                const values = measure.values.slice(0, 50);
                const maxVal = Math.max(...values);
                const minVal = Math.min(...values);
                const range = maxVal - minVal || 1;
                
                // Build SVG path for area chart
                const chartWidth = 280;
                const chartHeight = 100;
                const padding = 10;
                
                let pathD = '';
                let areaD = '';
                
                values.forEach((v, idx) => {
                  const x = padding + (idx / (values.length - 1)) * (chartWidth - 2 * padding);
                  const y = padding + (1 - (v - minVal) / range) * (chartHeight - 2 * padding);
                  
                  if (idx === 0) {
                    pathD = `M ${x} ${y}`;
                    areaD = `M ${x} ${chartHeight - padding}`;
                  }
                  pathD += ` L ${x} ${y}`;
                  areaD += ` L ${x} ${y}`;
                });
                
                areaD += ` L ${padding + chartWidth - 2 * padding} ${chartHeight - padding} Z`;
                
                const chartColor = measure.isRate ? t.rateColor : t.volumeColor;
                const metricName = labelOverrides[measure.name]
                  || measure.name.replace(/^(SUM|AVG|CNTD?|AGG)\(|\)$/gi, '').trim();
                
                const displayAvg = measure.isRate 
                  ? (measure.avg * 100).toFixed(1) + '%'
                  : measure.avg >= 1000 
                    ? (measure.avg / 1000).toFixed(1) + 'K'
                    : measure.avg.toFixed(0);
                
                html += `
      <div style="background: ${t.cardBg}; border-radius: 12px; padding: 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.08);">
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
          <div>
            <h3 style="margin: 0 0 4px 0; font-size: 16px; font-weight: 600; color: ${t.text};">
              ${metricName}
            </h3>
            <p style="margin: 0; font-size: 12px; color: ${t.textMuted};">
              Trend over ${values.length} data points · Avg: ${displayAvg}
            </p>
          </div>
          <div style="width: 10px; height: 10px; border-radius: 50%; background: ${chartColor};"></div>
        </div>
        <svg width="${chartWidth}" height="${chartHeight}" style="display: block;">
          <!-- Area fill -->
          <path d="${areaD}" fill="${chartColor}" fill-opacity="0.15" />
          <!-- Line -->
          <path d="${pathD}" fill="none" stroke="${chartColor}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
          <!-- Min/Max labels -->
          <text x="${padding}" y="${chartHeight - padding + 12}" font-size="10" fill="${t.textMuted}">
            Min: ${measure.isRate ? (minVal * 100).toFixed(1) + '%' : minVal.toLocaleString()}
          </text>
          <text x="${chartWidth - padding}" y="${chartHeight - padding + 12}" font-size="10" fill="${t.textMuted}" text-anchor="end">
            Max: ${measure.isRate ? (maxVal * 100).toFixed(1) + '%' : maxVal.toLocaleString()}
          </text>
        </svg>
      </div>`;
              }
              
              html += `
    </div>
    <div style="margin-top: 12px; padding: 12px; background: ${t.border}; border-radius: 8px; font-size: 12px; color: ${t.textMuted};">
      <strong>Note:</strong> No categorical dimension found for bar charts. Showing measure trends instead. 
      To enable bar charts, ensure your data has a string dimension (e.g., Campaign Name, Region, Category) with 3-15 unique values.
    </div>
  </div>`;
            }
            
            // AI-Generated Insights Section
            const insights = [];
            
            // Generate insights based on data patterns
            if (uniqueMeasures.length > 0) {
              // Top performer insight
              if (wsData.breakdowns.length > 0) {
                const topBreakdown = wsData.breakdowns[0];
                if (topBreakdown.data.length > 0) {
                  const topItem = topBreakdown.data[0];
                  const metricLabel = normalizeFieldName(topBreakdown.measure.name, { isRate: topBreakdown.measure.isRate });
                  const dimLabel = topBreakdown.dimension;
                  const displayVal = topBreakdown.measure.isRate 
                    ? (topItem.value * 100).toFixed(1) + '%'
                    : topItem.value >= 1000 ? (topItem.value / 1000).toFixed(1) + 'K' : topItem.value.toLocaleString();
                  insights.push({
                    icon: '',
                    title: 'Top Performer',
                    text: `<strong>${topItem.label}</strong> leads in ${metricLabel} with <strong>${displayVal}</strong>.`
                  });
                }
              }
              
              // Rate metrics insight
              if (rateMeasures.length > 0) {
                const bestRate = rateMeasures.reduce((best, m) => m.avg > best.avg ? m : best, rateMeasures[0]);
                const rateLabel = normalizeFieldName(bestRate.name, { isRate: true });
                insights.push({
                  icon: '',
                  title: 'Rate Performance',
                  text: `Average ${rateLabel} is <strong>${(bestRate.avg * 100).toFixed(1)}%</strong> across all data.`
                });
              }
              
              // Volume metrics insight
              if (volumeMeasures.length > 0) {
                const totalVol = volumeMeasures[0].sum;
                const volLabel = normalizeFieldName(volumeMeasures[0].name, { isRate: false });
                insights.push({
                  icon: '',
                  title: 'Volume Summary',
                  text: `Total ${volLabel}: <strong>${totalVol >= 1000000 ? (totalVol / 1000000).toFixed(1) + 'M' : totalVol >= 1000 ? (totalVol / 1000).toFixed(1) + 'K' : totalVol.toLocaleString()}</strong> across ${wsData.rowCount.toLocaleString()} records.`
                });
              }
              
              // Concentration insight (if donut data exists)
              if (wsData.donutData && wsData.donutData.data.length >= 2) {
                const top2 = wsData.donutData.data.slice(0, 2);
                const total = wsData.donutData.data.reduce((s, d) => s + d.value, 0);
                const top2Share = ((top2[0].value + top2[1].value) / total * 100).toFixed(0);
                insights.push({
                  icon: '',
                  title: 'Concentration',
                  text: `Top 2 ${wsData.donutData.dimension} categories account for <strong>${top2Share}%</strong> of total volume.`
                });
              }
              
              // Timeline insight (if available)
              if (wsData.timelineData && wsData.timelineData.data.length >= 2) {
                const timeline = wsData.timelineData;
                const first = timeline.data[0].value;
                const last = timeline.data[timeline.data.length - 1].value;
                const change = ((last - first) / first * 100).toFixed(0);
                const trend = change > 0 ? 'increased' : change < 0 ? 'decreased' : 'remained stable';
                const metricLabel = normalizeFieldName(timeline.measure.name, { isRate: timeline.measure.isRate });
                insights.push({
                  icon: '',
                  title: 'Trend',
                  text: `${metricLabel} has <strong>${trend} by ${Math.abs(change)}%</strong> from ${timeline.data[0].label} to ${timeline.data[timeline.data.length - 1].label}.`
                });
              }
            }
            
            // Render insights section if we have any
            if (insights.length > 0) {
              html += `

  <!-- AI-Generated Insights -->
  <div style="margin-bottom: 28px;">
    <h2 style="margin: 0 0 16px 0; font-size: 14px; font-weight: 600; color: ${t.textMuted}; text-transform: uppercase; letter-spacing: 1px;">
      Key Insights
    </h2>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px;">`;
              
              for (const insight of insights) {
                html += `
      <div style="background: ${t.cardBg}; border-radius: 12px; padding: 16px 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border-left: 4px solid ${t.volumeColor};">
        <div style="display: flex; align-items: flex-start; gap: 12px;">
          <div style="font-size: 20px;">${insight.icon}</div>
          <div>
            <div style="font-size: 13px; font-weight: 600; color: ${t.text}; margin-bottom: 4px;">${insight.title}</div>
            <div style="font-size: 12px; color: ${t.textMuted}; line-height: 1.5;">${insight.text}</div>
          </div>
        </div>
      </div>`;
              }
              
              html += `
    </div>
  </div>`;
            }
            
            // Footer
            html += `

  <!-- Dashboard Footer -->
  <div style="background: ${t.cardBg}; border-radius: 12px; padding: 16px 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.08);">
    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px;">
      <div style="font-size: 12px; color: ${t.textMuted};">
        <strong style="color: ${t.text};">Data Summary:</strong> 
        ${rateMeasures.length} rate metrics · 
        ${volumeMeasures.length} volume metrics · 
        ${wsData.breakdowns.length} comparison charts
        ${hasDonut ? ' · 1 composition chart' : ''}
      </div>
      <div style="font-size: 11px; color: ${t.textMuted};">
        Generated by DashAgent · ${new Date().toLocaleString()}
      </div>
    </div>
  </div>

  </div>
</div>`;
            
              // Validate generated HTML
              if (!html || html.length < 100 || html.includes('undefined') || html.includes('NaN')) {
                throw new Error('Generated dashboard HTML appears invalid (undefined values or too short)');
              }
              
            } catch (renderError) {
              // LLM FALLBACK for build_dashboard
              console.warn('[DashAgent] Dashboard rendering failed, using LLM fallback:', renderError);
              
              const sampleDataStr = wsData.rawData?.slice(0, 5) 
                ? JSON.stringify(wsData.rawData.slice(0, 5), null, 2) 
                : 'Not available';
              
              const fallbackPrompt = `You are an expert dashboard HTML generator. The standard template-based dashboard builder encountered an error. Generate a complete, working HTML dashboard based on the following context.

## Dashboard Configuration
- Theme: ${theme}
- Dashboard Title: ${dashboardTitle || 'Data Dashboard'}
- Worksheet: ${worksheetName}
- Max Metrics: ${maxMetrics}
- Max Items per chart: ${maxItems}

## Available Measures
${uniqueMeasures.map(m => `- ${m.name} (${m.type || 'numeric'})`).join('\n')}

## Available Dimensions
${wsData.dimensions.map(d => `- ${d.name} (${d.cardinality} unique values)`).join('\n')}

## Design Plan
${JSON.stringify(designPlan.chartSelections || [], null, 2)}

## Theme Colors
- Background: ${t.bg}
- Header Background: ${t.headerBg}
- Card Background: ${t.cardBg}
- Text: ${t.text}
- Accent: ${t.accent}

## Error That Occurred
${renderError.message}

## Sample Data (first 5 rows)
${sampleDataStr}

## Requirements
1. Generate ONLY the HTML markup - no JavaScript, no explanation, just pure HTML
2. Use inline styles (no external CSS)
3. Include:
   - A header section with title and subtitle
   - KPI cards for the main metrics (show values from sample data if available)
   - At least one bar chart visualization (use inline SVG or styled divs)
   - A footer with generation timestamp
4. Use the theme colors provided
5. Make it responsive using flexbox
6. The HTML should be wrapped in a single container div

Return ONLY the HTML code, nothing else.`;

              try {
                const fallbackResponse = await callLLM(fallbackPrompt, null, 'generation');
                
                // Extract HTML from response (might be in code blocks)
                let extractedHtml = fallbackResponse;
                const htmlMatch = fallbackResponse.match(/```(?:html)?\s*([\s\S]*?)```/);
                if (htmlMatch) {
                  extractedHtml = htmlMatch[1].trim();
                }
                
                html = extractedHtml;
                usedFallback = true;
                console.log('[DashAgent] LLM fallback generated dashboard HTML successfully');
              } catch (llmError) {
                console.error('[DashAgent] LLM fallback also failed:', llmError);
                return `Error: Dashboard generation failed.\n\n**Standard Renderer Error:** ${renderError.message}\n\n**LLM Fallback Error:** ${llmError.message}\n\nPlease try again or simplify your request.`;
              }
            }
            
            // Clear previous state and display
            currentVizConfigs = [];
            for (const listener of vizEventListeners) {
              try { listener.unregister(); } catch (e) {}
            }
            vizEventListeners = [];
            
            previewContainer.innerHTML = html;
            generatedHtml = html;
            dashboardBaseHtml = html; // Store for appending later
            
            // Apply dark theme background to preview container if using modern theme
            if (theme === 'modern') {
              previewContainer.style.backgroundColor = '#0f172a';
              previewContainer.style.borderColor = '#334155';
            } else {
              previewContainer.style.backgroundColor = '';
              previewContainer.style.borderColor = '';
            }
            
            // Show buttons
            const refreshBtn = document.getElementById('btn-refresh-viz');
            const clearBtn = document.getElementById('btn-clear-viz');
            if (refreshBtn) refreshBtn.style.display = 'inline-block';
            if (clearBtn) clearBtn.style.display = 'inline-block';
            
            // Switch to preview panel
            document.querySelector('[data-panel="preview"]').click();
            
            // Build detailed response with design plan
            let response = '## Dashboard Design Plan\n\n';
            
            // Include design guidance if provided
            if (designGuidance) {
              response += '### Design Guidance Applied\n';
              response += `> ${designGuidance.substring(0, 300)}${designGuidance.length > 300 ? '...' : ''}\n\n`;
            }
            
            response += '### Theme & Color Strategy\n';
            response += `- **Theme:** ${t.name}\n`;
            response += `- **Background:** ${theme === 'modern' ? 'Dark slate' : 'Light gray'}\n`;
            response += `- **Color Strategy:** ${designPlan.colorStrategy}\n\n`;
            
            response += '### Layout Structure\n';
            response += '```\n';
            response += '┌─────────────────────────────────────────┐\n';
            response += '│           HEADER (Title + Meta)         │\n';
            response += '├─────────────────────────────────────────┤\n';
            response += `│  KPI  │  KPI  │  KPI  │  KPI  │  ...   │ ← ${uniqueMeasures.length} metrics\n`;
            response += '├─────────────────────────────────────────┤\n';
            response += '│ Bar Chart 1  │ Bar Chart 2  │ Donut    │\n';
            response += '│              │              │          │\n';
            response += '├──────────────┴──────────────┴──────────┤\n';
            response += '│              FOOTER                     │\n';
            response += '└─────────────────────────────────────────┘\n';
            response += '```\n\n';
            
            response += '### Chart Type Selections\n';
            response += '| Metric | Chart Type | Reason |\n';
            response += '|--------|------------|--------|\n';
            
            for (const selection of designPlan.chartSelections) {
              response += `| ${selection.metric} | ${selection.chartType} | ${selection.reason} |\n`;
            }
            
            response += '\n### What\'s Rendered\n';
            response += `- **${uniqueMeasures.length} KPI Cards** with mini sparklines\n`;
            if (numBarCharts > 0) {
              response += `- **${numBarCharts} Bar Charts** for ranked comparisons\n`;
            }
            if (hasDonut) {
              const donutMeasureName = wsData.donutData.measure.name.replace(/^SUM\(|\)$/g, '');
              response += `- **1 Donut Chart** showing ${donutMeasureName} composition by ${wsData.donutData.dimension}\n`;
            }
            if (numBarCharts === 0 && !hasDonut) {
              response += `- **${Math.min(uniqueMeasures.length, 4)} Trend Charts** (fallback - no categorical dimension found)\n`;
              response += `\n**Note:** No bar/donut charts could be created because no suitable dimension was detected.\n`;
              response += `Detected dimensions: ${wsData.dimensions.length > 0 ? wsData.dimensions.map(d => `${d.name} (${d.cardinality} values)`).join(', ') : 'None'}\n`;
              response += `For bar charts, you need a string dimension with 3-15 unique values.\n`;
            }
            
            response += '\n### Data Analysis Summary\n';
            response += `- **Worksheet:** ${wsData.worksheet}\n`;
            response += `- **Measures:** ${wsData.measures.length} (${rateMeasures.length} rates, ${volumeMeasures.length} volumes)\n`;
            response += `- **Dimensions:** ${wsData.dimensions.length}\n`;
            if (wsData.dimensions.length > 0) {
              response += `- **Best Dimension:** ${wsData.bestDimension?.name || 'None'}\n`;
            }
            
            response += '\n---\n\n';
            response += '✅ **Dashboard created and displayed in the Preview panel.**\n\n';
            
            // Add fallback notification if LLM was used
            if (usedFallback) {
              response += '⚠️ *Note: The standard dashboard builder encountered an issue, so the Code Generation model was used to create this dashboard.*\n\n';
            }
            
            response += '💬 **Does this look good?** Say **"apply it"** to update your actual Tableau workbook.\n\n';
            response += 'Or ask me to:\n';
            response += '- Change the theme (try `modern` for dark mode)\n';
            response += '- Focus on specific metrics\n';
            response += '- Specify a dimension for bar charts (e.g., "break down by Campaign Name")';
            
            return response;
          }
          
          case 'parse_workbook_xml': {
            // PARSE TABLEAU WORKBOOK XML
            const xmlContent = args.xmlContent;
            const extractOnly = args.extractOnly || ['all'];
            const format = args.format || 'summary';
            
            if (!xmlContent || xmlContent.trim().length === 0) {
              return 'Error: No XML content provided. Please paste the contents of a .twb file.';
            }
            
            try {
              // Parse XML
              const parser = new DOMParser();
              const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
              
              // Check for parse errors
              const parseError = xmlDoc.querySelector('parsererror');
              if (parseError) {
                return `Error parsing XML: ${parseError.textContent.substring(0, 200)}...`;
              }
              
              const shouldExtract = (type) => extractOnly.includes('all') || extractOnly.includes(type);
              const result = {
                workbookName: xmlDoc.querySelector('workbook')?.getAttribute('name') || 'Unknown',
                version: xmlDoc.querySelector('workbook')?.getAttribute('version') || 'Unknown',
                dataSources: [],
                calculatedFields: [],
                parameters: [],
                worksheets: [],
                dashboards: [],
                filters: []
              };
              
              // Extract Data Sources
              if (shouldExtract('dataSources')) {
                const datasources = xmlDoc.querySelectorAll('datasource');
                for (const ds of datasources) {
                  const dsName = ds.getAttribute('caption') || ds.getAttribute('name') || 'Unnamed';
                  const connection = ds.querySelector('connection');
                  result.dataSources.push({
                    name: dsName,
                    type: connection?.getAttribute('class') || 'unknown',
                    server: connection?.getAttribute('server') || '',
                    database: connection?.getAttribute('dbname') || '',
                    tables: [...ds.querySelectorAll('relation')].map(r => r.getAttribute('name')).filter(Boolean).slice(0, 10)
                  });
                }
              }
              
              // Extract Calculated Fields
              if (shouldExtract('calculatedFields')) {
                const calculations = xmlDoc.querySelectorAll('column[calculation]');
                for (const calc of calculations) {
                  const calcNode = calc.querySelector('calculation');
                  if (calcNode) {
                    result.calculatedFields.push({
                      name: calc.getAttribute('caption') || calc.getAttribute('name') || 'Unnamed',
                      formula: calcNode.getAttribute('formula') || calcNode.textContent || '',
                      datatype: calc.getAttribute('datatype') || 'unknown'
                    });
                  }
                }
                // Also check for standalone calculation elements
                const standaloneCalcs = xmlDoc.querySelectorAll('calculation');
                for (const calc of standaloneCalcs) {
                  const formula = calc.getAttribute('formula');
                  if (formula && !result.calculatedFields.find(f => f.formula === formula)) {
                    const parent = calc.parentElement;
                    result.calculatedFields.push({
                      name: parent?.getAttribute('caption') || parent?.getAttribute('name') || 'Unnamed',
                      formula: formula,
                      datatype: parent?.getAttribute('datatype') || 'unknown'
                    });
                  }
                }
              }
              
              // Extract Parameters
              if (shouldExtract('parameters')) {
                const paramDatasource = xmlDoc.querySelector('datasource[name="Parameters"]');
                if (paramDatasource) {
                  const params = paramDatasource.querySelectorAll('column');
                  for (const param of params) {
                    const range = param.querySelector('range');
                    result.parameters.push({
                      name: param.getAttribute('caption') || param.getAttribute('name') || 'Unnamed',
                      datatype: param.getAttribute('datatype') || 'unknown',
                      value: param.getAttribute('value') || '',
                      min: range?.getAttribute('min') || '',
                      max: range?.getAttribute('max') || ''
                    });
                  }
                }
              }
              
              // Extract Worksheets
              if (shouldExtract('worksheets')) {
                const worksheets = xmlDoc.querySelectorAll('worksheet');
                for (const ws of worksheets) {
                  const rows = [...ws.querySelectorAll('rows[encoding]')].map(r => r.textContent).filter(Boolean);
                  const cols = [...ws.querySelectorAll('cols[encoding]')].map(c => c.textContent).filter(Boolean);
                  result.worksheets.push({
                    name: ws.getAttribute('name') || 'Unnamed',
                    title: ws.querySelector('title')?.textContent || '',
                    rows: rows.slice(0, 5),
                    columns: cols.slice(0, 5)
                  });
                }
              }
              
              // Extract Dashboards
              if (shouldExtract('dashboards')) {
                const dashboards = xmlDoc.querySelectorAll('dashboard');
                for (const db of dashboards) {
                  const zones = db.querySelectorAll('zone[name]');
                  result.dashboards.push({
                    name: db.getAttribute('name') || 'Unnamed',
                    size: {
                      width: db.querySelector('size')?.getAttribute('maxwidth') || 'auto',
                      height: db.querySelector('size')?.getAttribute('maxheight') || 'auto'
                    },
                    worksheets: [...zones].map(z => z.getAttribute('name')).filter(Boolean).slice(0, 10)
                  });
                }
              }
              
              // Extract Filters
              if (shouldExtract('filters')) {
                const filters = xmlDoc.querySelectorAll('filter');
                for (const filter of filters) {
                  result.filters.push({
                    class: filter.getAttribute('class') || 'unknown',
                    column: filter.getAttribute('column') || '',
                    members: [...filter.querySelectorAll('groupfilter member')].map(m => m.getAttribute('member')).slice(0, 10)
                  });
                }
              }
              
              // Format output
              if (format === 'json') {
                return '```json\n' + JSON.stringify(result, null, 2) + '\n```';
              }
              
              // Build readable output
              let output = `# Workbook Analysis: ${result.workbookName}\n`;
              output += `**Tableau Version:** ${result.version}\n\n`;
              
              if (result.dataSources.length > 0) {
                output += `## Data Sources (${result.dataSources.length})\n`;
                for (const ds of result.dataSources) {
                  output += `### ${ds.name}\n`;
                  output += `- **Type:** ${ds.type}\n`;
                  if (ds.server) output += `- **Server:** ${ds.server}\n`;
                  if (ds.database) output += `- **Database:** ${ds.database}\n`;
                  if (ds.tables.length > 0) output += `- **Tables:** ${ds.tables.join(', ')}\n`;
                  output += '\n';
                }
              }
              
              if (result.calculatedFields.length > 0) {
                output += `## Calculated Fields (${result.calculatedFields.length})\n`;
                if (format === 'detailed') {
                  for (const cf of result.calculatedFields) {
                    output += `### ${cf.name}\n`;
                    output += `- **Type:** ${cf.datatype}\n`;
                    output += `- **Formula:** \`${cf.formula}\`\n\n`;
                  }
                } else {
                  output += '| Field | Type | Formula |\n|-------|------|--------|\n';
                  for (const cf of result.calculatedFields.slice(0, 20)) {
                    const shortFormula = cf.formula.length > 50 ? cf.formula.substring(0, 47) + '...' : cf.formula;
                    output += `| ${cf.name} | ${cf.datatype} | \`${shortFormula}\` |\n`;
                  }
                  if (result.calculatedFields.length > 20) {
                    output += `\n*...and ${result.calculatedFields.length - 20} more calculated fields*\n`;
                  }
                  output += '\n';
                }
              }
              
              if (result.parameters.length > 0) {
                output += `## Parameters (${result.parameters.length})\n`;
                output += '| Parameter | Type | Value | Range |\n|-----------|------|-------|-------|\n';
                for (const p of result.parameters) {
                  const range = p.min || p.max ? `${p.min} - ${p.max}` : 'N/A';
                  output += `| ${p.name} | ${p.datatype} | ${p.value || 'N/A'} | ${range} |\n`;
                }
                output += '\n';
              }
              
              if (result.worksheets.length > 0) {
                output += `## Worksheets (${result.worksheets.length})\n`;
                for (const ws of result.worksheets) {
                  output += `- **${ws.name}**`;
                  if (ws.title) output += ` - "${ws.title}"`;
                  output += '\n';
                }
                output += '\n';
              }
              
              if (result.dashboards.length > 0) {
                output += `## Dashboards (${result.dashboards.length})\n`;
                for (const db of result.dashboards) {
                  output += `### ${db.name}\n`;
                  output += `- **Size:** ${db.size.width} x ${db.size.height}\n`;
                  if (db.worksheets.length > 0) {
                    output += `- **Contains:** ${db.worksheets.join(', ')}\n`;
                  }
                  output += '\n';
                }
              }
              
              if (result.filters.length > 0) {
                output += `## Filters (${result.filters.length})\n`;
                for (const f of result.filters.slice(0, 10)) {
                  output += `- **${f.column}** (${f.class})`;
                  if (f.members.length > 0) output += `: ${f.members.slice(0, 5).join(', ')}${f.members.length > 5 ? '...' : ''}`;
                  output += '\n';
                }
                if (result.filters.length > 10) {
                  output += `*...and ${result.filters.length - 10} more filters*\n`;
                }
              }
              
              return output;
              
            } catch (e) {
              return `Error parsing workbook XML: ${e.message}`;
            }
          }
          
          default:
            throw new Error('Unknown tool: ' + toolName);
        }
      }
      
      // ===== SMART GRID LAYOUT SYSTEM =====
      
      async function buildDashboardLayout() {
        if (currentVizConfigs.length === 0) {
          return '<div style="padding: 20px; color: #6b7280;">No visualizations to display.</div>';
        }
        
        const rows = [];
        let currentRow = [];
        let currentRowWidth = 0;
        
        for (const config of currentVizConfigs) {
          const layout = config.layout || 'full';
          let vizHtml;
          
          try {
            vizHtml = await renderVisualization(config);
          } catch (e) {
            vizHtml = `<div style="padding: 20px; color: red; background: #fee2e2; border-radius: 8px;">Error: ${e.message}</div>`;
          }
          
          // Calculate width based on layout
          let width = '100%';
          let flexBasis = 100;
          
          switch (layout) {
            case 'half':
              width = 'calc(50% - 8px)';
              flexBasis = 50;
              break;
            case 'third':
              width = 'calc(33.33% - 11px)';
              flexBasis = 33.33;
              break;
            case 'row-start':
              // Force new row
              if (currentRow.length > 0) {
                rows.push(currentRow);
                currentRow = [];
                currentRowWidth = 0;
              }
              width = '100%';
              flexBasis = 100;
              break;
            case 'row-end':
              width = '100%';
              flexBasis = 100;
              break;
            default: // 'full'
              width = '100%';
              flexBasis = 100;
          }
          
          // Check if we need to start a new row
          if (currentRowWidth + flexBasis > 100 && currentRow.length > 0) {
            rows.push(currentRow);
            currentRow = [];
            currentRowWidth = 0;
          }
          
          // Add viz to current row
          currentRow.push({
            html: vizHtml,
            width: width,
            flexBasis: flexBasis
          });
          currentRowWidth += flexBasis;
          
          // If we're at full width or row-end, finalize row
          if (currentRowWidth >= 100 || layout === 'row-end' || layout === 'full') {
            rows.push(currentRow);
            currentRow = [];
            currentRowWidth = 0;
          }
        }
        
        // Don't forget the last row if it has items
        if (currentRow.length > 0) {
          rows.push(currentRow);
        }
        
        // Build the HTML grid
        let dashboardHtml = '<div class="dashboard-grid" style="display: flex; flex-direction: column; gap: 16px; width: 100%;">';
        
        for (const row of rows) {
          if (row.length === 1 && row[0].flexBasis >= 100) {
            // Full width row
            dashboardHtml += `<div class="dashboard-row" style="width: 100%;">${row[0].html}</div>`;
          } else {
            // Multi-column row
            dashboardHtml += '<div class="dashboard-row" style="display: flex; gap: 16px; width: 100%;">';
            for (const viz of row) {
              dashboardHtml += `<div style="flex: 0 0 ${viz.width}; min-width: 0;">${viz.html}</div>`;
            }
            dashboardHtml += '</div>';
          }
        }
        
        dashboardHtml += '</div>';
        return dashboardHtml;
      }
      
      // ===== VISUALIZATION RENDERING ENGINE =====
      
      // Color schemes for visualizations
      // BEST PRACTICE: For ranked bar charts, use SINGLE color or SEQUENTIAL gradient
      // For categorical (pie/donut), use DISTINCT colors
      const COLOR_SCHEMES = {
        // Single-color palettes (RECOMMENDED for ranked bar charts)
        blue: ['#3b82f6'],  // Single blue - professional look
        green: ['#10b981'], // Single green
        purple: ['#8b5cf6'], // Single purple
        orange: ['#f97316'], // Single orange
        teal: ['#14b8a6'],   // Single teal
        
        // Sequential palettes (for showing rank through color intensity)
        'blue-sequential': ['#1e40af', '#2563eb', '#3b82f6', '#60a5fa', '#93c5fd', '#bfdbfe', '#dbeafe'],
        'green-sequential': ['#065f46', '#059669', '#10b981', '#34d399', '#6ee7b7', '#a7f3d0', '#d1fae5'],
        'purple-sequential': ['#5b21b6', '#7c3aed', '#8b5cf6', '#a78bfa', '#c4b5fd', '#ddd6fe', '#ede9fe'],
        
        // Categorical palettes (for pie/donut charts where each slice is different)
        tableau: ['#4e79a7', '#f28e2c', '#e15759', '#76b7b2', '#59a14f', '#edc949', '#af7aa1', '#ff9da7', '#9c755f', '#bab0ab'],
        categorical: ['#4e79a7', '#f28e2c', '#e15759', '#76b7b2', '#59a14f', '#edc949', '#af7aa1', '#ff9da7', '#9c755f', '#bab0ab'],
        gradient: ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe', '#43e97b']
      };
      
      // Helper: Generate sequential color ramp from a base color
      // Creates shades from light (low values) to dark (high values)
      function generateSequentialColors(baseColor, steps = 10) {
        // Parse hex color to RGB
        const hex = baseColor.replace('#', '');
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        
        const colors = [];
        for (let i = 0; i < steps; i++) {
          // Create gradient from very light (white blend) to full color to darker
          const t = i / (steps - 1); // 0 to 1
          
          let newR, newG, newB;
          if (t < 0.5) {
            // First half: blend from white to base color
            const blend = t * 2; // 0 to 1
            newR = Math.round(255 - (255 - r) * blend);
            newG = Math.round(255 - (255 - g) * blend);
            newB = Math.round(255 - (255 - b) * blend);
          } else {
            // Second half: darken the base color
            const darken = (t - 0.5) * 2; // 0 to 1
            newR = Math.round(r * (1 - darken * 0.6));
            newG = Math.round(g * (1 - darken * 0.6));
            newB = Math.round(b * (1 - darken * 0.6));
          }
          
          const toHex = (n) => Math.min(255, Math.max(0, n)).toString(16).padStart(2, '0');
          colors.push(`#${toHex(newR)}${toHex(newG)}${toHex(newB)}`);
        }
        
        return colors;
      }
      
      // Helper: Get color for bar charts (single color for ranked data)
      function getBarColor(colors, index, total) {
        if (colors.length === 1) {
          // Single color - all bars same color (BEST PRACTICE)
          return colors[0];
        } else if (colors.length >= total) {
          // Sequential - darker for higher values (index 0 = highest = darkest)
          return colors[index % colors.length];
        } else {
          // Fall back to cycling through colors
          return colors[index % colors.length];
        }
      }
      
      // Helper: Get color for categorical charts (each slice different)
      function getCategoricalColor(colors, index) {
        // Always cycle through distinct colors for pie/donut
        const categoricalColors = colors.length > 1 ? colors : COLOR_SCHEMES.tableau;
        return categoricalColors[index % categoricalColors.length];
      }
      
      async function renderVisualization(config) {
        const { vizType, worksheetObj, measureField, dimensionField, title, colorScheme = 'blue', customColors = null, colorMode = 'single', showValues = true, showLegend = true, maxItems = 10, sortBy = 'value', sortOrder = 'desc', theme = 'professional', showAverageLine = false, aggregateByDate = false, aggregationType = 'sum' } = config;
        
        console.log('[DashAgent] renderVisualization config.maxItems:', config.maxItems, '→ destructured maxItems:', maxItems);
        
        // Fetch data from worksheet
        const summaryData = await worksheetObj.getSummaryDataAsync({ maxRows: 500 });
        const columns = summaryData.columns;
        const rows = summaryData.data;
        
        // ============================================
        // SMART COLUMN DETECTION
        // Analyze actual data to find the best columns for the visualization type
        // ============================================
        
        console.log('=== RENDER VISUALIZATION DEBUG ===');
        console.log('vizType:', vizType);
        console.log('Columns:', columns.map(c => ({ fieldName: c.fieldName, dataType: c.dataType })));
        console.log('Requested dimension hint:', dimensionField);
        console.log('Requested measure hint:', measureField);
        console.log('Total rows:', rows.length);
        
        // Helper function to check if values look like dates
        function columnLooksLikeDate(colIndex) {
          if (rows.length === 0) return false;
          const sampleVals = rows.slice(0, Math.min(10, rows.length))
            .map(r => r[colIndex].formattedValue || r[colIndex].value)
            .filter(v => v && v.toString().trim());
          
          if (sampleVals.length < 2) return false;
          
          const datePatterns = [
            /^\d{4}-\d{2}-\d{2}/, // 2024-01-15
            /^\d{1,2}\/\d{1,2}\/\d{2,4}/, // 1/15/2024
            /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i, // Jan 2024
            /^\d{4}$/, // 2024 (year)
            /^Q[1-4]\s*\d{4}/i, // Q1 2024
            /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)/i, // Day names
            /^\d{1,2}\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i // 15 Jan 2024
          ];
          
          const dateCount = sampleVals.filter(v => {
            if (datePatterns.some(p => p.test(v))) return true;
            const parsed = Date.parse(v);
            return !isNaN(parsed) && parsed > 0;
          }).length;
          
          // At least 80% of samples look like dates
          return dateCount / sampleVals.length >= 0.8;
        }
        
        // Helper function to check if values are numeric
        function columnLooksLikeNumber(colIndex) {
          if (rows.length === 0) return false;
          const sampleVals = rows.slice(0, Math.min(10, rows.length))
            .map(r => r[colIndex].value)
            .filter(v => v !== null && v !== undefined);
          
          if (sampleVals.length === 0) return false;
          
          const numCount = sampleVals.filter(v => !isNaN(parseFloat(v))).length;
          return numCount / sampleVals.length >= 0.8;
        }
        
        // Helper function to count unique values
        function getUniqueCount(colIndex) {
          const uniqueVals = new Set();
          for (const row of rows) {
            uniqueVals.add(row[colIndex].formattedValue || row[colIndex].value);
          }
          return uniqueVals.size;
        }
        
        // Analyze all columns
        const columnAnalysis = columns.map((col, idx) => {
          const isDate = col.dataType === 'date' || col.dataType === 'datetime' || columnLooksLikeDate(idx);
          const isNumeric = ['int', 'float', 'number'].includes(col.dataType) || columnLooksLikeNumber(idx);
          const uniqueCount = getUniqueCount(idx);
          const fieldNameLower = col.fieldName.toLowerCase();
          
          // Check if field name suggests a date
          const nameSuggestsDate = /date|time|day|week|month|year|period|quarter/i.test(fieldNameLower) ||
            /^(DAY|MONTH|YEAR|WEEK|HOUR|QUARTER|DATEPART|DATETRUNC)\s*\(/i.test(col.fieldName);
          
          // Check if field name suggests a measure
          const nameSuggestsMeasure = /count|sum|avg|total|rate|amount|revenue|sales|profit|quantity|volume/i.test(fieldNameLower) ||
            /^(SUM|AVG|COUNT|CNTD|MIN|MAX|AGG)\s*\(/i.test(col.fieldName);
          
          return {
            index: idx,
            fieldName: col.fieldName,
            dataType: col.dataType,
            isDate,
            isNumeric,
            uniqueCount,
            nameSuggestsDate,
            nameSuggestsMeasure,
            // Score for being a good dimension (categorical)
            dimensionScore: (!isNumeric ? 2 : 0) + (uniqueCount >= 2 && uniqueCount <= 50 ? 2 : 0) + (nameSuggestsDate ? 0 : 1),
            // Score for being a good date dimension (for line charts)
            dateScore: (isDate ? 3 : 0) + (nameSuggestsDate ? 2 : 0) + (uniqueCount >= 3 ? 1 : 0),
            // Score for being a good measure
            measureScore: (isNumeric ? 3 : 0) + (nameSuggestsMeasure ? 2 : 0)
          };
        });
        
        console.log('Column analysis:', columnAnalysis);
        
        // ============================================
        // PRIORITY 1: EXACT COLUMN NAME MATCH
        // If the provided field name matches a column exactly, use it directly
        // This handles confirmed field names from confirm_chart_fields
        // ============================================
        
        let dimColIndex = -1;
        let measureColIndex = -1;
        
        // Check for exact dimension match first
        if (dimensionField) {
          const exactDimMatch = columns.findIndex(c => c.fieldName === dimensionField);
          if (exactDimMatch >= 0) {
            dimColIndex = exactDimMatch;
            console.log('EXACT dimension match found:', columns[dimColIndex].fieldName);
          }
        }
        
        // Check for exact measure match first
        if (measureField) {
          const exactMeasureMatch = columns.findIndex(c => c.fieldName === measureField);
          if (exactMeasureMatch >= 0) {
            measureColIndex = exactMeasureMatch;
            console.log('EXACT measure match found:', columns[measureColIndex].fieldName);
          }
        }
        
        // If both found with exact match, skip all fuzzy logic
        if (dimColIndex >= 0 && measureColIndex >= 0) {
          console.log('Both fields matched exactly - skipping smart detection');
        } else {
          // ============================================
          // PRIORITY 2: FUZZY MATCHING (only if exact match failed)
          // ============================================
          
          // Helper function for matching field names - STRICT matching to avoid false positives
          function matchField(hint, fieldName) {
            if (!hint || !fieldName) return { score: 0, matched: false };
            
            // Normalize: remove aggregation wrapper and lowercase
            const normalizeField = (str) => str.toLowerCase()
              .replace(/^(sum|avg|count|cntd|min|max|agg|attr)\s*\(/gi, '') // Remove aggregation prefix
              .replace(/\)$/g, '') // Remove closing paren
              .trim();
            
            const hintNorm = normalizeField(hint);
            const fieldNorm = normalizeField(fieldName);
            
            console.log(`  Comparing hint="${hintNorm}" vs field="${fieldNorm}"`);
            
            // EXACT match after normalization (highest priority)
            if (hintNorm === fieldNorm) {
              console.log(`    → EXACT match!`);
              return { score: 100, matched: true };
            }
            
            // One contains the other COMPLETELY
            if (fieldNorm.includes(hintNorm) && hintNorm.length > 3) {
              console.log(`    → Field contains hint`);
              return { score: 80, matched: true };
            }
            if (hintNorm.includes(fieldNorm) && fieldNorm.length > 3) {
              console.log(`    → Hint contains field`);
              return { score: 80, matched: true };
            }
            
            // Check for word-level matches (but require significant overlap)
            // Split on non-alphanumeric and filter short words
            const hintWords = hintNorm.split(/[^a-z0-9]+/).filter(w => w.length > 2);
            const fieldWords = fieldNorm.split(/[^a-z0-9]+/).filter(w => w.length > 2);
            
            // Count matching words (exact word match only, not substring)
            let matchingWords = 0;
            for (const hw of hintWords) {
              if (fieldWords.includes(hw)) matchingWords++;
            }
            
            // Require at least 50% of hint words to match
            if (hintWords.length > 0 && matchingWords / hintWords.length >= 0.5) {
              console.log(`    → Word match: ${matchingWords}/${hintWords.length} words`);
              return { score: 50 + (matchingWords * 10), matched: true };
            }
            
            return { score: 0, matched: false };
          }
        
          // FUZZY: Try to match dimension from hint if provided (only if not already matched exactly)
          if (dimColIndex === -1 && dimensionField) {
            console.log('Looking for dimension hint match (fuzzy):', dimensionField);
            const dimCandidates = columnAnalysis.filter(c => !c.nameSuggestsMeasure);
            
            // Score all candidates and pick the best match
            let bestMatch = null;
            let bestScore = 0;
            
            for (const c of dimCandidates) {
              const result = matchField(dimensionField, c.fieldName);
              if (result.matched && result.score > bestScore) {
                bestScore = result.score;
                bestMatch = c;
              }
            }
            
            if (bestMatch) {
              dimColIndex = bestMatch.index;
              console.log('Matched dimension from hint (fuzzy):', columns[dimColIndex].fieldName, 'score:', bestScore);
            }
          }
        
          if (vizType === 'line' || vizType === 'area') {
            // For line/area charts, prefer date columns (but only if no dimension hint matched)
            if (dimColIndex === -1) {
              const dateColumns = columnAnalysis.filter(c => c.isDate || c.nameSuggestsDate);
              if (dateColumns.length > 0) {
                // Pick the one with highest date score
                dateColumns.sort((a, b) => b.dateScore - a.dateScore);
                dimColIndex = dateColumns[0].index;
                console.log('Selected date column for line chart:', columns[dimColIndex].fieldName);
              }
            }
          }
        
          // If no dimension matched yet, find best categorical dimension
          if (dimColIndex === -1) {
            const dimCandidates = columnAnalysis.filter(c => !c.isNumeric || c.isDate);
            if (dimCandidates.length > 0) {
              dimCandidates.sort((a, b) => b.dimensionScore - a.dimensionScore);
              dimColIndex = dimCandidates[0].index;
              dimCandidates.sort((a, b) => b.dimensionScore - a.dimensionScore);
              dimColIndex = dimCandidates[0].index;
              console.log('Selected dimension column:', columns[dimColIndex].fieldName);
            }
          }
        
          // Find best measure column (only if not already matched exactly)
          if (measureColIndex === -1) {
            const measureCandidates = columnAnalysis.filter(c => c.isNumeric && !c.isDate);
            console.log('Measure candidates:', measureCandidates.map(c => c.fieldName));
            
            if (measureCandidates.length > 0) {
              // If measureField hint provided, try to match it using scoring
              if (measureField) {
                console.log('Looking for measure hint match (fuzzy):', measureField);
                
                // Score all candidates and pick the best match
                let bestMatch = null;
                let bestScore = 0;
                
                for (const c of measureCandidates) {
                  const result = matchField(measureField, c.fieldName);
                  if (result.matched && result.score > bestScore) {
                    bestScore = result.score;
                    bestMatch = c;
                  }
                }
                
                if (bestMatch) {
                  measureColIndex = bestMatch.index;
                  console.log('Matched measure from hint (fuzzy):', columns[measureColIndex].fieldName, 'score:', bestScore);
                } else {
                  console.log('WARNING: No measure matched hint "' + measureField + '" - will use fallback');
                }
              }
              
              // Otherwise pick by score
              if (measureColIndex === -1) {
                measureCandidates.sort((a, b) => b.measureScore - a.measureScore);
                measureColIndex = measureCandidates[0].index;
                console.log('Selected measure column (fallback):', columns[measureColIndex].fieldName);
              }
            }
          }
        } // End of fuzzy matching block
        
        console.log('Final dimension column:', dimColIndex >= 0 ? columns[dimColIndex].fieldName : 'NONE');
        console.log('Final measure column:', measureColIndex >= 0 ? columns[measureColIndex].fieldName : 'NONE');
        
        // Determine if this is a date-based chart
        const isDateDimension = dimColIndex >= 0 && columnAnalysis[dimColIndex].isDate;
        console.log('Is date dimension:', isDateDimension);
        
        // Log sample rows for debugging
        if (rows.length > 0) {
          console.log('Sample row 0:', rows[0].map((cell, i) => ({ col: columns[i]?.fieldName, val: cell.value, formatted: cell.formattedValue })));
          if (rows.length > 1) {
            console.log('Sample row 1:', rows[1].map((cell, i) => ({ col: columns[i]?.fieldName, val: cell.value, formatted: cell.formattedValue })));
          }
        }
        
        console.log('=== END DEBUG ===');
        
        // Helper function to extract just the date part (strip timestamp)
        const extractDateOnly = (val) => {
          if (!val) return val;
          const str = String(val);
          
          // ISO format: 2025-10-26T10:00:00 -> 2025-10-26
          const isoMatch = str.match(/^(\d{4}-\d{2}-\d{2})/);
          if (isoMatch) return isoMatch[1];
          
          // Full format: "October 26, 2025, 10:00 AM" -> "October 26, 2025"
          // Also handle: "October 26, 2025 10:00 AM" (without comma before time)
          const fullDateMatch = str.match(/^(\w+\s+\d{1,2},?\s*\d{4})/);
          if (fullDateMatch) return fullDateMatch[1].replace(/,\s*$/, '');
          
          // US format with time: "10/26/2025 10:00 AM" -> "10/26/2025"
          const usMatch = str.match(/^(\d{1,2}\/\d{1,2}\/\d{2,4})/);
          if (usMatch) return usMatch[1];
          
          // European format: "26/10/2025 10:00" -> "26/10/2025"
          const euMatch = str.match(/^(\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4})/);
          if (euMatch) return euMatch[1];
          
          // Short month format: "Oct 26, 2025, 10:00 AM" or "Oct 26 2025 10:00 AM"
          const shortMonthMatch = str.match(/^([A-Za-z]{3}\s+\d{1,2},?\s*\d{4})/);
          if (shortMonthMatch) return shortMonthMatch[1].replace(/,\s*$/, '');
          
          // Day-Month format: "26 Oct 2025, 10:00 AM"
          const dayMonthMatch = str.match(/^(\d{1,2}\s+[A-Za-z]{3,}\s+\d{4})/);
          if (dayMonthMatch) return dayMonthMatch[1];
          
          // Strip time pattern and trailing comma as fallback
          const stripped = str.replace(/,?\s*\d{1,2}:\d{2}(:\d{2})?\s*(AM|PM)?$/i, '').trim();
          if (stripped !== str && stripped.length > 5) return stripped;
          
          return str;
        };
        
        // Extract data with improved aggregation
        const aggregated = {};
        
        for (const row of rows) {
          let dimValue = dimColIndex >= 0 ? (row[dimColIndex].formattedValue || row[dimColIndex].value || 'Unknown') : 'Value';
          
          // If aggregateByDate is enabled and this is a date dimension, strip the time
          if (aggregateByDate && isDateDimension) {
            dimValue = extractDateOnly(dimValue);
            console.log('Aggregating by date, stripped:', dimValue);
          }
          
          const rawValue = measureColIndex >= 0 ? row[measureColIndex].value : 1;
          const measureValue = parseFloat(rawValue) || 0;
          
          if (!aggregated[dimValue]) {
            aggregated[dimValue] = { sum: 0, count: 0 };
          }
          aggregated[dimValue].sum += measureValue;
          aggregated[dimValue].count += 1;
        }
        
        // Convert to sorted array
        const dataPoints = [];
        for (const [label, data] of Object.entries(aggregated)) {
          // Use the appropriate aggregation type
          let value;
          switch (aggregationType) {
            case 'average':
              value = data.count > 0 ? data.sum / data.count : 0;
              break;
            case 'count':
              value = data.count;
              break;
            case 'max':
              value = data.sum; // Note: would need to track max separately for true max
              break;
            case 'min':
              value = data.sum; // Note: would need to track min separately for true min
              break;
            case 'sum':
            default:
              value = data.sum;
          }
          // Store parsed date for sorting if this is a date dimension
          let dateValue = null;
          if (isDateDimension) {
            const months = { jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5, jul: 6, aug: 7, sep: 8, oct: 9, nov: 10, dec: 11 };
            
            // Helper to extract hour from time string
            const extractHour = (str) => {
              // "at 12 AM", "at 1 AM", "12:00 AM", "1:00 PM", etc.
              const atTimeMatch = str.match(/at\s+(\d{1,2})(?::\d{2})?\s*(AM|PM)/i);
              if (atTimeMatch) {
                let hour = parseInt(atTimeMatch[1]);
                const isPM = atTimeMatch[2].toUpperCase() === 'PM';
                if (isPM && hour !== 12) hour += 12;
                if (!isPM && hour === 12) hour = 0;
                return hour;
              }
              // "3:10:00 AM" format
              const timeMatch = str.match(/(\d{1,2}):(\d{2})(?::\d{2})?\s*(AM|PM)/i);
              if (timeMatch) {
                let hour = parseInt(timeMatch[1]);
                const isPM = timeMatch[3].toUpperCase() === 'PM';
                if (isPM && hour !== 12) hour += 12;
                if (!isPM && hour === 12) hour = 0;
                return hour;
              }
              return 0;
            };
            
            // Try parsing "Month Day, Year at Time" format (e.g., "October 26, 2017 at 12 AM")
            const fullDateTimeMatch = label.match(/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+(\d{1,2}),?\s*(\d{4})/i);
            if (fullDateTimeMatch) {
              const hour = extractHour(label);
              dateValue = new Date(
                parseInt(fullDateTimeMatch[3]), 
                months[fullDateTimeMatch[1].toLowerCase().substring(0, 3)], 
                parseInt(fullDateTimeMatch[2]),
                hour, 0, 0
              );
            }
            
            // Try US format with time (e.g., "10/26/2017 3:10:00 AM")
            if (!dateValue || isNaN(dateValue.getTime())) {
              const usMatch = label.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
              if (usMatch) {
                let year = parseInt(usMatch[3]);
                if (year < 100) year += 2000;
                const hour = extractHour(label);
                dateValue = new Date(year, parseInt(usMatch[1]) - 1, parseInt(usMatch[2]), hour, 0, 0);
              }
            }
            
            // Try ISO format with time (e.g., "2017-10-26T12:00:00" or "2017-10-26 12:00:00")
            if (!dateValue || isNaN(dateValue.getTime())) {
              const isoMatch = label.match(/^(\d{4})-(\d{2})-(\d{2})[T\s]?(\d{2})?:?(\d{2})?/);
              if (isoMatch) {
                const hour = isoMatch[4] ? parseInt(isoMatch[4]) : 0;
                const minute = isoMatch[5] ? parseInt(isoMatch[5]) : 0;
                dateValue = new Date(parseInt(isoMatch[1]), parseInt(isoMatch[2]) - 1, parseInt(isoMatch[3]), hour, minute, 0);
              }
            }
            
            // Try standard Date parsing as fallback
            if (!dateValue || isNaN(dateValue.getTime())) {
              dateValue = new Date(label);
            }
            
            // Try parsing "Month Year" format (e.g., "Oct 2024") - no time component
            if (!dateValue || isNaN(dateValue.getTime())) {
              const monthYearMatch = label.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s*(\d{4})$/i);
              if (monthYearMatch) {
                dateValue = new Date(parseInt(monthYearMatch[2]), months[monthYearMatch[1].toLowerCase().substring(0, 3)], 1);
              }
            }
            
            console.log('[DashAgent] Date parsing:', { label, dateValue: dateValue?.toString(), hour: dateValue?.getHours() });
          }
          dataPoints.push({ label, value, count: data.count, avg: data.count > 0 ? data.sum / data.count : 0, dateValue });
        }
        
        console.log('Aggregated data points:', dataPoints.slice(0, 5));
        console.log('=== END DEBUG ===');
        
        // Sort based on sortBy, sortOrder, and whether it's a date dimension
        // For line/area charts with dates, always sort chronologically
        if (isDateDimension && (vizType === 'line' || vizType === 'area')) {
          dataPoints.sort((a, b) => {
            if (a.dateValue && b.dateValue) {
              return a.dateValue.getTime() - b.dateValue.getTime();
            }
            // Fall back to string comparison for date-like strings
            return a.label.localeCompare(b.label);
          });
          console.log('Sorted chronologically for line chart');
        } else if (sortBy === 'label') {
          // Try to parse as numbers/years first for proper numeric sorting
          dataPoints.sort((a, b) => {
            const aNum = parseFloat(a.label);
            const bNum = parseFloat(b.label);
            if (!isNaN(aNum) && !isNaN(bNum)) {
              return sortOrder === 'desc' ? bNum - aNum : aNum - bNum;
            }
            // Fall back to string comparison
            return sortOrder === 'desc' 
              ? b.label.localeCompare(a.label) 
              : a.label.localeCompare(b.label);
          });
        } else {
          // Sort by value
          dataPoints.sort((a, b) => sortOrder === 'desc' ? b.value - a.value : a.value - b.value);
        }
        
        // For line/area charts, use higher maxItems limit to show full time series
        const effectiveMaxItems = (vizType === 'line' || vizType === 'area') ? Math.max(maxItems, 200) : maxItems;
        const limitedData = dataPoints.slice(0, effectiveMaxItems);
        console.log(`[DashAgent] Using ${limitedData.length} of ${dataPoints.length} data points (effectiveMaxItems: ${effectiveMaxItems})`);
        
        // Get column names for display
        const dimName = dimColIndex >= 0 ? columns[dimColIndex].fieldName : 'Category';
        const measureName = measureColIndex >= 0 ? columns[measureColIndex].fieldName : 'Value';
        const vizTitle = title || `${measureName} by ${dimName}`;
        
        // Resolve colors - handle sequential mode
        let colors = customColors && customColors.length > 0 
          ? customColors 
          : (COLOR_SCHEMES[colorScheme] || COLOR_SCHEMES.tableau);
        
        // For sequential mode, generate a gradient from the primary color
        let sequentialColors = null;
        if (colorMode === 'sequential') {
          const baseColor = colors[0] || '#3b82f6';
          sequentialColors = generateSequentialColors(baseColor, Math.max(limitedData.length, 10));
          console.log('[DashAgent] Generated sequential colors from', baseColor, ':', sequentialColors.slice(0, 5), '...');
        }
        
        // Render based on type - pass theme for consistent styling
        const themeConfig = {
          isDark: theme === 'modern',
          bg: theme === 'modern' ? '#1e293b' : 'white',
          bgSecondary: theme === 'modern' ? '#334155' : '#f8fafc',
          text: theme === 'modern' ? '#f1f5f9' : '#1f2937',
          textSecondary: theme === 'modern' ? '#94a3b8' : '#6b7280',
          textMuted: theme === 'modern' ? '#64748b' : '#9ca3af',
          border: theme === 'modern' ? '#475569' : '#e5e7eb',
          borderLight: theme === 'modern' ? '#334155' : '#f3f4f6'
        };
        
        switch (vizType) {
          case 'bar':
            return renderBarChart(limitedData, vizTitle, colors, showValues, measureName, themeConfig, colorMode, sequentialColors);
          case 'horizontal-bar':
            return renderHorizontalBarChart(limitedData, vizTitle, colors, showValues, measureName, themeConfig, colorMode, sequentialColors);
          case 'pie':
            return renderPieChart(limitedData, vizTitle, colors, showValues, showLegend, themeConfig);
          case 'donut':
            return renderDonutChart(limitedData, vizTitle, colors, showValues, showLegend, themeConfig);
          case 'kpi':
            return renderKPICard(limitedData, vizTitle, colors, measureName, themeConfig);
          case 'metric-cards':
            return renderMetricCards(limitedData, vizTitle, colors, themeConfig);
          case 'line':
            return renderLineChart(limitedData, vizTitle, colors, showValues, dimName, measureName, themeConfig, showAverageLine);
          case 'area':
            return renderAreaChart(limitedData, vizTitle, colors, showValues, dimName, measureName, themeConfig);
          case 'table':
            return renderDataTable(limitedData, vizTitle, dimName, measureName, themeConfig);
          default:
            return renderBarChart(limitedData, vizTitle, colors, showValues, measureName, themeConfig);
        }
      }
      
      function formatNumber(num) {
        if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
        if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
        // For rates/percentages (small numbers), show 2 decimal places
        if (num < 100 && num !== Math.floor(num)) {
          return num.toFixed(2);
        }
        return num.toLocaleString(undefined, { maximumFractionDigits: 2 });
      }
      
      function renderBarChart(data, title, colors, showValues, measureName, themeConfig = {}, colorMode = 'single', sequentialColors = null) {
        const maxValue = Math.max(...data.map(d => d.value));
        const total = data.reduce((s, d) => s + d.value, 0);
        const barWidth = Math.floor(280 / data.length) - 8;
        // Use single primary color for all bars (best practice for ranked data)
        const primaryColor = colors[0] || '#3b82f6';
        
        // For sequential mode, map each bar to a color based on its value rank
        // Higher values get darker colors (end of the sequential array)
        const getBarColor = (index, value) => {
          if (colorMode === 'sequential' && sequentialColors && sequentialColors.length > 0) {
            // Map value to color index - higher values get darker (higher index)
            const valueRatio = maxValue > 0 ? value / maxValue : 0;
            const colorIndex = Math.floor(valueRatio * (sequentialColors.length - 1));
            return sequentialColors[colorIndex];
          }
          return primaryColor;
        };
        
        // Theme defaults
        const theme = {
          isDark: themeConfig.isDark || false,
          bg: themeConfig.bg || 'white',
          text: themeConfig.text || '#1f2937',
          textSecondary: themeConfig.textSecondary || '#6b7280',
          textMuted: themeConfig.textMuted || '#9ca3af',
          border: themeConfig.border || '#e5e7eb',
          borderLight: themeConfig.borderLight || '#f3f4f6'
        };
        
        return `
          <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; background: ${theme.bg}; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,${theme.isDark ? '0.3' : '0.1'});">
            <h3 style="margin: 0 0 4px 0; color: ${theme.text}; font-size: 16px; font-weight: 600;">${title}</h3>
            <p style="margin: 0 0 16px 0; color: ${theme.textSecondary}; font-size: 12px;">${measureName} · ${data.length} items</p>
            
            <div style="display: flex; align-items: flex-end; justify-content: space-between; height: 180px; padding: 0 10px; border-bottom: 2px solid ${theme.border};">
              ${data.map((d, i) => {
                const tooltipText = `${d.label} - ${measureName}: ${formatNumber(d.value)} (${((d.value / total) * 100).toFixed(1)}%)`;
                const barColor = getBarColor(i, d.value);
                return `
                <div style="display: flex; flex-direction: column; align-items: center; width: ${barWidth}px; cursor: pointer;" 
                     title="${tooltipsEnabled ? tooltipText : ''}">
                  ${showValues ? `<span style="font-size: 10px; color: ${theme.text}; margin-bottom: 4px; font-weight: 500;">${formatNumber(d.value)}</span>` : ''}
                  <div style="width: 100%; height: ${(d.value / maxValue) * 140}px; background: ${barColor}; border-radius: 4px 4px 0 0; transition: all 0.2s ease;"
                       onmouseover="this.style.opacity='0.8'; this.style.transform='scaleY(1.02)'"
                       onmouseout="this.style.opacity='1'; this.style.transform='scaleY(1)'"></div>
                </div>
              `;}).join('')}
            </div>
            
            <div style="display: flex; justify-content: space-between; padding: 8px 10px 0;">
              ${data.map((d, i) => `
                <div style="width: ${barWidth}px; text-align: center;">
                  <span style="font-size: 9px; color: ${theme.textSecondary}; display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${d.label}">${d.label.length > 8 ? d.label.substring(0, 7) + '…' : d.label}</span>
                </div>
              `).join('')}
            </div>
            
          </div>
        `;
      }
      
      function renderHorizontalBarChart(data, title, colors, showValues, measureName, themeConfig = {}, colorMode = 'single', sequentialColors = null) {
        const maxValue = Math.max(...data.map(d => d.value));
        const total = data.reduce((s, d) => s + d.value, 0);
        // Use single primary color for all bars (best practice for ranked data)
        const primaryColor = colors[0] || '#3b82f6';
        
        // Helper to get bar color based on colorMode
        const getBarColor = (index, value) => {
          if (colorMode === 'sequential' && sequentialColors && sequentialColors.length > 0) {
            // Map value to color index (higher value = darker color)
            const valueRatio = maxValue > 0 ? value / maxValue : 0;
            const colorIndex = Math.floor(valueRatio * (sequentialColors.length - 1));
            return sequentialColors[colorIndex];
          }
          return primaryColor;
        };
        
        // Theme defaults
        const theme = {
          isDark: themeConfig.isDark || false,
          bg: themeConfig.bg || 'white',
          text: themeConfig.text || '#1f2937',
          textSecondary: themeConfig.textSecondary || '#6b7280',
          textMuted: themeConfig.textMuted || '#9ca3af',
          border: themeConfig.border || '#e5e7eb',
          borderLight: themeConfig.borderLight || '#f3f4f6',
          barBg: themeConfig.isDark ? '#475569' : '#f3f4f6'
        };
        
        return `
          <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; background: ${theme.bg}; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,${theme.isDark ? '0.3' : '0.1'});">
            <h3 style="margin: 0 0 4px 0; color: ${theme.text}; font-size: 16px; font-weight: 600;">${title}</h3>
            <p style="margin: 0 0 16px 0; color: ${theme.textSecondary}; font-size: 12px;">${measureName} · ${data.length} items</p>
            
            <div style="display: flex; flex-direction: column; gap: 8px;">
              ${data.map((d, i) => {
                const barColor = getBarColor(i, d.value);
                const tooltipText = `${d.label}&#10;${measureName}: ${formatNumber(d.value)}&#10;Percentage: ${((d.value / total) * 100).toFixed(1)}%`;
                return `
                <div style="display: flex; align-items: center; gap: 8px; cursor: pointer;"
                     data-tooltip="${tooltipText}"
                     ${tooltipsEnabled ? `title="${tooltipText}"` : ''}>
                  <span style="min-width: 140px; max-width: 200px; font-size: 11px; color: ${theme.text}; text-align: right; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${d.label}">${d.label.length > 20 ? d.label.substring(0, 19) + '…' : d.label}</span>
                  <div style="flex: 1; height: 24px; background: ${theme.barBg}; border-radius: 4px; overflow: hidden;">
                    <div style="width: ${(d.value / maxValue) * 100}%; height: 100%; background: ${barColor}; border-radius: 4px; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px; transition: all 0.2s ease;"
                         onmouseover="this.style.opacity='0.85'; this.style.transform='scaleX(1.01)'"
                         onmouseout="this.style.opacity='1'; this.style.transform='scaleX(1)'">
                      ${showValues ? `<span style="font-size: 10px; color: white; font-weight: 500; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${formatNumber(d.value)}</span>` : ''}
                    </div>
                  </div>
                </div>
              `;}).join('')}
            </div>
          </div>
        `;
      }
      
      function renderPieChart(data, title, colors, showValues, showLegend, themeConfig = {}) {
        const total = data.reduce((s, d) => s + d.value, 0);
        let cumulativePercent = 0;
        
        // Theme defaults
        const theme = {
          isDark: themeConfig.isDark || false,
          bg: themeConfig.bg || 'white',
          text: themeConfig.text || '#1f2937',
          textSecondary: themeConfig.textSecondary || '#6b7280',
          textMuted: themeConfig.textMuted || '#9ca3af',
          border: themeConfig.border || '#e5e7eb',
          borderLight: themeConfig.borderLight || '#f3f4f6',
          hoverBg: themeConfig.isDark ? '#475569' : '#f3f4f6'
        };
        
        const slices = data.map((d, i) => {
          const percent = (d.value / total) * 100;
          const startPercent = cumulativePercent;
          cumulativePercent += percent;
          return { ...d, percent, startPercent, color: colors[i % colors.length] };
        });
        
        // Create conic gradient
        const gradientStops = slices.map(s => `${s.color} ${s.startPercent}% ${s.startPercent + s.percent}%`).join(', ');
        
        return `
          <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; background: ${theme.bg}; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,${theme.isDark ? '0.3' : '0.1'});">
            <h3 style="margin: 0 0 4px 0; color: ${theme.text}; font-size: 16px; font-weight: 600;">${title}</h3>
            <p style="margin: 0 0 16px 0; color: ${theme.textSecondary}; font-size: 12px;">Distribution · ${data.length} categories</p>
            
            <div style="display: flex; align-items: center; gap: 20px;">
              <div style="width: 140px; height: 140px; border-radius: 50%; background: conic-gradient(${gradientStops}); box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer;"
                   ${tooltipsEnabled ? `title="Total: ${formatNumber(total)}&#10;${slices.slice(0, 5).map(s => s.label + ': ' + s.percent.toFixed(1) + '%').join('&#10;')}${slices.length > 5 ? '&#10;...' + (slices.length - 5) + ' more' : ''}"` : ''}></div>
              
              ${showLegend ? `
                <div style="flex: 1; display: flex; flex-direction: column; gap: 6px; max-height: 140px; overflow-y: auto;">
                  ${slices.slice(0, 8).map(s => `
                    <div style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 2px 4px; border-radius: 4px; transition: background 0.15s ease;"
                         ${tooltipsEnabled ? `title="${s.label}&#10;Value: ${formatNumber(s.value)}&#10;Percentage: ${s.percent.toFixed(1)}%"` : ''}
                         onmouseover="this.style.background='${theme.hoverBg}'"
                         onmouseout="this.style.background='transparent'">
                      <div style="width: 12px; height: 12px; border-radius: 2px; background: ${s.color}; flex-shrink: 0;"></div>
                      <span style="font-size: 11px; color: ${theme.text}; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${s.label}</span>
                      <span style="font-size: 11px; color: ${theme.textSecondary}; font-weight: 500;">${s.percent.toFixed(1)}%</span>
                    </div>
                  `).join('')}
                  ${slices.length > 8 ? `<span style="font-size: 10px; color: ${theme.textMuted};">+${slices.length - 8} more</span>` : ''}
                </div>
              ` : ''}
            </div>
          </div>
        `;
      }
      
      function renderDonutChart(data, title, colors, showValues, showLegend, themeConfig = {}) {
        const total = data.reduce((s, d) => s + d.value, 0);
        let cumulativePercent = 0;
        
        // Theme defaults
        const theme = {
          isDark: themeConfig.isDark || false,
          bg: themeConfig.bg || 'white',
          text: themeConfig.text || '#1f2937',
          textSecondary: themeConfig.textSecondary || '#6b7280',
          textMuted: themeConfig.textMuted || '#9ca3af',
          border: themeConfig.border || '#e5e7eb',
          borderLight: themeConfig.borderLight || '#f3f4f6',
          hoverBg: themeConfig.isDark ? '#475569' : '#f3f4f6'
        };
        
        const slices = data.map((d, i) => {
          const percent = (d.value / total) * 100;
          const startPercent = cumulativePercent;
          cumulativePercent += percent;
          return { ...d, percent, startPercent, color: colors[i % colors.length] };
        });
        
        const gradientStops = slices.map(s => `${s.color} ${s.startPercent}% ${s.startPercent + s.percent}%`).join(', ');
        
        return `
          <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; background: ${theme.bg}; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,${theme.isDark ? '0.3' : '0.1'});">
            <h3 style="margin: 0 0 4px 0; color: ${theme.text}; font-size: 16px; font-weight: 600;">${title}</h3>
            <p style="margin: 0 0 16px 0; color: ${theme.textSecondary}; font-size: 12px;">Distribution · ${data.length} categories</p>
            
            <div style="display: flex; align-items: center; gap: 20px;">
              ${(() => {
                const donutTooltip = `Total: ${formatNumber(total)}&#10;${slices.slice(0, 5).map(s => s.label + ': ' + s.percent.toFixed(1) + '%').join('&#10;')}${slices.length > 5 ? '&#10;...' + (slices.length - 5) + ' more' : ''}`;
                return `<div style="position: relative; width: 140px; height: 140px; cursor: pointer;"
                   data-tooltip="${donutTooltip}"
                   ${tooltipsEnabled ? `title="${donutTooltip}"` : ''}>
                <div style="width: 100%; height: 100%; border-radius: 50%; background: conic-gradient(${gradientStops}); box-shadow: 0 2px 8px rgba(0,0,0,0.15);"></div>`;
              })()}
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 70px; height: 70px; background: ${theme.bg}; border-radius: 50%; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                  <span style="font-size: 16px; font-weight: 700; color: ${theme.text};">${formatNumber(total)}</span>
                  <span style="font-size: 9px; color: ${theme.textMuted};">TOTAL</span>
                </div>
              </div>
              
              ${showLegend ? `
                <div style="flex: 1; display: flex; flex-direction: column; gap: 6px; max-height: 140px; overflow-y: auto;">
                  ${slices.slice(0, 8).map(s => `
                    <div style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 2px 4px; border-radius: 4px; transition: background 0.15s ease;"
                         ${tooltipsEnabled ? `title="${s.label}&#10;Value: ${formatNumber(s.value)}&#10;Percentage: ${s.percent.toFixed(1)}%"` : ''}
                         onmouseover="this.style.background='${theme.hoverBg}'"
                         onmouseout="this.style.background='transparent'">
                      <div style="width: 12px; height: 12px; border-radius: 2px; background: ${s.color}; flex-shrink: 0;"></div>
                      <span style="font-size: 11px; color: ${theme.text}; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${s.label}</span>
                      <span style="font-size: 11px; color: ${theme.textSecondary}; font-weight: 500;">${s.percent.toFixed(1)}%</span>
                    </div>
                  `).join('')}
                  ${slices.length > 8 ? `<span style="font-size: 10px; color: ${theme.textMuted};">+${slices.length - 8} more</span>` : ''}
                </div>
              ` : ''}
            </div>
          </div>
        `;
      }
      
      function renderKPICard(data, title, colors, measureName, themeConfig = {}) {
        const total = data.reduce((s, d) => s + d.value, 0);
        const topItem = data[0] || { label: 'N/A', value: 0 };
        
        // KPI cards use gradient colors so theme doesn't affect much, but we accept it for consistency
        const kpiTooltip = `${measureName}&#10;Total: ${formatNumber(total)}&#10;Top Item: ${topItem.label}&#10;Top Value: ${formatNumber(topItem.value)}`;
        return `
          <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 24px; background: linear-gradient(135deg, ${colors[0]}, ${colors[1] || colors[0]}); border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); color: white; cursor: pointer;"
               data-tooltip="${kpiTooltip}"
               ${tooltipsEnabled ? `title="${kpiTooltip}"` : ''}>
            <p style="margin: 0 0 8px 0; font-size: 12px; opacity: 0.9; text-transform: uppercase; letter-spacing: 0.5px;">${title}</p>
            <div style="font-size: 36px; font-weight: 700; margin-bottom: 4px;">${formatNumber(total)}</div>
            <p style="margin: 0; font-size: 13px; opacity: 0.85;">${measureName}</p>
            
            <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.2);">
              <div>
                <span style="font-size: 11px; opacity: 0.8;">Top: </span>
                <span style="font-size: 11px; font-weight: 600;">${topItem.label} (${formatNumber(topItem.value)})</span>
              </div>
            </div>
          </div>
        `;
      }
      
      function renderMetricCards(data, title, colors, themeConfig = {}) {
        // Theme defaults
        const theme = {
          isDark: themeConfig.isDark || false,
          bg: themeConfig.bg || 'white',
          text: themeConfig.text || '#1f2937',
          textSecondary: themeConfig.textSecondary || '#6b7280',
          textMuted: themeConfig.textMuted || '#9ca3af',
          borderLight: themeConfig.borderLight || '#f3f4f6'
        };
        
        return `
          <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
            <h3 style="margin: 0 0 12px 0; color: ${theme.text}; font-size: 14px; font-weight: 600;">${title}</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px;">
              ${data.slice(0, 6).map((d, i) => {
                const metricTooltip = `${d.label}&#10;Value: ${formatNumber(d.value)}`;
                return `
                <div style="padding: 16px; background: ${theme.bg}; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,${theme.isDark ? '0.2' : '0.08'}); border-left: 4px solid ${colors[i % colors.length]}; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease;"
                     data-tooltip="${metricTooltip}"
                     ${tooltipsEnabled ? `title="${metricTooltip}"` : ''}
                     onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,${theme.isDark ? '0.3' : '0.12'})'"
                     onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 6px rgba(0,0,0,${theme.isDark ? '0.2' : '0.08'})'">
                  <div style="font-size: 20px; font-weight: 700; color: ${theme.text}; margin-bottom: 4px;">${formatNumber(d.value)}</div>
                  <div style="font-size: 11px; color: ${theme.textSecondary}; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${d.label}</div>
                </div>
              `;}).join('')}
            </div>
            <div style="margin-top: 8px; text-align: right;">
              <span style="font-size: 10px; color: ${theme.textMuted};">Auto-updates with filters</span>
            </div>
          </div>
        `;
      }
      
      function renderLineChart(data, title, colors, showValues, dimName, measureName, themeConfig = {}, showAverageLine = false) {
        const maxValue = Math.max(...data.map(d => d.value));
        const minValue = Math.min(...data.map(d => d.value));
        const range = maxValue - minValue || 1;
        const total = data.reduce((s, d) => s + d.value, 0);
        const avgValue = total / data.length;
        
        // Theme defaults
        const theme = {
          isDark: themeConfig.isDark || false,
          bg: themeConfig.bg || 'white',
          text: themeConfig.text || '#1f2937',
          textSecondary: themeConfig.textSecondary || '#6b7280',
          textMuted: themeConfig.textMuted || '#9ca3af',
          border: themeConfig.border || '#e5e7eb',
          borderLight: themeConfig.borderLight || '#f3f4f6',
          gridLine: themeConfig.isDark ? '#475569' : '#e5e7eb',
          axisLine: themeConfig.isDark ? '#64748b' : '#d1d5db'
        };
        
        // Local function to clean up field names - remove aggregation prefixes
        const cleanFieldName = (name) => {
          if (!name) return name;
          // Strip aggregation prefixes like HOUR(), DAY(), MONTH(), SUM(), AVG(), etc.
          let cleaned = name
            .replace(/^(HOUR|DAY|WEEK|MONTH|QUARTER|YEAR|DATEPART|DATETRUNC)\s*\(/gi, '')
            .replace(/^(SUM|AVG|MIN|MAX|COUNT|COUNTD|CNTD|MEDIAN|ATTR|AGG)\s*\(/gi, '')
            .replace(/\)$/g, '')
            .trim();
          
          // Common field name mappings
          const mappings = {
            'Activity Date': 'Date',
            'Id': 'Emails',
            'Open Rate': 'Open Rate',
            'Click Rate': 'Click Rate'
          };
          return mappings[cleaned] || cleaned;
        };
        
        // Clean up the dimension name - remove aggregation prefixes like HOUR(), DAY(), etc.
        const cleanDimName = cleanFieldName(dimName);
        const cleanMeasureName = cleanFieldName(measureName);
        
        // Detect if data has timestamps - check for various time patterns
        // Patterns: "12:00", "12:00:00", "12 AM", "12AM", "T12:00", time after comma
        const hasTimeData = data.some(d => {
          const label = d.label || '';
          return /(\d{1,2}:\d{2})|(T\d{2}:\d{2})|(\d{1,2}\s*(?:AM|PM))/i.test(label);
        });
        
        console.log('[DashAgent] Time data detection:', { 
          hasTimeData, 
          sampleLabels: data.slice(0, 3).map(d => d.label)
        });
        
        // Extract unique dates from labels to see if data spans multiple days
        const extractDatePart = (label) => {
          // US format: "10/27/2017 3:10:00 AM" -> "10/27/2017"
          const usMatch = label.match(/^(\d{1,2}\/\d{1,2}\/\d{2,4})/);
          if (usMatch) return usMatch[1];
          // Full month: "October 26, 2025, 10:00 AM" -> "October 26, 2025"
          const fullMatch = label.match(/^(\w+\s+\d{1,2},?\s*\d{4})/);
          if (fullMatch) return fullMatch[1].replace(/,\s*$/, '');
          // ISO: "2025-10-26T10:00" -> "2025-10-26"
          const isoMatch = label.match(/^(\d{4}-\d{2}-\d{2})/);
          if (isoMatch) return isoMatch[1];
          return label;
        };
        
        const uniqueDates = new Set(data.map(d => extractDatePart(d.label)));
        const spansMultipleDays = uniqueDates.size > 1;
        
        // Format date labels - show date+time if hourly data spans multiple days
        const formatDateLabel = (label, showTime = false, showDate = true) => {
          const monthShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          const monthFull = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
          
          // Extract time component - handle many formats:
          // "10/27/2017 3:10:00 AM", "12:00:00 AM", "12:00 AM", "at 12:00 AM", "12 AM", "T12:00:00"
          let timeStr = '';
          
          // Pattern 1: Time with optional seconds and AM/PM "3:10:00 AM" or "12:00 AM"
          const time12Match = label.match(/(\d{1,2}):(\d{2})(?::\d{2})?\s*(AM|PM)/i);
          // Pattern 2: Hour only with AM/PM "12 AM" or "12AM"
          const hourOnlyMatch = label.match(/(?:^|\s)(\d{1,2})\s*(AM|PM)/i);
          // Pattern 3: ISO 24-hour "T12:00" or "T12:00:00"
          const time24Match = label.match(/T(\d{2}):(\d{2})/);
          
          if (showTime) {
            if (time12Match) {
              // 12-hour format: "3:10:00 AM" -> "3AM"
              const hour = parseInt(time12Match[1]);
              timeStr = ` ${hour}${time12Match[3].toUpperCase()}`;
            } else if (hourOnlyMatch) {
              // Hour only: "10 AM" or "10AM" -> "10AM"
              const hour = parseInt(hourOnlyMatch[1]);
              timeStr = ` ${hour}${hourOnlyMatch[2].toUpperCase()}`;
            } else if (time24Match) {
              // ISO 24-hour format: convert to 12h
              const hour = parseInt(time24Match[1]);
              const ampm = hour >= 12 ? 'PM' : 'AM';
              const h12 = hour % 12 || 12;
              timeStr = ` ${h12}${ampm}`;
            }
          }
          
          // Extract date component
          let dateStr = '';
          
          // Full month name pattern (e.g., "October 26, 2025")
          const fullMonthMatch = label.match(/^(\w+)\s+(\d{1,2})/);
          if (fullMonthMatch) {
            const monthIdx = monthFull.indexOf(fullMonthMatch[1]);
            if (monthIdx >= 0) {
              dateStr = `${monthShort[monthIdx]} ${fullMonthMatch[2]}`;
            }
          }
          
          // Short month pattern (e.g., "Oct 26, 2025")
          if (!dateStr) {
            const shortMonthMatch = label.match(/^([A-Za-z]{3})\s+(\d{1,2})/);
            if (shortMonthMatch) {
              dateStr = `${shortMonthMatch[1]} ${shortMonthMatch[2]}`;
            }
          }
          
          // ISO date format (e.g., "2025-10-26")
          if (!dateStr) {
            const isoMatch = label.match(/^(\d{4})-(\d{2})-(\d{2})/);
            if (isoMatch) {
              const monthIdx = parseInt(isoMatch[2]) - 1;
              dateStr = `${monthShort[monthIdx]} ${parseInt(isoMatch[3])}`;
            }
          }
          
          // US date format (e.g., "10/26/2025")
          if (!dateStr) {
            const usMatch = label.match(/^(\d{1,2})\/(\d{1,2})/);
            if (usMatch) {
              const monthIdx = parseInt(usMatch[1]) - 1;
              if (monthIdx >= 0 && monthIdx < 12) {
                dateStr = `${monthShort[monthIdx]} ${parseInt(usMatch[2])}`;
              }
            }
          }
          
          // Build final label
          if (showDate && dateStr) {
            return dateStr + timeStr;
          } else if (showTime && timeStr) {
            return timeStr.trim();
          } else if (dateStr) {
            return dateStr;
          }
          
          // Fallback: truncate if too long
          return label.length > 15 ? label.substring(0, 12) + '…' : label;
        };
        
        // Determine display mode based on data characteristics
        // If hourly data spans multiple days: show "Oct 26 10AM", "Oct 27 8AM"
        // If hourly data on single day: show "10AM", "12PM", etc.
        // If daily data: show "Oct 26", "Oct 27"
        const showTimeInLabels = hasTimeData;
        const showDateInLabels = !hasTimeData || spansMultipleDays;
        
        console.log('[DashAgent] Label formatting debug:', {
          hasTimeData,
          spansMultipleDays,
          uniqueDatesCount: uniqueDates.size,
          uniqueDates: Array.from(uniqueDates).slice(0, 5),
          showTimeInLabels,
          showDateInLabels,
          sampleLabels: data.slice(0, 3).map(d => d.label)
        });
        
        // Simple helper to get display label
        const getDisplayLabel = (d, idx) => {
          const result = formatDateLabel(d.label, showTimeInLabels, showDateInLabels);
          if (idx === 0) {
            console.log('[DashAgent] First label transform:', d.label, '->', result);
          }
          return result;
        };
        
        // Responsive chart dimensions with proper padding
        const width = 600;
        const height = 200;
        const padding = { top: 20, right: 50, bottom: 50, left: 60 };
        const plotWidth = width - padding.left - padding.right;
        const plotHeight = height - padding.top - padding.bottom;
        
        // Calculate points with proper spacing
        const points = data.map((d, i) => {
          const x = padding.left + (data.length > 1 ? (i / (data.length - 1)) * plotWidth : plotWidth / 2);
          const y = padding.top + plotHeight - ((d.value - minValue) / range) * plotHeight;
          return { x, y, ...d };
        });
        
        const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
        
        // Create area path for gradient fill
        const areaD = `${pathD} L ${padding.left + plotWidth} ${padding.top + plotHeight} L ${padding.left} ${padding.top + plotHeight} Z`;
        
        // Determine how many X-axis labels to show (max 8)
        const labelInterval = Math.max(1, Math.ceil(data.length / 8));
        const xLabels = data.filter((_, i) => i % labelInterval === 0 || i === data.length - 1);
        
        // Y-axis tick values (5 ticks)
        const yTicks = [];
        for (let i = 0; i <= 4; i++) {
          const val = minValue + (range * i) / 4;
          const y = padding.top + plotHeight - (i / 4) * plotHeight;
          yTicks.push({ value: val, y });
        }
        
        // Create a sanitized ID for SVG gradient (remove all non-alphanumeric)
        const gradientId = 'lineGrad-' + title.replace(/[^a-zA-Z0-9]/g, '');
        
        return `
          <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; background: ${theme.bg}; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,${theme.isDark ? '0.3' : '0.1'}); width: 100%; box-sizing: border-box;">
            <h3 style="margin: 0 0 4px 0; color: ${theme.text}; font-size: 16px; font-weight: 600;">${title}</h3>
            <p style="margin: 0 0 16px 0; color: ${theme.textSecondary}; font-size: 12px;">${cleanMeasureName} over ${cleanDimName}</p>
            
            <div style="width: 100%; overflow-x: auto;">
              <svg viewBox="0 0 ${width} ${height}" style="width: 100%; min-width: 400px; height: auto;">
                <defs>
                  <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:${colors[0]};stop-opacity:${theme.isDark ? '0.4' : '0.3'}"/>
                    <stop offset="100%" style="stop-color:${colors[0]};stop-opacity:0.02"/>
                  </linearGradient>
                </defs>
                
                <!-- Y-axis grid lines and labels -->
                ${yTicks.map(tick => `
                  <line x1="${padding.left}" y1="${tick.y}" x2="${padding.left + plotWidth}" y2="${tick.y}" stroke="${theme.gridLine}" stroke-dasharray="${tick.value === minValue ? '0' : '4'}"/>
                  <text x="${padding.left - 10}" y="${tick.y + 4}" text-anchor="end" font-size="10" fill="${theme.textSecondary}">${formatNumber(tick.value)}</text>
                `).join('')}
                
                <!-- X-axis line -->
                <line x1="${padding.left}" y1="${padding.top + plotHeight}" x2="${padding.left + plotWidth}" y2="${padding.top + plotHeight}" stroke="${theme.axisLine}" stroke-width="1"/>
                
                <!-- Y-axis line -->
                <line x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${padding.top + plotHeight}" stroke="${theme.axisLine}" stroke-width="1"/>
                
                <!-- Area fill -->
                <path d="${areaD}" fill="url(#${gradientId})"/>
                
                <!-- Average reference line (if enabled) -->
                ${showAverageLine ? (() => {
                  const avgY = padding.top + plotHeight - ((avgValue - minValue) / range) * plotHeight;
                  return `
                    <line x1="${padding.left}" y1="${avgY}" x2="${padding.left + plotWidth}" y2="${avgY}" 
                          stroke="${theme.isDark ? '#f59e0b' : '#d97706'}" stroke-width="2" stroke-dasharray="6,4"/>
                    <text x="${padding.left + plotWidth + 5}" y="${avgY + 4}" font-size="10" fill="${theme.isDark ? '#fbbf24' : '#b45309'}" font-weight="500">
                      Avg: ${formatNumber(avgValue)}
                    </text>
                  `;
                })() : ''}
                
                <!-- Main line -->
                <path d="${pathD}" fill="none" stroke="${colors[0]}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                
                <!-- Data points (show every nth point to avoid clutter) -->
                ${points.filter((_, i) => i % Math.max(1, Math.ceil(data.length / 30)) === 0).map((p, origIdx) => {
                  // Find the original index in data array for proper label lookup
                  const dataIdx = data.findIndex(d => d.label === p.label && d.value === p.value);
                  const displayLabel = getDisplayLabel(p, dataIdx >= 0 ? dataIdx : origIdx);
                  const tooltipText = `${displayLabel} - ${cleanMeasureName}: ${formatNumber(p.value)}`;
                  return `
                  <g style="cursor: pointer;">
                    <circle cx="${p.x}" cy="${p.y}" r="5" fill="${colors[0]}" stroke="${theme.isDark ? '#1e293b' : 'white'}" stroke-width="2">
                      ${tooltipsEnabled ? `<title>${tooltipText}</title>` : ''}
                    </circle>
                  </g>
                `;}).join('')}
                
                <!-- X-axis labels -->
                ${xLabels.map((d, idx) => {
                  const origIndex = data.indexOf(d);
                  const x = padding.left + (data.length > 1 ? (origIndex / (data.length - 1)) * plotWidth : plotWidth / 2);
                  // Use getDisplayLabel to handle duplicate labels
                  const label = getDisplayLabel(d, origIndex);
                  return `
                    <text x="${x}" y="${padding.top + plotHeight + 20}" text-anchor="middle" font-size="10" fill="${theme.textSecondary}" transform="rotate(-30, ${x}, ${padding.top + plotHeight + 20})">${label}</text>
                  `;
                }).join('')}
                
                <!-- Axis labels -->
                <text x="${width / 2}" y="${height - 5}" text-anchor="middle" font-size="11" fill="${theme.text}" font-weight="500">${cleanDimName}</text>
              </svg>
            </div>
            
            <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid ${theme.borderLight}; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px;">
              <div style="display: flex; align-items: center; gap: 12px;">
                ${showAverageLine ? `
                  <span style="display: flex; align-items: center; gap: 4px;">
                    <span style="width: 16px; height: 2px; background: ${theme.isDark ? '#f59e0b' : '#d97706'}; display: inline-block; border-style: dashed;"></span>
                    <span style="font-size: 10px; color: ${theme.isDark ? '#fbbf24' : '#b45309'};">Average Reference</span>
                  </span>
                ` : ''}
              </div>
              <div style="display: flex; gap: 16px;">
                <span style="font-size: 10px; color: ${theme.textSecondary};">Min: <strong>${formatNumber(minValue)}</strong></span>
                ${showAverageLine ? `<span style="font-size: 10px; color: ${theme.isDark ? '#fbbf24' : '#b45309'};">Avg: <strong>${formatNumber(avgValue)}</strong></span>` : ''}
                <span style="font-size: 10px; color: ${theme.textSecondary};">Max: <strong>${formatNumber(maxValue)}</strong></span>
                <span style="font-size: 10px; color: ${theme.textMuted};">${data.length} data points</span>
              </div>
            </div>
          </div>
        `;
      }
      
      function renderAreaChart(data, title, colors, showValues, dimName, measureName, themeConfig = {}) {
        const maxValue = Math.max(...data.map(d => d.value));
        const minValue = 0;
        const range = maxValue - minValue || 1;
        const total = data.reduce((s, d) => s + d.value, 0);
        
        // Theme defaults
        const theme = {
          isDark: themeConfig.isDark || false,
          bg: themeConfig.bg || 'white',
          text: themeConfig.text || '#1f2937',
          textSecondary: themeConfig.textSecondary || '#6b7280',
          textMuted: themeConfig.textMuted || '#9ca3af',
          borderLight: themeConfig.borderLight || '#f3f4f6'
        };
        
        const width = 280;
        const height = 120;
        const points = data.map((d, i) => {
          const x = (i / (data.length - 1)) * width;
          const y = height - ((d.value - minValue) / range) * height;
          return { x, y, ...d };
        });
        
        const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
        const areaD = `${pathD} L ${width} ${height} L 0 ${height} Z`;
        
        return `
          <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; background: ${theme.bg}; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,${theme.isDark ? '0.3' : '0.1'});">
            <h3 style="margin: 0 0 4px 0; color: ${theme.text}; font-size: 16px; font-weight: 600;">${title}</h3>
            <p style="margin: 0 0 16px 0; color: ${theme.textSecondary}; font-size: 12px;">${measureName} over ${dimName}</p>
            
            <div style="position: relative; padding: 10px 0;">
              <svg width="${width}" height="${height}" style="overflow: visible;">
                <defs>
                  <linearGradient id="areaGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:${colors[0]};stop-opacity:0.4"/>
                    <stop offset="100%" style="stop-color:${colors[0]};stop-opacity:0.05"/>
                  </linearGradient>
                </defs>
                
                <!-- Area fill -->
                <path d="${areaD}" fill="url(#areaGradient)"/>
                
                <!-- Line -->
                <path d="${pathD}" fill="none" stroke="${colors[0]}" stroke-width="2" stroke-linecap="round"/>
                
                <!-- Interactive data points with tooltips -->
                ${points.filter((_, i) => i % Math.ceil(data.length / 6) === 0).map(p => `
                  <g style="cursor: pointer;">
                    <circle cx="${p.x}" cy="${p.y}" r="8" fill="transparent">
                      ${tooltipsEnabled ? `<title>${p.label}&#10;${measureName}: ${formatNumber(p.value)}&#10;% of Total: ${((p.value / total) * 100).toFixed(1)}%</title>` : ''}
                    </circle>
                    <circle cx="${p.x}" cy="${p.y}" r="3" fill="${colors[0]}" stroke="${theme.bg}" stroke-width="1.5" style="pointer-events: none;"/>
                  </g>
                `).join('')}
              </svg>
            </div>
          </div>
        `;
      }
      
      function renderDataTable(data, title, dimName, measureName, themeConfig = {}) {
        const total = data.reduce((s, d) => s + d.value, 0);
        
        // Theme defaults
        const theme = {
          isDark: themeConfig.isDark || false,
          bg: themeConfig.bg || 'white',
          bgAlt: themeConfig.isDark ? '#334155' : '#fafafa',
          bgHeader: themeConfig.isDark ? '#475569' : '#f9fafb',
          bgFooter: themeConfig.isDark ? '#475569' : '#f3f4f6',
          bgHover: themeConfig.isDark ? '#3b82f6' : '#e0f2fe',
          text: themeConfig.text || '#1f2937',
          textSecondary: themeConfig.textSecondary || '#374151',
          textMuted: themeConfig.textMuted || '#6b7280',
          border: themeConfig.border || '#e5e7eb',
          borderLight: themeConfig.borderLight || '#f3f4f6'
        };
        
        return `
          <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; background: ${theme.bg}; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,${theme.isDark ? '0.3' : '0.1'});">
            <h3 style="margin: 0 0 4px 0; color: ${theme.text}; font-size: 16px; font-weight: 600;">${title}</h3>
            <p style="margin: 0 0 16px 0; color: ${theme.textMuted}; font-size: 12px;">${data.length} rows</p>
            
            <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
              <thead>
                <tr style="background: ${theme.bgHeader};">
                  <th style="padding: 10px 12px; text-align: left; border-bottom: 2px solid ${theme.border}; color: ${theme.textSecondary}; font-weight: 600;">${dimName}</th>
                  <th style="padding: 10px 12px; text-align: right; border-bottom: 2px solid ${theme.border}; color: ${theme.textSecondary}; font-weight: 600;">${measureName}</th>
                  <th style="padding: 10px 12px; text-align: right; border-bottom: 2px solid ${theme.border}; color: ${theme.textSecondary}; font-weight: 600;">%</th>
                </tr>
              </thead>
              <tbody>
                ${data.map((d, i) => `
                  <tr style="background: ${i % 2 === 0 ? theme.bg : theme.bgAlt}; cursor: pointer; transition: background 0.15s ease;"
                      ${tooltipsEnabled ? `title="${dimName}: ${d.label}&#10;${measureName}: ${formatNumber(d.value)}&#10;Percentage: ${((d.value / total) * 100).toFixed(1)}%&#10;Rank: ${i + 1} of ${data.length}"` : ''}
                      onmouseover="this.style.background='${theme.bgHover}'"
                      onmouseout="this.style.background='${i % 2 === 0 ? theme.bg : theme.bgAlt}'">
                    <td style="padding: 8px 12px; border-bottom: 1px solid ${theme.borderLight}; color: ${theme.text};">${d.label}</td>
                    <td style="padding: 8px 12px; border-bottom: 1px solid ${theme.borderLight}; text-align: right; color: ${theme.textSecondary}; font-weight: 500;">${formatNumber(d.value)}</td>
                    <td style="padding: 8px 12px; border-bottom: 1px solid ${theme.borderLight}; text-align: right; color: ${theme.textMuted};">${((d.value / total) * 100).toFixed(1)}%</td>
                  </tr>
                `).join('')}
              </tbody>
              <tfoot>
                <tr style="background: ${theme.bgFooter}; font-weight: 600;">
                  <td style="padding: 10px 12px; color: ${theme.text};">Total</td>
                  <td style="padding: 10px 12px; text-align: right; color: ${theme.text};">${formatNumber(total)}</td>
                  <td style="padding: 10px 12px; text-align: right; color: ${theme.text};">100%</td>
                </tr>
              </tfoot>
            </table>
          </div>
        `;
      }
      
      // Generate AI summary for dashboard documentation
      async function generateDashboardSummary(docData) {
        // Build a context prompt with dashboard info
        const worksheetNames = docData.worksheets?.map(w => w.name).join(', ') || 'None';
        const dataSourceNames = docData.dataSources?.map(d => d.name).join(', ') || 'None';
        const parameterNames = docData.parameters?.slice(0, 10).map(p => p.name).join(', ') || 'None';
        
        // Get field names from data sources for context
        let fieldSample = [];
        for (const ds of docData.dataSources || []) {
          if (ds.fields) {
            fieldSample = fieldSample.concat(ds.fields.slice(0, 20).map(f => f.name));
          }
        }
        const fieldNames = fieldSample.slice(0, 30).join(', ') || 'None';
        
        const summaryPrompt = `Based on this Tableau dashboard information, write a 2-3 sentence summary of what this dashboard appears to be about and its purpose. Be concise and professional.

Dashboard Name: ${docData.dashboardName}
Worksheets: ${worksheetNames}
Data Sources: ${dataSourceNames}
Sample Fields: ${fieldNames}
Parameters: ${parameterNames}

Write ONLY the summary, no preamble or explanation.`;

        // Make a quick LLM call for the summary
        if (settings.provider === 'openai') {
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + settings.apiKey
            },
            body: JSON.stringify({
              model: settings.model,
              messages: [{ role: 'user', content: summaryPrompt }],
              ...settings.getOpenAITokenParam(settings.model, 200)
            })
          });
          
          if (response.ok) {
            const data = await response.json();
            return data.choices[0]?.message?.content || null;
          }
        } else {
          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-api-key': settings.apiKey,
              'anthropic-version': '2023-06-01',
              'anthropic-dangerous-direct-browser-access': 'true'
            },
            body: JSON.stringify({
              model: settings.model.includes('claude') ? settings.model : 'claude-sonnet-4-5',
              max_tokens: 200,
              messages: [{ role: 'user', content: summaryPrompt }]
            })
          });
          
          if (response.ok) {
            const data = await response.json();
            const textBlock = data.content?.find(b => b.type === 'text');
            return textBlock?.text || null;
          }
        }
        
        return null;
      }
      
      // Store last generated documentation for download
      let lastGeneratedDoc = null;

      // Generate Markdown from documentation data (for chat tool)
      function generateMarkdownFromData(data, aiSummary = null) {
        const lines = [];
        const timestamp = new Date().toLocaleString();
        
        lines.push(`# ${data.dashboardName || 'Tableau Dashboard'} Documentation`);
        lines.push('');
        lines.push(`*Generated on ${timestamp}*`);
        lines.push('');
        
        // AI-generated summary
        if (aiSummary) {
          lines.push('## Summary');
          lines.push('');
          lines.push(aiSummary);
          lines.push('');
        }
        
        // Overview
        lines.push('## Overview');
        lines.push('');
        lines.push(`| Property | Value |`);
        lines.push(`|----------|-------|`);
        lines.push(`| Dashboard Name | ${data.dashboardName} |`);
        lines.push(`| Worksheets | ${data.worksheets?.length || 0} |`);
        lines.push(`| Data Sources | ${data.dataSources?.length || 0} |`);
        lines.push(`| Parameters | ${data.parameters?.length || 0} |`);
        lines.push('');
        
        // Data Sources with Dimensions and Measures
        if (data.dataSources?.length) {
          lines.push('## Data Sources');
          lines.push('');
          
          for (const ds of data.dataSources) {
            lines.push(`### ${ds.name}`);
            lines.push('');
            
            // Connection info
            if (ds.isExtract) lines.push('- **Type:** Extract');
            if (ds.connectionInfo) {
              if (ds.connectionInfo.type) lines.push(`- **Connection Type:** ${ds.connectionInfo.type}`);
              if (ds.connectionInfo.serverName) lines.push(`- **Server:** ${ds.connectionInfo.serverName}`);
              if (ds.connectionInfo.databaseName) lines.push(`- **Database:** ${ds.connectionInfo.databaseName}`);
            }
            if (ds.tables?.length) {
              lines.push(`- **Tables:** ${ds.tables.map(t => t.name).join(', ')}`);
            }
            lines.push('');
            
            // Fields breakdown
            if (ds.fields?.length) {
              const dimensions = ds.fields.filter(f => f.role === 'dimension');
              const measures = ds.fields.filter(f => f.role === 'measure');
              const calcFields = ds.fields.filter(f => f.isCalculatedField);
              
              lines.push(`#### Field Summary`);
              lines.push(`- **Total Fields:** ${ds.fields.length}`);
              lines.push(`- **Dimensions:** ${dimensions.length}`);
              lines.push(`- **Measures:** ${measures.length}`);
              lines.push(`- **Calculated Fields:** ${calcFields.length}`);
              lines.push('');
              
              // Dimensions table
              if (dimensions.length) {
                lines.push('#### Dimensions');
                lines.push('');
                lines.push('| Field Name | Data Type | Calculated |');
                lines.push('|------------|-----------|------------|');
                for (const f of dimensions.slice(0, 50)) {
                  lines.push(`| ${f.name} | ${f.dataType} | ${f.isCalculatedField ? 'Yes' : 'No'} |`);
                }
                if (dimensions.length > 50) {
                  lines.push(`| ... and ${dimensions.length - 50} more | | |`);
                }
                lines.push('');
              }
              
              // Measures table
              if (measures.length) {
                lines.push('#### Measures');
                lines.push('');
                lines.push('| Field Name | Data Type | Calculated |');
                lines.push('|------------|-----------|------------|');
                for (const f of measures.slice(0, 50)) {
                  lines.push(`| ${f.name} | ${f.dataType} | ${f.isCalculatedField ? 'Yes' : 'No'} |`);
                }
                if (measures.length > 50) {
                  lines.push(`| ... and ${measures.length - 50} more | | |`);
                }
                lines.push('');
              }
              
              // Calculated fields detail
              if (calcFields.length) {
                lines.push('#### Calculated Fields');
                lines.push('');
                for (const f of calcFields.slice(0, 20)) {
                  lines.push(`- **${f.name}** (${f.role}, ${f.dataType})`);
                }
                if (calcFields.length > 20) {
                  lines.push(`- ... and ${calcFields.length - 20} more calculated fields`);
                }
                lines.push('');
              }
            }
          }
        }
        
        // Worksheets with visual encoding info
        if (data.worksheets?.length) {
          lines.push('## Worksheets (Sheets)');
          lines.push('');
          
          for (const ws of data.worksheets) {
            lines.push(`### ${ws.name}`);
            lines.push('');
            
            // Inferred Visualization Type
            if (ws.inferredVizType) {
              lines.push(`**Inferred Visualization Type:** ${ws.inferredVizType.type}`);
              lines.push('');
              if (ws.inferredVizType.details?.length) {
                for (const detail of ws.inferredVizType.details) {
                  lines.push(`> ${detail}`);
                }
                lines.push('');
              }
            }
            
            // Data sources used
            if (ws.dataSources?.length) {
              lines.push(`**Data Source(s):** ${ws.dataSources.map(d => d.name).join(', ')}`);
              lines.push('');
            }
            
            // Field breakdown by role
            if (ws.columns?.length) {
              const dimensions = ws.columns.filter(c => c.role === 'dimension');
              const measures = ws.columns.filter(c => c.role === 'measure');
              
              lines.push('**Field Breakdown:**');
              lines.push('');
              lines.push(`- **Dimensions:** ${dimensions.length}`);
              lines.push(`- **Measures:** ${measures.length}`);
              lines.push('');
              
              // Dimensions table
              if (dimensions.length) {
                lines.push('#### Dimensions (Categorical Fields)');
                lines.push('');
                lines.push('| Field Name | Data Type |');
                lines.push('|------------|-----------|');
                for (const col of dimensions) {
                  lines.push(`| ${col.fieldName} | ${col.dataType} |`);
                }
                lines.push('');
              }
              
              // Measures table
              if (measures.length) {
                lines.push('#### Measures (Numeric Fields)');
                lines.push('');
                lines.push('| Field Name | Data Type |');
                lines.push('|------------|-----------|');
                for (const col of measures) {
                  lines.push(`| ${col.fieldName} | ${col.dataType} |`);
                }
                lines.push('');
              }
              
              // Tooltip info
              lines.push('#### Tooltip Fields');
              lines.push('');
              lines.push('*These fields appear in the default tooltip:*');
              lines.push('');
              for (const col of ws.columns) {
                const roleIcon = col.role === 'dimension' ? '[D]' : '[M]';
                lines.push(`- ${roleIcon} **${col.fieldName}** (${col.role}, ${col.dataType})`);
              }
              lines.push('');
              lines.push('> **Tooltip Note:** Custom tooltips may include additional formatting, calculated values, or Viz in Tooltip configurations.');
              lines.push('');
            }
            
            // Filters applied
            if (ws.filters?.length) {
              lines.push('**Filters Applied:**');
              lines.push('');
              for (const f of ws.filters) {
                const values = f.appliedValues?.slice(0, 5).join(', ') || 'All';
                const moreCount = (f.appliedValues?.length || 0) - 5;
                lines.push(`- **${f.fieldName}** (${f.filterType}): ${values}${moreCount > 0 ? ` ... +${moreCount} more` : ''}`);
              }
              lines.push('');
            }
            
            lines.push('---');
            lines.push('');
          }
        }
        
        // Parameters
        if (data.parameters?.length) {
          lines.push('## Parameters');
          lines.push('');
          lines.push('| Parameter Name | Data Type | Current Value | Allowable Values |');
          lines.push('|----------------|-----------|---------------|------------------|');
          for (const p of data.parameters) {
            lines.push(`| ${p.name} | ${p.dataType} | ${p.currentValue ?? 'N/A'} | ${p.allowableValuesType || 'All'} |`);
          }
          lines.push('');
        }
        
        // Footer
        lines.push('---');
        lines.push('');
        lines.push('*Generated by DashAgent for Tableau*');
        
        return lines.join('\n');
      }

      async function fetchDashboardContext() {
        // Use Tableau Extensions API directly (we're running inside Tableau)
        console.log('fetchDashboardContext: Starting...');
        
        try {
          // Check if dashboard content is available
          if (!tableau.extensions.dashboardContent) {
            throw new Error('Dashboard content not available');
          }
          
          const dashboard = tableau.extensions.dashboardContent.dashboard;
          if (!dashboard) {
            throw new Error('Dashboard not found');
          }
          
          console.log('fetchDashboardContext: Dashboard name:', dashboard.name);
          
          // Get workbook name from environment if available
          let workbookName = null;
          try {
            // tableau.extensions.environment contains workbookName in some versions
            const env = tableau.extensions.environment;
            workbookName = env?.workbookName || null;
            console.log('fetchDashboardContext: Workbook name from env:', workbookName);
          } catch (e) {
            console.log('Could not get workbook name from environment:', e);
          }
          
          // Get worksheets with field information
          const worksheets = [];
          const allFields = new Set(); // Track all unique fields across worksheets
          const dimensions = new Set();
          const measures = new Set();
          
          for (const ws of dashboard.worksheets) {
            const wsInfo = {
              name: ws.name,
              sheetType: ws.sheetType,
              fields: []
            };
            
            // Try to get fields from this worksheet
            try {
              const data = await ws.getSummaryDataAsync({ maxRows: 1 });
              const columns = data.columns;
              
              for (const col of columns) {
                const fieldName = col.fieldName;
                wsInfo.fields.push({
                  name: fieldName,
                  dataType: col.dataType,
                  // Classify as dimension or measure based on field name patterns
                  role: /^(SUM|AVG|COUNT|CNTD|MIN|MAX|AGG|MEDIAN)\s*\(/i.test(fieldName) ? 'measure' : 'dimension'
                });
                
                allFields.add(fieldName);
                if (/^(SUM|AVG|COUNT|CNTD|MIN|MAX|AGG|MEDIAN)\s*\(/i.test(fieldName)) {
                  measures.add(fieldName);
                } else {
                  dimensions.add(fieldName);
                }
              }
            } catch (e) {
              console.log('Could not get fields for worksheet:', ws.name, e.message);
            }
            
            worksheets.push(wsInfo);
          }
          console.log('fetchDashboardContext: Found', worksheets.length, 'worksheets');
          console.log('fetchDashboardContext: Found dimensions:', [...dimensions]);
          console.log('fetchDashboardContext: Found measures:', [...measures]);
          
          // Get parameters
          let parameters = [];
          try {
            const params = await dashboard.getParametersAsync();
            parameters = params.map(p => ({
              name: p.name,
              dataType: p.dataType,
              currentValue: p.currentValue?.value
            }));
          } catch (e) {
            console.log('Could not get parameters:', e);
          }
          
          // Get filters from each worksheet
          let filters = [];
          for (const ws of dashboard.worksheets) {
            try {
              const wsFilters = await ws.getFiltersAsync();
              for (const f of wsFilters) {
                filters.push({
                  worksheet: ws.name,
                  fieldName: f.fieldName,
                  filterType: f.filterType
                });
              }
            } catch (e) {
              // Some worksheets may not support filters
            }
          }
          
          dashboardContext = {
            dashboardName: dashboard.name,
            workbookName: workbookName,
            worksheets: worksheets,
            parameters: parameters,
            filters: filters,
            // Add field summary for LLM context
            availableDimensions: [...dimensions],
            availableMeasures: [...measures]
          };
          
          updateDashboardInfoDisplay();
          console.log('Dashboard context loaded via Tableau API:', dashboardContext);
          return dashboardContext;
        } catch (error) {
          console.error('Failed to get dashboard context:', error);
          throw error;
        }
      }

      function updateDashboardInfoDisplay() {
        if (!dashboardContext) return;
        
        // Skip if dashboardInfo element doesn't exist (removed from UI)
        if (!dashboardInfo) {
          console.log('[DashAgent] Dashboard context loaded:', dashboardContext.dashboardName);
          return;
        }
        
        let html = `<div class="data-card-title">${dashboardContext.dashboardName || 'Dashboard'}</div>`;
        
        if (dashboardContext.worksheets?.length) {
          html += `<div class="data-item"><span class="data-item-label">Worksheets</span><span class="data-item-value">${dashboardContext.worksheets.length}</span></div>`;
          dashboardContext.worksheets.forEach(ws => {
            const name = ws.name || ws;
            html += `<div class="data-item" style="padding-left:12px"><span class="data-item-label">${name}</span></div>`;
          });
        }
        
        if (dashboardContext.parameters?.length) {
          html += `<div class="data-item"><span class="data-item-label">Parameters</span><span class="data-item-value">${dashboardContext.parameters.length}</span></div>`;
        }
        
        if (dashboardContext.filters?.length) {
          html += `<div class="data-item"><span class="data-item-label">Filters</span><span class="data-item-value">${dashboardContext.filters.length}</span></div>`;
        }
        
        dashboardInfo.innerHTML = html;
      }

      // NOTE: callOpenAIWithTools and callAnthropicWithTools removed
      // LLM calling is now centralized in MCP server via sendChatToMCP()


      function addMessage(role, content) {
        const div = document.createElement('div');
        div.className = 'message ' + role;
        
        // Check if this is documentation or analysis content (contains download instructions)
        const isDocumentation = content.includes('Click the "Download PDF" button');
        const isAnalysis = content.includes('Click the "Download Analysis PDF" button');
        
        // ALWAYS render markdown for assistant and system messages (LLM often uses markdown formatting)
        const shouldRenderMarkdown = role === 'assistant' || role === 'system';
        
        // Format content - render markdown properly for assistant, escape for user messages
        let formattedContent;
        if (shouldRenderMarkdown) {
          // Remove the download instruction line before rendering
          let cleanContent = content
            .replace(/\n---\n\*Click the "Download PDF" button below to save this documentation\.\*/, '')
            .replace(/\n---\n\*Click the "Download Analysis PDF" button below to save this report\.\*/, '');
          formattedContent = convertMarkdownToHtml(cleanContent);
        } else {
          formattedContent = '<p>' + escapeHtml(content).replace(/\n/g, '</p><p>') + '</p>';
        }
        
        // Create download button HTML
        const downloadButtonStyle = `
          margin-top: 12px;
          padding: 10px 20px;
          background: linear-gradient(135deg, #2563eb, #1d4ed8);
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          font-weight: 500;
          display: inline-flex;
          align-items: center;
          gap: 8px;
          transition: all 0.2s ease;
        `;
        
        const downloadIcon = `<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
        </svg>`;
        
        let downloadButton = '';
        if (isDocumentation) {
          downloadButton = `
            <button onclick="downloadDocAsPDF()" style="${downloadButtonStyle}"
              onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(37,99,235,0.3)'"
              onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
              ${downloadIcon} Download PDF
            </button>
          `;
        } else if (isAnalysis) {
          downloadButton = `
            <button onclick="downloadAnalysisAsPDF()" style="${downloadButtonStyle}"
              onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(37,99,235,0.3)'"
              onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
              ${downloadIcon} Download Analysis PDF
            </button>
          `;
        }
        
        div.innerHTML = `
          <div class="message-avatar">${role === 'user' ? 'You' : role === 'system' ? '⚠️' : 'Dash'}</div>
          <div class="message-content" ${shouldRenderMarkdown ? 'style="max-width: 100%; overflow-x: auto;"' : ''}>
            ${formattedContent}
            ${downloadButton}
          </div>
        `;
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Download documentation as PDF - exposed to window for onclick handler
      window.downloadDocAsPDF = async function() {
        console.log('Download PDF clicked, lastGeneratedDoc:', lastGeneratedDoc);
        
        if (!lastGeneratedDoc) {
          alert('No documentation available. Please generate documentation first.');
          return;
        }
        
        // Create a styled HTML document for PDF generation
        const { markdown, data, timestamp } = lastGeneratedDoc;
        console.log('Generating PDF for markdown of length:', markdown?.length);
        
        // Convert markdown to HTML with proper styling
        const htmlContent = convertMarkdownToHtml(markdown);
        
        // Create a container for the PDF - no duplicate header, just the content
        const container = document.createElement('div');
        container.innerHTML = `
          <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 40px; max-width: 800px; margin: 0 auto;">
            ${htmlContent}
            <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #9ca3af; font-size: 12px;">
              Generated by DashAgent for Tableau
            </div>
          </div>
        `;
        
        // Use html2pdf to generate the PDF
        const opt = {
          margin: 10,
          filename: `dashboard-documentation-${new Date().toISOString().split('T')[0]}.pdf`,
          image: { type: 'jpeg', quality: 0.98 },
          html2canvas: { scale: 2, useCORS: true },
          jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
        };
        
        try {
          await html2pdf().set(opt).from(container).save();
        } catch (error) {
          console.error('PDF generation error:', error);
          // Fallback: open in new window for print
          const printWindow = window.open('', '_blank');
          printWindow.document.write(`
            <!DOCTYPE html>
            <html>
            <head>
              <title>Dashboard Documentation</title>
              <style>
                body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 40px; max-width: 800px; margin: 0 auto; }
                h1, h2, h3 { color: #1f2937; }
                h1 { border-bottom: 2px solid #e5e7eb; padding-bottom: 10px; }
                h2 { margin-top: 24px; }
                table { width: 100%; border-collapse: collapse; margin: 16px 0; }
                th, td { border: 1px solid #e5e7eb; padding: 8px 12px; text-align: left; }
                th { background: #f9fafb; }
                code { background: #f3f4f6; padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
                pre { background: #f3f4f6; padding: 16px; border-radius: 8px; overflow-x: auto; }
              </style>
            </head>
            <body>
              ${htmlContent}
              <p style="margin-top: 40px; color: #9ca3af; text-align: center; font-size: 12px;">
                Generated by DashAgent on ${new Date(timestamp).toLocaleString()}
              </p>
            </body>
            </html>
          `);
          printWindow.document.close();
          printWindow.print();
        }
      }
      
      // Download analysis as PDF - exposed to window for onclick handler
      window.downloadAnalysisAsPDF = async function() {
        console.log('Download Analysis PDF clicked, lastGeneratedAnalysis:', lastGeneratedAnalysis);
        
        if (!lastGeneratedAnalysis) {
          alert('No analysis available. Please run data analysis first.');
          return;
        }
        
        // Create a styled HTML document for PDF generation
        const { markdown, data, timestamp } = lastGeneratedAnalysis;
        console.log('Generating PDF for analysis markdown of length:', markdown?.length);
        
        // Convert markdown to HTML with proper styling
        const htmlContent = convertMarkdownToHtml(markdown);
        
        // Create a container for the PDF
        const container = document.createElement('div');
        container.innerHTML = `
          <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 40px; max-width: 800px; margin: 0 auto;">
            ${htmlContent}
            <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #9ca3af; font-size: 12px;">
              Generated by DashAgent for Tableau
            </div>
          </div>
        `;
        
        // Use html2pdf to generate the PDF
        const opt = {
          margin: 10,
          filename: `dashboard-analysis-${new Date().toISOString().split('T')[0]}.pdf`,
          image: { type: 'jpeg', quality: 0.98 },
          html2canvas: { scale: 2, useCORS: true },
          jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
        };
        
        try {
          await html2pdf().set(opt).from(container).save();
        } catch (error) {
          console.error('PDF generation error:', error);
          // Fallback: open in new window for print
          const printWindow = window.open('', '_blank');
          printWindow.document.write(`
            <!DOCTYPE html>
            <html>
            <head>
              <title>Dashboard Data Analysis</title>
              <style>
                body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 40px; max-width: 800px; margin: 0 auto; }
                h1, h2, h3 { color: #1f2937; }
                h1 { border-bottom: 2px solid #e5e7eb; padding-bottom: 10px; }
                h2 { margin-top: 24px; }
                h3 { margin-top: 16px; }
                table { width: 100%; border-collapse: collapse; margin: 16px 0; }
                th, td { border: 1px solid #e5e7eb; padding: 8px 12px; text-align: left; }
                th { background: #f9fafb; font-weight: 600; }
                ul { margin: 12px 0; padding-left: 24px; }
                li { margin: 4px 0; }
                code { background: #f3f4f6; padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
              </style>
            </head>
            <body>
              ${htmlContent}
              <p style="margin-top: 40px; color: #9ca3af; text-align: center; font-size: 12px;">
                Generated by DashAgent on ${new Date(timestamp).toLocaleString()}
              </p>
            </body>
            </html>
          `);
          printWindow.document.close();
          printWindow.print();
        }
      }
      
      // Convert markdown to styled HTML (with table support)
      function convertMarkdownToHtml(markdown) {
        // Split into lines for processing
        const lines = markdown.split('\n');
        const htmlLines = [];
        let inTable = false;
        let tableRows = [];
        let inList = false;
        let listItems = [];
        
        function flushList() {
          if (listItems.length > 0) {
            htmlLines.push('<ul style="margin: 12px 0; padding-left: 20px;">');
            htmlLines.push(...listItems);
            htmlLines.push('</ul>');
            listItems = [];
          }
          inList = false;
        }
        
        function flushTable() {
          if (tableRows.length >= 2) {
            const parseRow = (row) => row.split('|').slice(1, -1).map(cell => cell.trim());
            const headers = parseRow(tableRows[0]);
            const dataRows = tableRows.slice(2); // Skip header and separator
            
            htmlLines.push('<table style="width: 100%; border-collapse: collapse; margin: 16px 0; font-size: 14px;">');
            htmlLines.push('<thead><tr style="background: #f9fafb;">');
            for (const h of headers) {
              const formattedH = formatInline(h);
              htmlLines.push(`<th style="border: 1px solid #e5e7eb; padding: 10px 12px; text-align: left; font-weight: 600;">${formattedH}</th>`);
            }
            htmlLines.push('</tr></thead><tbody>');
            
            for (const row of dataRows) {
              const cells = parseRow(row);
              htmlLines.push('<tr>');
              for (const cell of cells) {
                const formattedCell = formatInline(cell);
                htmlLines.push(`<td style="border: 1px solid #e5e7eb; padding: 8px 12px;">${formattedCell}</td>`);
              }
              htmlLines.push('</tr>');
            }
            htmlLines.push('</tbody></table>');
          }
          tableRows = [];
          inTable = false;
        }
        
        function formatInline(text) {
          // First, handle hex color codes BEFORE other formatting to prevent matching colors in generated HTML
          // Only match hex colors that are standalone (not inside HTML attributes)
          let result = text.replace(/#([A-Fa-f0-9]{6})\b/g, (match) => {
            return `<span class="color-swatch-wrapper" style="display: inline-flex; align-items: center; gap: 4px; margin: 2px 0;"><span style="display: inline-block; width: 16px; height: 16px; background: ${match}; border-radius: 4px; border: 1px solid rgba(0,0,0,0.2); flex-shrink: 0;"></span><span style="font-family: monospace; font-size: 0.85em; color: #374151;">${match}</span></span>`;
          });
          
          // Then apply other formatting (bold, italic, code)
          return result
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>')
            .replace(/`([^`]+)`/g, '<code style="background: #f3f4f6; padding: 2px 6px; border-radius: 4px; font-size: 0.9em;">$1</code>');
        }
        
        for (const line of lines) {
          const trimmed = line.trim();
          
          // Check for table rows
          if (trimmed.startsWith('|') && trimmed.endsWith('|')) {
            if (!inTable) {
              flushList();
              inTable = true;
            }
            tableRows.push(trimmed);
            continue;
          } else if (inTable) {
            flushTable();
          }
          
          // H4 header
          if (trimmed.startsWith('#### ')) {
            flushList();
            const text = formatInline(trimmed.substring(5));
            htmlLines.push(`<h4 style="color: #4b5563; margin-top: 20px; margin-bottom: 10px; font-size: 1.1em;">${text}</h4>`);
            continue;
          }
          
          // H3 header
          if (trimmed.startsWith('### ')) {
            flushList();
            const text = formatInline(trimmed.substring(4));
            htmlLines.push(`<h3 style="color: #374151; margin-top: 20px; margin-bottom: 12px;">${text}</h3>`);
            continue;
          }
          
          // H2 header
          if (trimmed.startsWith('## ')) {
            flushList();
            const text = formatInline(trimmed.substring(3));
            htmlLines.push(`<h2 style="color: #1f2937; margin-top: 28px; padding-bottom: 8px; border-bottom: 1px solid #e5e7eb;">${text}</h2>`);
            continue;
          }
          
          // H1 header
          if (trimmed.startsWith('# ')) {
            flushList();
            const text = formatInline(trimmed.substring(2));
            htmlLines.push(`<h1 style="color: #111827; margin-bottom: 16px; font-size: 1.8em;">${text}</h1>`);
            continue;
          }
          
          // Horizontal rule
          if (trimmed === '---') {
            flushList();
            htmlLines.push('<hr style="border: none; border-top: 1px solid #e5e7eb; margin: 24px 0;">');
            continue;
          }
          
          // Bullet list
          if (trimmed.startsWith('- ')) {
            inList = true;
            const text = formatInline(trimmed.substring(2));
            listItems.push(`<li style="margin-bottom: 4px;">${text}</li>`);
            continue;
          }
          
          // Empty line
          if (trimmed === '') {
            flushList();
            continue;
          }
          
          // Regular paragraph
          flushList();
          const text = formatInline(trimmed);
          htmlLines.push(`<p style="margin: 8px 0; line-height: 1.6;">${text}</p>`);
        }
        
        // Flush any remaining
        flushList();
        flushTable();
        
        return htmlLines.join('\n');
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // LLM API - Task-based model selection
      // taskType: 'vision' (design analysis), 'generation' (HTML/code), 'analysis' (data/chat)
      async function callLLM(message, imageBase64 = null, taskType = 'analysis') {
        // Determine task type automatically if not specified
        if (imageBase64 && taskType === 'analysis') {
          taskType = 'vision'; // If there's an image, use vision model
        }
        
        const modelConfig = settings.getModelConfig(taskType);
        
        if (!modelConfig.apiKey) {
          const providerName = modelConfig.provider === 'openai' ? 'OpenAI' : 'Anthropic';
          throw new Error(`Please configure your ${providerName} API key in Settings (needed for ${taskType} tasks)`);
        }

        console.log(`[LLM] Task: ${taskType}, Provider: ${modelConfig.provider}, Model: ${modelConfig.model}`);

        if (modelConfig.provider === 'openai') {
          return callOpenAI(message, imageBase64, modelConfig);
        } else {
          return callAnthropic(message, imageBase64, modelConfig);
        }
      }

      async function callOpenAI(message, imageBase64, modelConfig) {
        const messages = [{
          role: 'system',
          content: 'You are DashAgent, an AI assistant for Tableau dashboard design. When asked to create visualizations, respond with clean HTML/CSS code wrapped in ```html``` blocks.'
        }];

        const userContent = [];
        userContent.push({ type: 'text', text: message });
        if (imageBase64) {
          userContent.push({
            type: 'image_url',
            image_url: { url: imageBase64 }
          });
        }
        messages.push({ role: 'user', content: userContent });

        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + modelConfig.apiKey
          },
          body: JSON.stringify({
            model: modelConfig.model,
            messages: messages,
            ...settings.getOpenAITokenParam(modelConfig.model, 4096)
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error?.message || 'OpenAI API request failed');
        }

        const data = await response.json();
        return data.choices[0].message.content;
      }

      async function callAnthropic(message, imageBase64, modelConfig) {
        const content = [];
        if (imageBase64) {
          const base64Data = imageBase64.replace(/^data:image\/\w+;base64,/, '');
          const mediaType = imageBase64.match(/^data:(image\/\w+);/)?.[1] || 'image/png';
          content.push({
            type: 'image',
            source: { type: 'base64', media_type: mediaType, data: base64Data }
          });
        }
        content.push({ type: 'text', text: message });

        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': modelConfig.apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true'
          },
          body: JSON.stringify({
            model: modelConfig.model,
            max_tokens: 4096,
            system: 'You are DashAgent, an AI assistant for Tableau dashboard design. When asked to create visualizations, respond with clean HTML/CSS code wrapped in ```html``` blocks.',
            messages: [{ role: 'user', content: content }]
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error?.message || 'Anthropic API request failed');
        }

        const data = await response.json();
        return data.content[0].text;
      }

      // Image upload
      dropZone.addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = (e) => handleFile(e.target.files[0]);
        input.click();
      });

      dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('dragover');
      });

      dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('dragover');
      });

      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('image/')) {
          handleFile(file);
        }
      });

      document.addEventListener('paste', (e) => {
        const items = e.clipboardData?.items;
        if (items) {
          for (const item of items) {
            if (item.type.startsWith('image/')) {
              handleFile(item.getAsFile());
              break;
            }
          }
        }
      });

      function handleFile(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          uploadedImage = e.target.result;
          previewImg.src = uploadedImage;
          previewImg.style.display = 'block';
          dropContent.style.display = 'none';
          dropZone.classList.add('has-image');
          btnClear.style.display = 'inline-flex';
          btnAnalyze.disabled = false;
        };
        reader.readAsDataURL(file);
      }

      // Screen Capture handler
      const btnCapture = document.getElementById('btn-capture');
      if (btnCapture) {
        btnCapture.addEventListener('click', async () => {
          try {
            btnCapture.disabled = true;
            btnCapture.textContent = 'Capturing...';
            
            // Show a status message in chat
            addMessage('assistant', '**Screen capture in progress...**\n\nPlease select the window or screen you want to capture.');
            
            // Request screen capture permission - user selects which window/tab
            const stream = await navigator.mediaDevices.getDisplayMedia({
              video: { 
                cursor: 'never',
                displaySurface: 'window' // Prefer window capture
              },
              audio: false
            });
            
            // Update status
            const statusMessages = chatMessages.querySelectorAll('.message.assistant');
            const lastStatus = statusMessages[statusMessages.length - 1];
            if (lastStatus && lastStatus.textContent.includes('Screen capture in progress')) {
              lastStatus.innerHTML = '<strong>Processing screenshot...</strong>';
            }
            
            // Create video element to capture a frame
            const video = document.createElement('video');
            video.srcObject = stream;
            await video.play();
            
            // Wait a moment for the frame to be ready
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Create canvas and capture the frame
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            
            // Stop all tracks immediately
            stream.getTracks().forEach(track => track.stop());
            
            // Convert to base64 and store
            uploadedImage = canvas.toDataURL('image/png');
            previewImg.src = uploadedImage;
            previewImg.style.display = 'block';
            dropContent.style.display = 'none';
            dropZone.classList.add('has-image');
            btnClear.style.display = 'inline-flex';
            btnAnalyze.disabled = false;
            
            // Update the status message to show success and offer analysis
            if (lastStatus && (lastStatus.textContent.includes('Processing') || lastStatus.textContent.includes('Screen capture'))) {
              lastStatus.innerHTML = `<strong>Screenshot captured successfully!</strong><br><br>
                <em>I can see your dashboard now. Would you like me to:</em><br>
                • <strong>Analyze the design</strong> - Click "Analyze Design" button, or<br>
                • <strong>Ask specific questions</strong> - Type your question in the chat<br><br>
                <em>Tip: For a comprehensive design audit, use the Analyze Design button.</em>`;
            }
            
          } catch (err) {
            console.error('Screen capture failed:', err);
            if (err.name === 'AbortError') {
              // User cancelled - update the message
              const statusMessages = chatMessages.querySelectorAll('.message.assistant');
              const lastStatus = statusMessages[statusMessages.length - 1];
              if (lastStatus && lastStatus.textContent.includes('Screen capture')) {
                lastStatus.innerHTML = '<em>Screen capture cancelled. Click "Capture Screen" to try again.</em>';
              }
            } else {
              addMessage('assistant', 'Screen capture failed: ' + err.message);
            }
          } finally {
            btnCapture.disabled = false;
            btnCapture.textContent = 'Capture Screen';
          }
        });
      }

      btnClear.addEventListener('click', () => {
        uploadedImage = null;
        previewImg.style.display = 'none';
        dropContent.style.display = 'block';
        dropZone.classList.remove('has-image');
        btnClear.style.display = 'none';
        btnAnalyze.disabled = true;
      });

      btnAnalyze.addEventListener('click', async () => {
        if (!uploadedImage) return;
        btnAnalyze.disabled = true;
        
        // Show which model is being used for vision
        const visionConfig = settings.getModelConfig('vision');
        const modelLabel = visionConfig.model.split('-').slice(0, 2).join('-');
        btnAnalyze.textContent = `Analyzing (${modelLabel})...`;

        try {
          // Use the same detailed prompt as the analyze_design tool
          const analysisPrompt = `You are an expert Tableau dashboard designer and data visualization consultant. Analyze this dashboard screenshot and provide SPECIFIC, ACTIONABLE feedback.

DO NOT be vague. For every issue you identify:
- Describe EXACTLY what you see (e.g., "The bar chart in the top-right uses 8 different colors")
- Explain WHY it's a problem (e.g., "This exceeds the 5-color rule and makes comparison difficult")
- Give a SPECIFIC fix (e.g., "Use a single color with varying saturation, or highlight only the top 3 categories")

DO NOT generate HTML/CSS code. Focus only on analysis and recommendations.

## COMPREHENSIVE DESIGN AUDIT

### 1. First Impressions (5-Second Test)
- What grabs attention first? Is that the RIGHT thing to highlight?
- What's the apparent purpose of this dashboard?
- Initial reaction: Clean/cluttered? Professional/amateur? Focused/scattered?

### 2. Layout Critique
- Describe the grid structure (or lack thereof)
- Are elements aligned? Point out specific misalignments
- Is there breathing room, or is everything crammed together?
- Suggested layout changes with specific positions

### 3. Color Audit
Count the colors used and list them:
- How many distinct colors? (Best practice: 5 or fewer meaningful colors)
- Is there a clear color hierarchy (primary, secondary, accent)?
- Are colors meaningful (red=bad, green=good) or arbitrary?
- Specific palette recommendation if needed

### 4. Chart-by-Chart Review
For EACH visualization:
| Chart | Type | What It Shows | Issue | Recommendation |
|-------|------|---------------|-------|----------------|
(fill in for each chart visible)

### 5. Typography Check
- How many font sizes are used? (Best practice: 3 levels max)
- Is there a clear hierarchy (title > subtitle > body > caption)?
- Any fonts that don't match or look unprofessional?

### 6. Data-Ink Ratio
- Identify any "chart junk" (unnecessary gridlines, 3D effects, borders)
- What visual elements can be removed without losing information?

### 7. Scoreboard
| Category | Score (1-10) | Key Issue |
|----------|--------------|-----------|
| Layout | ? | ... |
| Color | ? | ... |
| Typography | ? | ... |
| Chart Selection | ? | ... |
| Clarity | ? | ... |
| **OVERALL** | ? | ... |

### 8. Top 5 Action Items
Numbered list of the 5 most impactful changes, in priority order, with SPECIFIC instructions (not vague advice).`;

          const response = await callLLM(analysisPrompt, uploadedImage);
          
          // Store for PDF download
          lastGeneratedAnalysis = {
            markdown: response,
            data: { analysisType: 'design-review' },
            timestamp: new Date().toISOString()
          };
          
          // Switch to chat and show response
          document.querySelector('[data-panel="chat"]').click();
          addMessage('assistant', `# Dashboard Design Analysis\n\n**Generated:** ${new Date().toLocaleString()}\n\n${response}\n\n---\n*Click the "Download Analysis PDF" button below to save this report.*`);
          conversationHistory.push({ role: 'assistant', content: response });

        } catch (error) {
          addMessage('assistant', 'Analysis failed: ' + error.message);
        } finally {
          btnAnalyze.disabled = false;
          btnAnalyze.textContent = 'Analyze Design';
        }
      });

      // MCP Connection
      function connectMCP() {
        if (mcpSocket && mcpSocket.readyState === WebSocket.OPEN) return;

        try {
          mcpSocket = new WebSocket(settings.mcpUrl);

          mcpSocket.onopen = () => {
            console.log('MCP WebSocket bridge connected');
            
            // Register with the bridge
            mcpSocket.send(JSON.stringify({
              type: 'register',
              dashboardName: dashboardContext?.dashboardName || 'Unknown'
            }));
          };

          mcpSocket.onclose = () => {
            console.log('MCP WebSocket bridge disconnected');
          };

          mcpSocket.onerror = () => {
            console.log('MCP WebSocket bridge error');
          };

          mcpSocket.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              console.log('MCP message received:', data);
              
              // Handle bridge protocol messages
              if (data.type === 'connected') {
                console.log('Bridge connection confirmed:', data.clientId);
              } else if (data.requestId) {
                // This is a request from the MCP server via the bridge
                handleMCPRequest(data);
              } else if (data.id && mcpCallbacks[data.id]) {
                // This is a response to our request
                mcpCallbacks[data.id](data);
                delete mcpCallbacks[data.id];
              }
            } catch (e) {
              console.error('Failed to parse MCP message:', e);
            }
          };
          
          // Handle incoming requests from MCP server
          // This is the THIN CLIENT pattern - Extension handles Tableau API and rendering
          // All business logic is in the MCP server
          async function handleMCPRequest(request) {
            let response = { requestId: request.requestId, type: 'response' };
            const action = request.type || request.action;
            
            try {
              switch (action) {
                // ==================== DATA EXTRACTION ====================
                case 'get-dashboard-info':
                  await fetchDashboardContext();
                  response.data = dashboardContext;
                  break;
                  
                case 'get-worksheet-data': {
                  const ws = tableau.extensions.dashboardContent.dashboard.worksheets.find(
                    w => w.name === request.worksheet
                  );
                  if (ws) {
                    const dataTable = await ws.getSummaryDataAsync();
                    response.data = {
                      columns: dataTable.columns.map(c => ({
                        fieldName: c.fieldName,
                        dataType: c.dataType,
                        role: c.isReferenced ? 'measure' : 'dimension'
                      })),
                      rows: dataTable.data.slice(0, request.maxRows || 100).map(row =>
                        row.map(cell => cell.formattedValue)
                      ),
                      totalRows: dataTable.data.length
                    };
                  } else {
                    response.error = 'Worksheet not found: ' + request.worksheet;
                  }
                  break;
                }

                case 'extract-analysis-data': {
                  // Full data extraction for analysis - delegates to existing handleToolCall logic
                  const result = await handleToolCall('analyze_dashboard_smart', {
                    analysisGoal: request.analysisGoal,
                    focusMeasures: request.focusMeasures,
                    focusDimensions: request.focusDimensions,
                    forceRefresh: request.forceRefresh
                  });
                  response.data = result;
                  break;
                }

                case 'full-data-exploration': {
                  const result = await handleToolCall('full_data_exploration', {
                    analysisDepth: request.analysisDepth,
                    focusAreas: request.focusAreas,
                    targetMeasure: request.targetMeasure
                  });
                  response.data = result;
                  break;
                }

                case 'profile-data': {
                  const result = await handleToolCall('profile_data_for_visualization', {
                    worksheet: request.worksheet,
                    focusMeasure: request.focusMeasure,
                    focusDimension: request.focusDimension,
                    intendedVizType: request.intendedVizType
                  });
                  response.data = result;
                  break;
                }

                case 'confirm-chart-fields': {
                  const result = await handleToolCall('confirm_chart_fields', {
                    worksheet: request.worksheet,
                    requestedDimension: request.requestedDimension,
                    requestedMeasure: request.requestedMeasure,
                    vizType: request.vizType
                  });
                  response.data = result;
                  break;
                }

                // ==================== FILTERS & PARAMETERS ====================
                case 'apply-filter': {
                  const filterWs = tableau.extensions.dashboardContent.dashboard.worksheets.find(
                    w => w.name === request.worksheet
                  );
                  if (filterWs) {
                    if (request.action === 'clear') {
                      await filterWs.clearFilterAsync(request.field);
                    } else if (request.action === 'exclude') {
                      await filterWs.applyFilterAsync(
                        request.field,
                        request.values || [],
                        tableau.FilterUpdateType.Remove
                      );
                    } else {
                      await filterWs.applyFilterAsync(
                        request.field,
                        request.values || [],
                        tableau.FilterUpdateType.Replace
                      );
                    }
                    // Mark cache stale after filter change
                    if (typeof markStoryCacheStale === 'function') {
                      markStoryCacheStale('filter_changed');
                    }
                    response.data = { success: true };
                  } else {
                    response.error = 'Worksheet not found: ' + request.worksheet;
                  }
                  break;
                }

                case 'set-parameter': {
                  const param = await tableau.extensions.dashboardContent.dashboard
                    .findParameterAsync(request.name);
                  if (param) {
                    await param.changeValueAsync(request.value);
                    // Mark cache stale after parameter change
                    if (typeof markStoryCacheStale === 'function') {
                      markStoryCacheStale('parameter_changed');
                    }
                    response.data = { success: true };
                  } else {
                    response.error = 'Parameter not found: ' + request.name;
                  }
                  break;
                }

                // ==================== VISUALIZATION & RENDERING ====================
                case 'build-dashboard': {
                  const result = await handleToolCall('build_dashboard', {
                    title: request.title,
                    labelOverrides: request.labelOverrides,
                    mode: request.mode,
                    theme: request.theme,
                    worksheet: request.worksheet,
                    focusMetrics: request.focusMetrics,
                    focusDimension: request.focusDimension,
                    maxMetrics: request.maxMetrics,
                    maxItems: request.maxItems,
                    customColors: request.customColors
                  });
                  response.data = result;
                  break;
                }

                case 'render-visualization': {
                  const result = await handleToolCall('render_visualization', {
                    vizType: request.vizType,
                    worksheet: request.worksheet,
                    measureField: request.measureField,
                    dimensionField: request.dimensionField,
                    title: request.title,
                    colorScheme: request.colorScheme,
                    customColors: request.customColors,
                    showValues: request.showValues,
                    maxItems: request.maxItems,
                    sortOrder: request.sortOrder,
                    append: request.append,
                    theme: request.theme,
                    aggregateByDate: request.aggregateByDate,
                    aggregationType: request.aggregationType
                  });
                  response.data = result;
                  break;
                }

                case 'render': {
                  // Direct HTML rendering
                  const previewPanel = document.getElementById('preview-panel');
                  if (previewPanel) {
                    if (request.append) {
                      previewPanel.innerHTML += request.html;
                    } else {
                      previewPanel.innerHTML = request.html;
                    }
                  }
                  response.data = { success: true };
                  break;
                }

                case 'toggle-tooltips': {
                  tooltipsEnabled = request.enabled;
                  const tooltipStyle = document.getElementById('tooltip-toggle-style') || document.createElement('style');
                  tooltipStyle.id = 'tooltip-toggle-style';
                  tooltipStyle.textContent = tooltipsEnabled ? '' : '.chart-tooltip { display: none !important; }';
                  if (!tooltipStyle.parentNode) document.head.appendChild(tooltipStyle);
                  response.data = { success: true, tooltipsEnabled };
                  break;
                }

                case 'transform-to-story': {
                  const result = await handleToolCall('transform_to_story', {
                    storyAngle: request.storyAngle,
                    audience: request.audience,
                    includeRecommendations: request.includeRecommendations,
                    forceRefresh: request.forceRefresh,
                    designRequest: request.designRequest
                  });
                  response.data = result;
                  break;
                }

                // ==================== DESIGN ANALYSIS ====================
                case 'get-image': {
                  // Return dropped screenshot if available
                  response.data = { 
                    image: droppedImageBase64 || null,
                    hasImage: !!droppedImageBase64 
                  };
                  break;
                }

                case 'analyze-iron-viz-style': {
                  const result = await handleToolCall('analyze_iron_viz_style', {
                    screenshotBase64: request.screenshotBase64 || droppedImageBase64,
                    focusAreas: request.focusAreas
                  });
                  response.data = result;
                  break;
                }

                case 'analyze-color-harmony': {
                  const result = await handleToolCall('analyze_color_harmony', {
                    colors: request.colors,
                    screenshotBase64: request.screenshotBase64 || droppedImageBase64,
                    checkAccessibility: request.checkAccessibility
                  });
                  response.data = result;
                  break;
                }

                case 'generate-tableau-palette': {
                  const result = await handleToolCall('generate_tableau_palette', {
                    theme: request.theme,
                    brandColors: request.brandColors,
                    paletteType: request.paletteType,
                    paletteName: request.paletteName,
                    colorCount: request.colorCount
                  });
                  response.data = result;
                  break;
                }

                case 'suggest-annotations': {
                  const result = await handleToolCall('suggest_annotations', {
                    worksheetName: request.worksheetName,
                    annotationStyle: request.annotationStyle
                  });
                  response.data = result;
                  break;
                }

                case 'generate-custom-assets': {
                  const result = await handleToolCall('generate_custom_assets', {
                    assetType: request.assetType,
                    theme: request.theme,
                    style: request.style,
                    colorScheme: request.colorScheme,
                    description: request.description,
                    size: request.size
                  });
                  response.data = result;
                  break;
                }

                // ==================== DOCUMENTATION ====================
                case 'generate-documentation': {
                  response.data = await generateDocumentationData(request.options || {});
                  break;
                }

                case 'parse-workbook-xml': {
                  const result = await handleToolCall('parse_workbook_xml', {
                    xmlContent: request.xmlContent,
                    extractOnly: request.extractOnly,
                    format: request.format
                  });
                  response.data = result;
                  break;
                }
                  
                default:
                  response.error = 'Unknown action: ' + action;
              }
            } catch (e) {
              response.error = e.message || 'Request failed';
              console.error('handleMCPRequest error:', e);
            }
            
            mcpSocket.send(JSON.stringify(response));
          }
        } catch (e) {
          console.error('MCP connection failed:', e);
        }
      }
      
      // Infer visualization type based on field configuration
      function inferVisualizationType(columns, summaryData) {
        const dimensions = columns.filter(c => c.role === 'dimension');
        const measures = columns.filter(c => c.role === 'measure');
        const dimCount = dimensions.length;
        const measureCount = measures.length;
        const rowCount = summaryData?.data?.length || 0;
        
        // Check for date/time dimensions
        const hasDateDim = dimensions.some(d => 
          d.dataType?.toLowerCase().includes('date') || 
          d.dataType?.toLowerCase().includes('time') ||
          d.fieldName?.toLowerCase().includes('date') ||
          d.fieldName?.toLowerCase().includes('year') ||
          d.fieldName?.toLowerCase().includes('month') ||
          d.fieldName?.toLowerCase().includes('quarter')
        );
        
        // Check for geographic dimensions
        const hasGeoDim = dimensions.some(d =>
          d.fieldName?.toLowerCase().includes('country') ||
          d.fieldName?.toLowerCase().includes('state') ||
          d.fieldName?.toLowerCase().includes('city') ||
          d.fieldName?.toLowerCase().includes('region') ||
          d.fieldName?.toLowerCase().includes('lat') ||
          d.fieldName?.toLowerCase().includes('long') ||
          d.fieldName?.toLowerCase().includes('zip') ||
          d.fieldName?.toLowerCase().includes('postal')
        );
        
        // Infer visualization type
        let vizType = 'Unknown';
        let vizDetails = [];
        
        if (dimCount === 0 && measureCount === 1 && rowCount <= 1) {
          vizType = 'KPI / Single Value';
          vizDetails.push('Single aggregated measure displayed as a big number');
        } else if (dimCount === 0 && measureCount > 1 && rowCount <= 1) {
          vizType = 'KPI Dashboard / Scorecard';
          vizDetails.push(`${measureCount} aggregated measures displayed as metrics`);
        } else if (hasGeoDim) {
          vizType = 'Map / Geographic Visualization';
          vizDetails.push('Contains geographic dimensions');
          if (measureCount > 0) vizDetails.push(`Sized/colored by ${measures[0]?.fieldName}`);
        } else if (hasDateDim && measureCount >= 1) {
          if (measureCount === 1) {
            vizType = 'Time Series Line Chart';
            vizDetails.push(`Trend of ${measures[0]?.fieldName} over time`);
          } else {
            vizType = 'Multi-Line Time Series';
            vizDetails.push(`${measureCount} measures tracked over time`);
          }
        } else if (dimCount === 1 && measureCount === 1) {
          if (rowCount <= 10) {
            vizType = 'Bar Chart';
            vizDetails.push(`${dimensions[0]?.fieldName} by ${measures[0]?.fieldName}`);
          } else if (rowCount <= 30) {
            vizType = 'Bar Chart or Horizontal Bar';
            vizDetails.push(`${rowCount} categories - may benefit from horizontal layout`);
          } else {
            vizType = 'Large Category Chart (Bar/Treemap)';
            vizDetails.push(`${rowCount} categories - consider grouping or filtering`);
          }
        } else if (dimCount === 1 && measureCount === 2) {
          vizType = 'Dual-Axis Bar Chart or Combo Chart';
          vizDetails.push(`${dimensions[0]?.fieldName} with two measures`);
        } else if (dimCount === 2 && measureCount === 1) {
          vizType = 'Stacked Bar / Grouped Bar / Heat Map';
          vizDetails.push(`${dimensions[0]?.fieldName} broken down by ${dimensions[1]?.fieldName}`);
          vizDetails.push(`Colored/sized by ${measures[0]?.fieldName}`);
        } else if (dimCount === 0 && measureCount === 2) {
          vizType = 'Scatter Plot';
          vizDetails.push(`${measures[0]?.fieldName} vs ${measures[1]?.fieldName}`);
        } else if (dimCount === 1 && measureCount >= 3) {
          vizType = 'Parallel Coordinates or Multi-Measure Table';
          vizDetails.push(`${measureCount} measures for each ${dimensions[0]?.fieldName}`);
        } else if (dimCount >= 2 && measureCount >= 1) {
          vizType = 'Cross-Tab / Pivot Table / Heat Map';
          vizDetails.push(`${dimCount} dimensions with ${measureCount} measure(s)`);
        } else if (dimCount >= 1 && measureCount === 0) {
          vizType = 'Text Table / List';
          vizDetails.push('Dimension-only view, likely a table or filter list');
        }
        
        return {
          type: vizType,
          details: vizDetails,
          analysis: {
            dimensions: dimensions.map(d => d.fieldName),
            measures: measures.map(m => m.fieldName),
            hasDateDimension: hasDateDim,
            hasGeoDimension: hasGeoDim,
            rowCount: rowCount
          }
        };
      }
      
      // Generate comprehensive documentation data (module-level for access from executeToolCall)
      async function generateDocumentationData(options = {}) {
        const dashboard = tableau.extensions.dashboardContent.dashboard;
        const docData = {
          dashboardName: dashboard.name,
          generatedAt: new Date().toISOString(),
          worksheets: [],
          dataSources: [],
          parameters: [],
          filters: []
        };
        
        // Get parameters
        if (options.includeParameters !== false) {
          try {
            const params = await dashboard.getParametersAsync();
            docData.parameters = params.map(p => ({
              name: p.name,
              dataType: p.dataType,
              currentValue: p.currentValue?.value,
              allowableValuesType: p.allowableValues?.type
            }));
          } catch (e) {
            console.log('Could not get parameters:', e);
          }
        }
        
        // Process each worksheet
        for (const ws of dashboard.worksheets) {
          const wsData = {
            name: ws.name,
            sheetType: ws.sheetType,
            size: ws.size ? { width: ws.size.width, height: ws.size.height } : null,
            filters: [],
            dataSources: [],
            columns: [],      // Fields used in the viz (from summary data)
            markType: null,   // Mark type if available
            inferredVizType: null,  // Inferred visualization type
            dimensionCount: 0,
            measureCount: 0
          };
          
          // Get summary data columns to see what fields are used in the viz
          try {
            const summaryData = await ws.getSummaryDataAsync({ maxRows: 10 });
            
            // Try to get field roles from the data source
            let fieldRoles = {};
            try {
              const dataSources = await ws.getDataSourcesAsync();
              if (dataSources.length > 0) {
                const fields = await dataSources[0].getFieldsAsync();
                for (const f of fields) {
                  fieldRoles[f.name] = f.role;
                }
              }
            } catch (e) {
              console.log('Could not get field roles for', ws.name);
            }
            
            wsData.columns = summaryData.columns.map(col => {
              // Determine role - check from data source or infer from data type
              let role = fieldRoles[col.fieldName] || null;
              if (!role) {
                // Infer role based on data type
                if (['int', 'float', 'real', 'integer'].includes(col.dataType?.toLowerCase())) {
                  role = 'measure';
                } else {
                  role = 'dimension';
                }
              }
              return {
                fieldName: col.fieldName,
                dataType: col.dataType,
                isReferenced: col.isReferenced,
                role: role
              };
            });
            
            // Count dimensions and measures
            wsData.dimensionCount = wsData.columns.filter(c => c.role === 'dimension').length;
            wsData.measureCount = wsData.columns.filter(c => c.role === 'measure').length;
            
            // Infer visualization type based on field configuration
            wsData.inferredVizType = inferVisualizationType(wsData.columns, summaryData);
            
          } catch (e) {
            console.log('Could not get summary data for', ws.name, e);
          }
          
          // Get filters for this worksheet
          if (options.includeWorksheets !== false) {
            try {
              const filters = await ws.getFiltersAsync();
              wsData.filters = filters.map(f => ({
                fieldName: f.fieldName,
                filterType: f.filterType,
                appliedValues: f.appliedValues?.map(v => v.value) || []
              }));
              
              // Add to global filters list
              for (const f of wsData.filters) {
                docData.filters.push({
                  worksheet: ws.name,
                  fieldName: f.fieldName,
                  filterType: f.filterType
                });
              }
            } catch (e) {
              // Some worksheets may not support filters
            }
          }
          
          // Get data sources for this worksheet
          if (options.includeDataSources !== false) {
            try {
              const dataSources = await ws.getDataSourcesAsync();
              for (const ds of dataSources) {
                wsData.dataSources.push({ name: ds.name });
                
                // Check if we already processed this data source
                if (!docData.dataSources.find(d => d.name === ds.name)) {
                  const dsData = {
                    name: ds.name,
                    isExtract: ds.isExtract,
                    fields: [],
                    tables: [],
                    connectionInfo: null
                  };
                  
                  // Get fields
                  if (options.includeFields !== false) {
                    try {
                      const fields = await ds.getFieldsAsync();
                      dsData.fields = fields.map(f => ({
                        name: f.name,
                        dataType: f.dataType,
                        role: f.role,
                        isCalculatedField: f.isCalculatedField,
                        description: f.description || null
                      }));
                    } catch (e) {
                      console.log('Could not get fields for', ds.name, e);
                    }
                  }
                  
                  // Get tables (active tables)
                  try {
                    const tables = await ds.getActiveTablesAsync();
                    dsData.tables = tables.map(t => ({
                      name: t.name,
                      connectionId: t.connectionId
                    }));
                  } catch (e) {
                    console.log('Could not get tables for', ds.name, e);
                  }
                  
                  // Get connection info
                  try {
                    const connections = await ds.getConnectionSummariesAsync();
                    if (connections.length > 0) {
                      const conn = connections[0];
                      dsData.connectionInfo = {
                        type: conn.type,
                        serverName: conn.serverName || null,
                        databaseName: conn.databaseName || null
                      };
                    }
                  } catch (e) {
                    console.log('Could not get connection info for', ds.name, e);
                  }
                  
                  docData.dataSources.push(dsData);
                }
              }
            } catch (e) {
              console.log('Could not get data sources for worksheet', ws.name, e);
            }
          }
          
          docData.worksheets.push(wsData);
        }
        
        return docData;
      }

      function callMCP(method, params) {
        return new Promise((resolve, reject) => {
          if (!mcpSocket || mcpSocket.readyState !== WebSocket.OPEN) {
            reject(new Error('MCP not connected'));
            return;
          }

          const id = ++mcpRequestId;
          mcpCallbacks[id] = (response) => {
            if (response.error) reject(new Error(response.error.message));
            else resolve(response.result);
          };

          mcpSocket.send(JSON.stringify({
            jsonrpc: '2.0',
            id: id,
            method: 'tools/call',
            params: { name: method, arguments: params }
          }));

          setTimeout(() => {
            if (mcpCallbacks[id]) {
              delete mcpCallbacks[id];
              reject(new Error('MCP request timeout'));
            }
          }, 30000);
        });
      }

      // Refresh Data button handler (only if element exists - removed from main UI)
      if (btnRefreshData) {
        btnRefreshData.addEventListener('click', async () => {
          btnRefreshData.disabled = true;
          btnRefreshData.textContent = 'Loading...';

          try {
            await fetchDashboardContext();
          } catch (error) {
            if (dashboardInfo) {
              dashboardInfo.innerHTML = '<p style="color:var(--error);font-size:13px">Failed to load: ' + error.message + '</p>';
            }
          } finally {
            btnRefreshData.disabled = false;
            btnRefreshData.textContent = 'Refresh Data';
          }
        });
      }

      // Settings
      btnSettings.addEventListener('click', () => {
        // Load current settings into the form
        document.getElementById('openai-api-key').value = settings.openaiApiKey;
        document.getElementById('anthropic-api-key').value = settings.anthropicApiKey;
        document.getElementById('model-vision').value = settings.modelVision;
        document.getElementById('model-generation').value = settings.modelGeneration;
        document.getElementById('model-analysis').value = settings.modelAnalysis;
        document.getElementById('mcp-url').value = settings.mcpUrl;
        settingsModal.classList.add('active');
      });

      btnCloseSettings.addEventListener('click', () => settingsModal.classList.remove('active'));
      btnCancelSettings.addEventListener('click', () => settingsModal.classList.remove('active'));

      btnSaveSettings.addEventListener('click', () => {
        // Save all settings
        settings.openaiApiKey = document.getElementById('openai-api-key').value;
        settings.anthropicApiKey = document.getElementById('anthropic-api-key').value;
        settings.modelVision = document.getElementById('model-vision').value;
        settings.modelGeneration = document.getElementById('model-generation').value;
        settings.modelAnalysis = document.getElementById('model-analysis').value;
        settings.mcpUrl = document.getElementById('mcp-url').value;

        // Persist to localStorage
        localStorage.setItem('dashagent_openai_apikey', settings.openaiApiKey);
        localStorage.setItem('dashagent_anthropic_apikey', settings.anthropicApiKey);
        localStorage.setItem('dashagent_model_vision', settings.modelVision);
        localStorage.setItem('dashagent_model_generation', settings.modelGeneration);
        localStorage.setItem('dashagent_model_analysis', settings.modelAnalysis);
        localStorage.setItem('dashagent_mcpurl', settings.mcpUrl);

        settingsModal.classList.remove('active');
        connectMCP();
        
        // Show confirmation
        addMessage('system', 'Settings saved! Model configuration:\n- **Vision/Design:** ' + settings.modelVision + '\n- **Code Generation:** ' + settings.modelGeneration + '\n- **Data Analysis:** ' + settings.modelAnalysis);
      });

      // Save & Close
      btnSave.addEventListener('click', () => {
        tableau.extensions.settings.set('dashagent_html', generatedHtml);
        tableau.extensions.settings.saveAsync().then(() => {
          tableau.extensions.ui.closeDialog('saved');
        });
      });

      // Initialize
      tableau.extensions.initializeDialogAsync().then(async function(openPayload) {
        console.log('Dialog initialized successfully');
        statusText.textContent = 'Connecting...';
        
        // Load any existing content
        try {
          const existingHtml = tableau.extensions.settings.get('dashagent_html');
          if (existingHtml) {
            generatedHtml = existingHtml;
            previewContainer.innerHTML = generatedHtml;
          }
        } catch (e) {
          console.log('No existing HTML to load');
        }

        // Load dashboard context with timeout
        try {
          console.log('Fetching dashboard context...');
          
          // Add timeout wrapper
          const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 10000)
          );
          
          await Promise.race([fetchDashboardContext(), timeoutPromise]);
          
          statusDot.classList.add('connected');
          statusText.textContent = 'Connected';
          console.log('Dashboard context ready:', dashboardContext);
          
          // Load saved viz configs after dashboard is ready
          loadVizConfigs();
          
        } catch (e) {
          console.error('Dashboard context error:', e);
          statusDot.classList.add('connected'); // Still show connected since we're in Tableau
          statusText.textContent = 'Ready';
          
          // Still try to load viz configs
          loadVizConfigs();
        }

        // Connect to MCP bridge (optional, for external AI tools)
        try {
          connectMCP();
        } catch (e) {
          console.log('MCP bridge not available:', e);
        }
      }).catch(function(error) {
        console.error('Dialog init failed:', error);
        statusText.textContent = 'Error: ' + (error.message || 'Init failed');
      });
    }
  </script>
</body>
</html>
